<!doctype html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <link href="es-spec.css" type="text/css" rel="stylesheet">
    </link>
  </head>
  <body>
    <section id="everything">
      <div id="unofficial">
        <p>
          <strong>This is <em>not</em> the official ECMAScript Language Specification.</strong>
        </p>
        <p>The most recent final ECMAScript standard is Edition 5.1, the PDF document located at <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf">http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf</a>.</p>
        <p>This is a draft of the next version of the standard. If all goes well it will become ECMAScript Edition 6.</p>
        <p>This is an HTML version of the current working draft published at <a href="http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts">http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts</a>. The program used to convert that Word doc to HTML is a custom-piled heap of hacks. Currently it is pretty bad. It has stripped out most of the formatting that makes the specification comprehensible. You can help improve the program <a href="https://github.com/jorendorff/es-spec-html">here</a>.</p>
        <p>For copyright information, see ECMA's legal disclaimer in the document itself.</p>
      </div>
      <p>
        <div>
          <p>
          </p>
          <p>ECMA-262</p>
          <p>6<sup>th</sup> Edition / Draft February 27 , 2012</p>
        </div>
        <p>ECMAScript Language Specification</p>
        <p>Draft</p>
        <p>Ecma/TC39/2011/0xx</p>
        <div>
          <p>
          </p>
          <p>Draft</p>
          <p>
          </p>
        </div>
      </p>
      <p>
        <hr>
      </p>
      <p>
      </p>
      <p>Contents	Page</p>
      <p>Introduction<span>	vii</span></p>
      <p>{ TOC \o "1-3" \h \z }<div>1	Scope	{ PAGEREF _Toc318131229 \h }1</div></p>
      <p>
        <div>2	Conformance	{ PAGEREF _Toc318131230 \h }1</div>
      </p>
      <p>
        <div>3	Normative references	{ PAGEREF _Toc318131231 \h }1</div>
      </p>
      <p>
        <div>4	Overview	{ PAGEREF _Toc318131232 \h }1</div>
      </p>
      <p>
        <div>4.1	Web Scripting	{ PAGEREF _Toc318131233 \h }2</div>
      </p>
      <p>
        <div>4.2	Language Overview	{ PAGEREF _Toc318131234 \h }2</div>
      </p>
      <p>
        <div>4.2.1	Objects	{ PAGEREF _Toc318131235 \h }3</div>
      </p>
      <p>
        <div>4.2.2	The Strict Variant of ECMAScript	{ PAGEREF _Toc318131236 \h }4</div>
      </p>
      <p>
        <div>4.3	Terms and definitions	{ PAGEREF _Toc318131237 \h }4</div>
      </p>
      <p>
        <div>5	Notational Conventions	{ PAGEREF _Toc318131238 \h }7</div>
      </p>
      <p>
        <div>5.1	Syntactic and Lexical Grammars	{ PAGEREF _Toc318131239 \h }7</div>
      </p>
      <p>
        <div>5.1.1	Context-Free Grammars	{ PAGEREF _Toc318131240 \h }7</div>
      </p>
      <p>
        <div>5.1.2	The Lexical and RegExp Grammars	{ PAGEREF _Toc318131241 \h }8</div>
      </p>
      <p>
        <div>5.1.3	The Numeric String Grammar	{ PAGEREF _Toc318131242 \h }8</div>
      </p>
      <p>
        <div>5.1.4	The Syntactic Grammar	{ PAGEREF _Toc318131243 \h }8</div>
      </p>
      <p>
        <div>5.1.5	The JSON Grammar	{ PAGEREF _Toc318131244 \h }9</div>
      </p>
      <p>
        <div>5.1.6	Grammar Notation	{ PAGEREF _Toc318131245 \h }9</div>
      </p>
      <p>
        <div>5.2	Algorithm Conventions	{ PAGEREF _Toc318131246 \h }12</div>
      </p>
      <p>
        <div>5.3 Static Semantic Rules	{ PAGEREF _Toc318131247 \h }13</div>
      </p>
      <p>
        <div>6	Source Text	{ PAGEREF _Toc318131248 \h }13</div>
      </p>
      <p>
        <div>7	Lexical Conventions	{ PAGEREF _Toc318131249 \h }14</div>
      </p>
      <p>
        <div>7.1	Unicode Format-Control Characters	{ PAGEREF _Toc318131250 \h }14</div>
      </p>
      <p>
        <div>7.2	White Space	{ PAGEREF _Toc318131251 \h }15</div>
      </p>
      <p>
        <div>7.3	Line Terminators	{ PAGEREF _Toc318131252 \h }15</div>
      </p>
      <p>
        <div>7.4	Comments	{ PAGEREF _Toc318131253 \h }16</div>
      </p>
      <p>
        <div>7.5	Tokens	{ PAGEREF _Toc318131254 \h }17</div>
      </p>
      <p>
        <div>7.6	Identifier Names and Identifiers	{ PAGEREF _Toc318131255 \h }17</div>
      </p>
      <p>
        <div>7.6.1	Reserved Words	{ PAGEREF _Toc318131256 \h }18</div>
      </p>
      <p>
        <div>7.7	Punctuators	{ PAGEREF _Toc318131257 \h }20</div>
      </p>
      <p>
        <div>7.8	Literals	{ PAGEREF _Toc318131258 \h }20</div>
      </p>
      <p>
        <div>7.8.1	Null Literals	{ PAGEREF _Toc318131259 \h }20</div>
      </p>
      <p>
        <div>7.8.2	Boolean Literals	{ PAGEREF _Toc318131260 \h }20</div>
      </p>
      <p>
        <div>7.8.3	Numeric Literals	{ PAGEREF _Toc318131261 \h }21</div>
      </p>
      <p>
        <div>7.8.4	String Literals	{ PAGEREF _Toc318131262 \h }23</div>
      </p>
      <p>
        <div>7.8.5	Regular Expression Literals	{ PAGEREF _Toc318131263 \h }25</div>
      </p>
      <p>
        <div>7.9	Automatic Semicolon Insertion	{ PAGEREF _Toc318131264 \h }26</div>
      </p>
      <p>
        <div>7.9.1	Rules of Automatic Semicolon Insertion	{ PAGEREF _Toc318131265 \h }26</div>
      </p>
      <p>
        <div>7.9.2	Examples of Automatic Semicolon Insertion	{ PAGEREF _Toc318131266 \h }27</div>
      </p>
      <p>
        <div>8	Types	{ PAGEREF _Toc318131267 \h }29</div>
      </p>
      <p>
        <div>8.1	The Undefined Type	{ PAGEREF _Toc318131268 \h }29</div>
      </p>
      <p>
        <div>8.2	The Null Type	{ PAGEREF _Toc318131269 \h }29</div>
      </p>
      <p>
        <div>8.3	The Boolean Type	{ PAGEREF _Toc318131270 \h }29</div>
      </p>
      <p>
        <div>8.4	The String Type	{ PAGEREF _Toc318131271 \h }29</div>
      </p>
      <p>
        <div>8.5	The Number Type	{ PAGEREF _Toc318131272 \h }30</div>
      </p>
      <p>
        <div>8.6	The Object Type	{ PAGEREF _Toc318131273 \h }31</div>
      </p>
      <p>
        <div>8.6.1	Property Attributes	{ PAGEREF _Toc318131274 \h }31</div>
      </p>
      <p>
        <div>8.6.2	Object Internal Properties and Methods	{ PAGEREF _Toc318131275 \h }32</div>
      </p>
      <p>
        <div>8.7	The List and Record Specification Type	{ PAGEREF _Toc318131276 \h }36</div>
      </p>
      <p>
        <div>8.8	The Completion Record Specification Type	{ PAGEREF _Toc318131277 \h }36</div>
      </p>
      <p>
        <div>8.9	The Reference Specification Type	{ PAGEREF _Toc318131278 \h }37</div>
      </p>
      <p>
        <div>8.9.1	GetValue (V)	{ PAGEREF _Toc318131279 \h }38</div>
      </p>
      <p>
        <div>8.9.2	PutValue (V, W)	{ PAGEREF _Toc318131280 \h }38</div>
      </p>
      <p>
        <div>8.10 	The Property Descriptor and Property Identifier Specification Types	{ PAGEREF _Toc318131281 \h }39</div>
      </p>
      <p>
        <div>8.10.1	IsAccessorDescriptor ( Desc )	{ PAGEREF _Toc318131282 \h }40</div>
      </p>
      <p>
        <div>8.10.2	IsDataDescriptor ( Desc )	{ PAGEREF _Toc318131283 \h }40</div>
      </p>
      <p>
        <div>8.10.3	IsGenericDescriptor ( Desc )	{ PAGEREF _Toc318131284 \h }40</div>
      </p>
      <p>
        <div>8.10.4	FromPropertyDescriptor ( Desc )	{ PAGEREF _Toc318131285 \h }40</div>
      </p>
      <p>
        <div>8.10.5	ToPropertyDescriptor ( Obj )	{ PAGEREF _Toc318131286 \h }41</div>
      </p>
      <p>
        <div>8.11	The Lexical Environment and Environment Record Specification Types	{ PAGEREF _Toc318131287 \h }41</div>
      </p>
      <p>
        <div>8.12	Algorithms for Object Internal Methods	{ PAGEREF _Toc318131288 \h }41</div>
      </p>
      <p>
        <div>8.12.1	[[GetOwnProperty]] (P)	{ PAGEREF _Toc318131289 \h }42</div>
      </p>
      <p>
        <div>8.12.2	[[GetProperty]] (P)	{ PAGEREF _Toc318131290 \h }42</div>
      </p>
      <p>
        <div>8.12.3	[[Get]] (P)	{ PAGEREF _Toc318131291 \h }42</div>
      </p>
      <p>
        <div>8.12.4	[[CanPut]] (P)	{ PAGEREF _Toc318131292 \h }42</div>
      </p>
      <p>
        <div>8.12.5	[[Put]] ( P, V, Throw )	{ PAGEREF _Toc318131293 \h }43</div>
      </p>
      <p>
        <div>8.12.6	[[HasProperty]] (P)	{ PAGEREF _Toc318131294 \h }43</div>
      </p>
      <p>
        <div>8.12.7	[[Delete]] (P, Throw)	{ PAGEREF _Toc318131295 \h }43</div>
      </p>
      <p>
        <div>8.12.8	[[DefaultValue]] (hint)	{ PAGEREF _Toc318131296 \h }44</div>
      </p>
      <p>
        <div>8.12.9	[[DefineOwnProperty]] (P, Desc, Throw)	{ PAGEREF _Toc318131297 \h }44</div>
      </p>
      <p>
        <div>8.12.10	[[Enumerate]] (includePrototype, onlyEnumerable )	{ PAGEREF _Toc318131298 \h }45</div>
      </p>
      <p>
        <div>8.12.11	[[Iterate]] ( )	{ PAGEREF _Toc318131299 \h }46</div>
      </p>
      <p>
        <div>9 Abstract Operations	{ PAGEREF _Toc318131300 \h }46</div>
      </p>
      <p>
        <div>9.1	Type Conversion and Testing	{ PAGEREF _Toc318131301 \h }46</div>
      </p>
      <p>
        <div>9.1.1	ToPrimitive	{ PAGEREF _Toc318131302 \h }46</div>
      </p>
      <p>
        <div>9.1.2	ToBoolean	{ PAGEREF _Toc318131303 \h }47</div>
      </p>
      <p>
        <div>9.1.3	ToNumber	{ PAGEREF _Toc318131304 \h }48</div>
      </p>
      <p>
        <div>9.1.4	ToInteger	{ PAGEREF _Toc318131305 \h }50</div>
      </p>
      <p>
        <div>9.1.5	ToInt32: (Signed 32 Bit Integer)	{ PAGEREF _Toc318131306 \h }51</div>
      </p>
      <p>
        <div>9.1.6	ToUint32: (Unsigned 32 Bit Integer)	{ PAGEREF _Toc318131307 \h }51</div>
      </p>
      <p>
        <div>9.1.7	ToUint16: (Unsigned 16 Bit Integer)	{ PAGEREF _Toc318131308 \h }51</div>
      </p>
      <p>
        <div>9.1.8	ToString	{ PAGEREF _Toc318131309 \h }52</div>
      </p>
      <p>
        <div>9.1.9	ToObject	{ PAGEREF _Toc318131310 \h }53</div>
      </p>
      <p>
        <div>9.2	Testing and Comparision Operations	{ PAGEREF _Toc318131311 \h }53</div>
      </p>
      <p>
        <div>9.2.1	CheckObjectCoercible	{ PAGEREF _Toc318131312 \h }53</div>
      </p>
      <p>
        <div>9.2.2	IsCallable	{ PAGEREF _Toc318131313 \h }53</div>
      </p>
      <p>
        <div>9.2.3	The SameValue Algorithm	{ PAGEREF _Toc318131314 \h }54</div>
      </p>
      <p>
        <div>9.3	Property Access Operations	{ PAGEREF _Toc318131315 \h }54</div>
      </p>
      <p>
        <div>9.3.1	Invoke	{ PAGEREF _Toc318131316 \h }54</div>
      </p>
      <p>
        <div>10	Executable Code and Execution Contexts	{ PAGEREF _Toc318131317 \h }55</div>
      </p>
      <p>
        <div>10.1	Types of Executable Code	{ PAGEREF _Toc318131318 \h }55</div>
      </p>
      <p>
        <div>10.1.1	Strict Mode Code	{ PAGEREF _Toc318131319 \h }55</div>
      </p>
      <p>
        <div>10.2	Lexical Environments	{ PAGEREF _Toc318131320 \h }55</div>
      </p>
      <p>
        <div>10.2.1	Environment Records	{ PAGEREF _Toc318131321 \h }56</div>
      </p>
      <p>
        <div>10.2.2	Lexical Environment Operations	{ PAGEREF _Toc318131322 \h }60</div>
      </p>
      <p>
        <div>10.2.3	The Global Environment	{ PAGEREF _Toc318131323 \h }61</div>
      </p>
      <p>
        <div>10.3	Execution Contexts	{ PAGEREF _Toc318131324 \h }61</div>
      </p>
      <p>
        <div>10.3.1	Identifier Resolution	{ PAGEREF _Toc318131325 \h }62</div>
      </p>
      <p>
        <div>10.4	Establishing an Execution Context	{ PAGEREF _Toc318131326 \h }62</div>
      </p>
      <p>
        <div>10.4.1	Entering Global Code	{ PAGEREF _Toc318131327 \h }62</div>
      </p>
      <p>
        <div>10.4.2	Entering Eval Code	{ PAGEREF _Toc318131328 \h }62</div>
      </p>
      <p>
        <div>10.4.3	Entering Function Code	{ PAGEREF _Toc318131329 \h }63</div>
      </p>
      <p>
        <div>10.5	Declaration Binding Instantiation	{ PAGEREF _Toc318131330 \h }63</div>
      </p>
      <p>
        <div>10.5.1	Top-Level Declaration Instantiation	{ PAGEREF _Toc318131331 \h }63</div>
      </p>
      <p>
        <div>10.5.2	Module Declaration Instantiation	{ PAGEREF _Toc318131332 \h }64</div>
      </p>
      <p>
        <div>10.5.3	Function Declaration Instantiation	{ PAGEREF _Toc318131333 \h }64</div>
      </p>
      <p>
        <div>10.5.4	Block Declaration Instantiation	{ PAGEREF _Toc318131334 \h }65</div>
      </p>
      <p>
        <div>10.6	Arguments Object	{ PAGEREF _Toc318131335 \h }66</div>
      </p>
      <p>
        <div>11	Expressions	{ PAGEREF _Toc318131336 \h }69</div>
      </p>
      <p>
        <div>11.1	Primary Expressions	{ PAGEREF _Toc318131337 \h }69</div>
      </p>
      <p>
        <div>11.1.1	The this Keyword	{ PAGEREF _Toc318131338 \h }69</div>
      </p>
      <p>
        <div>11.1.2	Identifier Reference	{ PAGEREF _Toc318131339 \h }69</div>
      </p>
      <p>
        <div>11.1.3	Literal Reference	{ PAGEREF _Toc318131340 \h }69</div>
      </p>
      <p>
        <div>11.1.4	Array Initialiser	{ PAGEREF _Toc318131341 \h }69</div>
      </p>
      <p>
        <div>11.1.5	Object Initialiser	{ PAGEREF _Toc318131342 \h }72</div>
      </p>
      <p>
        <div>11.1.6	Function Expressions	{ PAGEREF _Toc318131343 \h }77</div>
      </p>
      <p>
        <div>11.1.7	Generator Comprehensions	{ PAGEREF _Toc318131344 \h }77</div>
      </p>
      <p>
        <div>11.1.8	The Grouping Operator	{ PAGEREF _Toc318131345 \h }77</div>
      </p>
      <p>
        <div>11.2	Left-Hand-Side Expressions	{ PAGEREF _Toc318131346 \h }78</div>
      </p>
      <p>
        <div>11.2.1	Property Accessors	{ PAGEREF _Toc318131347 \h }78</div>
      </p>
      <p>
        <div>11.2.2	The new Operator	{ PAGEREF _Toc318131348 \h }79</div>
      </p>
      <p>
        <div>11.2.3	Function Calls	{ PAGEREF _Toc318131349 \h }80</div>
      </p>
      <p>
        <div>11.2.4	The super Keyword	{ PAGEREF _Toc318131350 \h }80</div>
      </p>
      <p>
        <div>11.2.5	Argument Lists	{ PAGEREF _Toc318131351 \h }81</div>
      </p>
      <p>
        <div>11.3	Postfix Expressions	{ PAGEREF _Toc318131352 \h }82</div>
      </p>
      <p>
        <div>11.3.1	Postfix Increment Operator	{ PAGEREF _Toc318131353 \h }82</div>
      </p>
      <p>
        <div>11.3.2	Postfix Decrement Operator	{ PAGEREF _Toc318131354 \h }83</div>
      </p>
      <p>
        <div>11.4	Unary Operators	{ PAGEREF _Toc318131355 \h }83</div>
      </p>
      <p>
        <div>11.4.1	The delete Operator	{ PAGEREF _Toc318131356 \h }83</div>
      </p>
      <p>
        <div>11.4.2	The void Operator	{ PAGEREF _Toc318131357 \h }84</div>
      </p>
      <p>
        <div>11.4.3	The typeof Operator	{ PAGEREF _Toc318131358 \h }84</div>
      </p>
      <p>
        <div>11.4.4	Prefix Increment Operator	{ PAGEREF _Toc318131359 \h }85</div>
      </p>
      <p>
        <div>11.4.5	Prefix Decrement Operator	{ PAGEREF _Toc318131360 \h }85</div>
      </p>
      <p>
        <div>11.4.6	Unary + Operator	{ PAGEREF _Toc318131361 \h }85</div>
      </p>
      <p>
        <div>11.4.7	Unary - Operator	{ PAGEREF _Toc318131362 \h }85</div>
      </p>
      <p>
        <div>11.4.8	Bitwise NOT Operator ( ~ )	{ PAGEREF _Toc318131363 \h }86</div>
      </p>
      <p>
        <div>11.4.9	Logical NOT Operator ( ! )	{ PAGEREF _Toc318131364 \h }86</div>
      </p>
      <p>
        <div>11.5	Multiplicative Operators	{ PAGEREF _Toc318131365 \h }86</div>
      </p>
      <p>
        <div>11.5.1	Applying the * Operator	{ PAGEREF _Toc318131366 \h }86</div>
      </p>
      <p>
        <div>11.5.2	Applying the / Operator	{ PAGEREF _Toc318131367 \h }87</div>
      </p>
      <p>
        <div>11.5.3	Applying the % Operator	{ PAGEREF _Toc318131368 \h }87</div>
      </p>
      <p>
        <div>11.6	Additive Operators	{ PAGEREF _Toc318131369 \h }88</div>
      </p>
      <p>
        <div>11.6.1	The Addition operator ( + )	{ PAGEREF _Toc318131370 \h }88</div>
      </p>
      <p>
        <div>11.6.2	The Subtraction Operator ( - )	{ PAGEREF _Toc318131371 \h }88</div>
      </p>
      <p>
        <div>11.6.3	Applying the Additive Operators to Numbers	{ PAGEREF _Toc318131372 \h }89</div>
      </p>
      <p>
        <div>11.7	Bitwise Shift Operators	{ PAGEREF _Toc318131373 \h }89</div>
      </p>
      <p>
        <div>11.7.1	The Left Shift Operator ( &lt;&lt; )	{ PAGEREF _Toc318131374 \h }89</div>
      </p>
      <p>
        <div>11.7.2	The Signed Right Shift Operator ( &gt;&gt; )	{ PAGEREF _Toc318131375 \h }90</div>
      </p>
      <p>
        <div>11.7.3	The Unsigned Right Shift Operator ( &gt;&gt;&gt; )	{ PAGEREF _Toc318131376 \h }90</div>
      </p>
      <p>
        <div>11.8	Relational Operators	{ PAGEREF _Toc318131377 \h }91</div>
      </p>
      <p>
        <div>11.8.1 Runtime Semantics	{ PAGEREF _Toc318131378 \h }91</div>
      </p>
      <p>
        <div>11.9	Equality Operators	{ PAGEREF _Toc318131379 \h }93</div>
      </p>
      <p>
        <div>11.9.1 Runtime Semantics	{ PAGEREF _Toc318131380 \h }94</div>
      </p>
      <p>
        <div>11.10	Binary Bitwise Operators	{ PAGEREF _Toc318131381 \h }96</div>
      </p>
      <p>
        <div>11.11	Binary Logical Operators	{ PAGEREF _Toc318131382 \h }97</div>
      </p>
      <p>
        <div>11.12	Conditional Operator ( ? : )	{ PAGEREF _Toc318131383 \h }98</div>
      </p>
      <p>
        <div>11.13	Assignment Operators	{ PAGEREF _Toc318131384 \h }98</div>
      </p>
      <p>
        <div>Static Semantics	{ PAGEREF _Toc318131385 \h }99</div>
      </p>
      <p>
        <div>Runtime Semantics	{ PAGEREF _Toc318131386 \h }99</div>
      </p>
      <p>
        <div>11.13.1 Destructuring Assignment	{ PAGEREF _Toc318131387 \h }100</div>
      </p>
      <p>
        <div>11.14	Comma Operator ( , )	{ PAGEREF _Toc318131388 \h }103</div>
      </p>
      <p>
        <div>12	Statements and Declarations	{ PAGEREF _Toc318131389 \h }104</div>
      </p>
      <p>
        <div>Static Semantics	{ PAGEREF _Toc318131390 \h }104</div>
      </p>
      <p>
        <div>Runtime Semantics	{ PAGEREF _Toc318131391 \h }105</div>
      </p>
      <p>
        <div>12.1	Block	{ PAGEREF _Toc318131392 \h }106</div>
      </p>
      <p>
        <div>12.2	Declarations and the Variable Statement	{ PAGEREF _Toc318131393 \h }108</div>
      </p>
      <p>
        <div>12.2.1	Let and Const Declarations	{ PAGEREF _Toc318131394 \h }108</div>
      </p>
      <p>
        <div>12.2.2	Variable Statement	{ PAGEREF _Toc318131395 \h }111</div>
      </p>
      <p>
        <div>12.2.4	Destructuring Binding Patterns	{ PAGEREF _Toc318131396 \h }114</div>
      </p>
      <p>
        <div>12.3	Empty Statement	{ PAGEREF _Toc318131397 \h }120</div>
      </p>
      <p>
        <div>12.4	Expression Statement	{ PAGEREF _Toc318131398 \h }120</div>
      </p>
      <p>
        <div>12.5	The if Statement	{ PAGEREF _Toc318131399 \h }121</div>
      </p>
      <p>
        <div>12.6	Iteration Statements	{ PAGEREF _Toc318131400 \h }122</div>
      </p>
      <p>
        <div>12.6.1	The do-while Statement	{ PAGEREF _Toc318131401 \h }122</div>
      </p>
      <p>
        <div>12.6.2	The while Statement	{ PAGEREF _Toc318131402 \h }123</div>
      </p>
      <p>
        <div>12.6.3	The for Statement	{ PAGEREF _Toc318131403 \h }123</div>
      </p>
      <p>
        <div>12.6.4	The for-in and for-of Statements	{ PAGEREF _Toc318131404 \h }125</div>
      </p>
      <p>
        <div>12.7	The continue Statement	{ PAGEREF _Toc318131405 \h }129</div>
      </p>
      <p>
        <div>12.8	The break Statement	{ PAGEREF _Toc318131406 \h }129</div>
      </p>
      <p>
        <div>12.9	The return Statement	{ PAGEREF _Toc318131407 \h }130</div>
      </p>
      <p>
        <div>12.10	The with Statement	{ PAGEREF _Toc318131408 \h }130</div>
      </p>
      <p>
        <div>12.11	The switch Statement	{ PAGEREF _Toc318131409 \h }131</div>
      </p>
      <p>
        <div>12.12	Labelled Statements	{ PAGEREF _Toc318131410 \h }135</div>
      </p>
      <p>
        <div>12.13	The throw Statement	{ PAGEREF _Toc318131411 \h }136</div>
      </p>
      <p>
        <div>12.14	The try Statement	{ PAGEREF _Toc318131412 \h }137</div>
      </p>
      <p>
        <div>12.15	The debugger statement	{ PAGEREF _Toc318131413 \h }139</div>
      </p>
      <p>
        <div>13	Functions and Generators	{ PAGEREF _Toc318131414 \h }139</div>
      </p>
      <p>
        <div>13.1	Function Definitions	{ PAGEREF _Toc318131415 \h }139</div>
      </p>
      <p>
        <div>13.1.1	Creating Function Objects	{ PAGEREF _Toc318131416 \h }144</div>
      </p>
      <p>
        <div>13.2	Generator Definitions	{ PAGEREF _Toc318131417 \h }146</div>
      </p>
      <p>
        <div>14	Program	{ PAGEREF _Toc318131418 \h }146</div>
      </p>
      <p>
        <div>14.1	Directive Prologues and the Use Strict Directive	{ PAGEREF _Toc318131419 \h }147</div>
      </p>
      <p>
        <div>15	Standard Built-in ECMAScript Objects	{ PAGEREF _Toc318131420 \h }147</div>
      </p>
      <p>
        <div>15.1	The Global Object	{ PAGEREF _Toc318131421 \h }148</div>
      </p>
      <p>
        <div>15.1.1	Value Properties of the Global Object	{ PAGEREF _Toc318131422 \h }149</div>
      </p>
      <p>
        <div>15.1.2	Function Properties of the Global Object	{ PAGEREF _Toc318131423 \h }149</div>
      </p>
      <p>
        <div>15.1.3	URI Handling Function Properties	{ PAGEREF _Toc318131424 \h }151</div>
      </p>
      <p>
        <div>15.1.4	Constructor Properties of the Global Object	{ PAGEREF _Toc318131425 \h }155</div>
      </p>
      <p>
        <div>15.1.5	Other Properties of the Global Object	{ PAGEREF _Toc318131426 \h }156</div>
      </p>
      <p>
        <div>15.2	Object Objects	{ PAGEREF _Toc318131427 \h }156</div>
      </p>
      <p>
        <div>15.2.1	The Object Constructor Called as a Function	{ PAGEREF _Toc318131428 \h }156</div>
      </p>
      <p>
        <div>15.2.2	The Object Constructor	{ PAGEREF _Toc318131429 \h }157</div>
      </p>
      <p>
        <div>15.2.3	Properties of the Object Constructor	{ PAGEREF _Toc318131430 \h }157</div>
      </p>
      <p>
        <div>15.2.4	Properties of the Object Prototype Object	{ PAGEREF _Toc318131431 \h }160</div>
      </p>
      <p>
        <div>15.2.5	Properties of Object Instances	{ PAGEREF _Toc318131432 \h }162</div>
      </p>
      <p>
        <div>15.3	Function Objects	{ PAGEREF _Toc318131433 \h }162</div>
      </p>
      <p>
        <div>15.3.1	The Function Constructor Called as a Function	{ PAGEREF _Toc318131434 \h }162</div>
      </p>
      <p>
        <div>15.3.2	The Function Constructor	{ PAGEREF _Toc318131435 \h }162</div>
      </p>
      <p>
        <div>15.3.3	Properties of the Function Constructor	{ PAGEREF _Toc318131436 \h }163</div>
      </p>
      <p>
        <div>15.3.4	Properties of the Function Prototype Object	{ PAGEREF _Toc318131437 \h }163</div>
      </p>
      <p>
        <div>15.3.5	Properties of Function Instances	{ PAGEREF _Toc318131438 \h }166</div>
      </p>
      <p>
        <div>15.4	Array Objects	{ PAGEREF _Toc318131439 \h }167</div>
      </p>
      <p>
        <div>15.4.1	The Array Constructor Called as a Function	{ PAGEREF _Toc318131440 \h }167</div>
      </p>
      <p>
        <div>15.4.2	The Array Constructor	{ PAGEREF _Toc318131441 \h }167</div>
      </p>
      <p>
        <div>15.4.3	Properties of the Array Constructor	{ PAGEREF _Toc318131442 \h }168</div>
      </p>
      <p>
        <div>15.4.4	Properties of the Array Prototype Object	{ PAGEREF _Toc318131443 \h }168</div>
      </p>
      <p>
        <div>15.4.5	Properties of Array Instances	{ PAGEREF _Toc318131444 \h }186</div>
      </p>
      <p>
        <div>15.5	String Objects	{ PAGEREF _Toc318131445 \h }188</div>
      </p>
      <p>
        <div>15.5.1	The String Constructor Called as a Function	{ PAGEREF _Toc318131446 \h }188</div>
      </p>
      <p>
        <div>15.5.2	The String Constructor	{ PAGEREF _Toc318131447 \h }188</div>
      </p>
      <p>
        <div>15.5.3	Properties of the String Constructor	{ PAGEREF _Toc318131448 \h }188</div>
      </p>
      <p>
        <div>15.5.4	Properties of the String Prototype Object	{ PAGEREF _Toc318131449 \h }189</div>
      </p>
      <p>
        <div>15.5.5	Properties of String Instances	{ PAGEREF _Toc318131450 \h }198</div>
      </p>
      <p>
        <div>15.6	Boolean Objects	{ PAGEREF _Toc318131451 \h }198</div>
      </p>
      <p>
        <div>15.6.1	The Boolean Constructor Called as a Function	{ PAGEREF _Toc318131452 \h }198</div>
      </p>
      <p>
        <div>15.6.2	The Boolean Constructor	{ PAGEREF _Toc318131453 \h }198</div>
      </p>
      <p>
        <div>15.6.3	Properties of the Boolean Constructor	{ PAGEREF _Toc318131454 \h }199</div>
      </p>
      <p>
        <div>15.6.4	Properties of the Boolean Prototype Object	{ PAGEREF _Toc318131455 \h }199</div>
      </p>
      <p>
        <div>15.6.5	Properties of Boolean Instances	{ PAGEREF _Toc318131456 \h }200</div>
      </p>
      <p>
        <div>15.7	Number Objects	{ PAGEREF _Toc318131457 \h }200</div>
      </p>
      <p>
        <div>15.7.1	The Number Constructor Called as a Function	{ PAGEREF _Toc318131458 \h }200</div>
      </p>
      <p>
        <div>15.7.2	The Number Constructor	{ PAGEREF _Toc318131459 \h }200</div>
      </p>
      <p>
        <div>15.7.3	Properties of the Number Constructor	{ PAGEREF _Toc318131460 \h }200</div>
      </p>
      <p>
        <div>15.7.4	Properties of the Number Prototype Object	{ PAGEREF _Toc318131461 \h }201</div>
      </p>
      <p>
        <div>15.7.5	Properties of Number Instances	{ PAGEREF _Toc318131462 \h }205</div>
      </p>
      <p>
        <div>15.8	The Math Object	{ PAGEREF _Toc318131463 \h }205</div>
      </p>
      <p>
        <div>15.8.1	Value Properties of the Math Object	{ PAGEREF _Toc318131464 \h }205</div>
      </p>
      <p>
        <div>15.8.2	Function Properties of the Math Object	{ PAGEREF _Toc318131465 \h }206</div>
      </p>
      <p>
        <div>15.9	Date Objects	{ PAGEREF _Toc318131466 \h }211</div>
      </p>
      <p>
        <div>15.9.1	Overview of Date Objects and Definitions of Abstract Operators	{ PAGEREF _Toc318131467 \h }211</div>
      </p>
      <p>
        <div>15.9.2	The Date Constructor Called as a Function	{ PAGEREF _Toc318131468 \h }216</div>
      </p>
      <p>
        <div>15.9.3	The Date Constructor	{ PAGEREF _Toc318131469 \h }216</div>
      </p>
      <p>
        <div>15.9.4	Properties of the Date Constructor	{ PAGEREF _Toc318131470 \h }217</div>
      </p>
      <p>
        <div>15.9.5	Properties of the Date Prototype Object	{ PAGEREF _Toc318131471 \h }218</div>
      </p>
      <p>
        <div>15.9.6	Properties of Date Instances	{ PAGEREF _Toc318131472 \h }225</div>
      </p>
      <p>
        <div>15.10	RegExp (Regular Expression) Objects	{ PAGEREF _Toc318131473 \h }225</div>
      </p>
      <p>
        <div>15.10.1	Patterns	{ PAGEREF _Toc318131474 \h }226</div>
      </p>
      <p>
        <div>15.10.2	Pattern Semantics	{ PAGEREF _Toc318131475 \h }228</div>
      </p>
      <p>
        <div>15.10.3	The RegExp Constructor Called as a Function	{ PAGEREF _Toc318131476 \h }239</div>
      </p>
      <p>
        <div>15.10.4	The RegExp Constructor	{ PAGEREF _Toc318131477 \h }239</div>
      </p>
      <p>
        <div>15.10.5	Properties of the RegExp Constructor	{ PAGEREF _Toc318131478 \h }240</div>
      </p>
      <p>
        <div>15.10.6	Properties of the RegExp Prototype Object	{ PAGEREF _Toc318131479 \h }241</div>
      </p>
      <p>
        <div>15.10.7	Properties of RegExp Instances	{ PAGEREF _Toc318131480 \h }242</div>
      </p>
      <p>
        <div>15.11	Error Objects	{ PAGEREF _Toc318131481 \h }243</div>
      </p>
      <p>
        <div>15.11.1	The Error Constructor Called as a Function	{ PAGEREF _Toc318131482 \h }243</div>
      </p>
      <p>
        <div>15.11.2	The Error Constructor	{ PAGEREF _Toc318131483 \h }243</div>
      </p>
      <p>
        <div>15.11.3	Properties of the Error Constructor	{ PAGEREF _Toc318131484 \h }244</div>
      </p>
      <p>
        <div>15.11.4	Properties of the Error Prototype Object	{ PAGEREF _Toc318131485 \h }244</div>
      </p>
      <p>
        <div>15.11.5	Properties of Error Instances	{ PAGEREF _Toc318131486 \h }244</div>
      </p>
      <p>
        <div>15.11.6	Native Error Types Used in This Standard	{ PAGEREF _Toc318131487 \h }244</div>
      </p>
      <p>
        <div>15.11.7	<i>NativeError</i> Object Structure	{ PAGEREF _Toc318131488 \h }245</div>
      </p>
      <p>
        <div>15.12	The JSON Object	{ PAGEREF _Toc318131489 \h }247</div>
      </p>
      <p>
        <div>15.12.1	The JSON Grammar	{ PAGEREF _Toc318131490 \h }247</div>
      </p>
      <p>
        <div>15.12.2	parse ( text [ , reviver ] )	{ PAGEREF _Toc318131491 \h }249</div>
      </p>
      <p>
        <div>15.12.3	stringify ( value [ , replacer [ , space ] ] )	{ PAGEREF _Toc318131492 \h }250</div>
      </p>
      <p>
        <div>16	Errors	{ PAGEREF _Toc318131493 \h }254</div>
      </p>
      <p>
        <div>Annex A (informative)  Grammar Summary	{ PAGEREF _Toc318131494 \h }256</div>
      </p>
      <p>
        <div>A.1	Lexical Grammar	{ PAGEREF _Toc318131495 \h }256</div>
      </p>
      <p>
        <div>A.2	Number Conversions	{ PAGEREF _Toc318131496 \h }262</div>
      </p>
      <p>
        <div>A.3	Expressions	{ PAGEREF _Toc318131497 \h }263</div>
      </p>
      <p>
        <div>A.4	Statements	{ PAGEREF _Toc318131498 \h }267</div>
      </p>
      <p>
        <div>A.5	Functions and Programs	{ PAGEREF _Toc318131499 \h }269</div>
      </p>
      <p>
        <div>A.6	Universal Resource Identifier Character Classes	{ PAGEREF _Toc318131500 \h }270</div>
      </p>
      <p>
        <div>A.7	Regular Expressions	{ PAGEREF _Toc318131501 \h }270</div>
      </p>
      <p>
        <div>A.8	JSON	{ PAGEREF _Toc318131502 \h }272</div>
      </p>
      <p>
        <div>A.8.1	JSON Lexical Grammar	{ PAGEREF _Toc318131503 \h }272</div>
      </p>
      <p>
        <div>A.8.2	JSON Syntactic Grammar	{ PAGEREF _Toc318131504 \h }273</div>
      </p>
      <p>
        <div>Annex B  (normative)  Additional ECMAScript Features for Web Browsers	{ PAGEREF _Toc318131505 \h }276</div>
      </p>
      <p>
        <div>B.1	Additional Syntax	{ PAGEREF _Toc318131506 \h }276</div>
      </p>
      <p>
        <div>B.1.1	Numeric Literals	{ PAGEREF _Toc318131508 \h }276</div>
      </p>
      <p>
        <div>B.1.2	String Literals	{ PAGEREF _Toc318131509 \h }276</div>
      </p>
      <p>
        <div>B.2	Additional Properties	{ PAGEREF _Toc318131510 \h }277</div>
      </p>
      <p>
        <div>B.2.1	escape (string)	{ PAGEREF _Toc318131511 \h }277</div>
      </p>
      <p>
        <div>B.2.2	unescape (string)	{ PAGEREF _Toc318131512 \h }278</div>
      </p>
      <p>
        <div>B.2.3	String.prototype.substr (start, length)	{ PAGEREF _Toc318131513 \h }279</div>
      </p>
      <p>
        <div>B.2.4	Date.prototype.getYear ( )	{ PAGEREF _Toc318131514 \h }279</div>
      </p>
      <p>
        <div>B.2.5	Date.prototype.setYear (year)	{ PAGEREF _Toc318131515 \h }279</div>
      </p>
      <p>
        <div>B.2.6	Date.prototype.toGMTString ( )	{ PAGEREF _Toc318131516 \h }279</div>
      </p>
      <p>
        <div>B.3	Other Additional Features	{ PAGEREF _Toc318131517 \h }280</div>
      </p>
      <p>
        <div>B.3.1	The __proto__ pseudo property.	{ PAGEREF _Toc318131518 \h }280</div>
      </p>
      <p>
        <div>Annex C (informative)  The Strict Mode of ECMAScript	{ PAGEREF _Toc318131519 \h }282</div>
      </p>
      <p>
        <div>Annex D (informative)  Corrections and Clarifications in the 5<sup>th</sup> Edition with Possible 3<sup>rd</sup> Edition Compatibility Impact	{ PAGEREF _Toc318131520 \h }284</div>
      </p>
      <p>
        <div>Annex E (informative)  Additions and Changes in the 5<sup>th</sup> Edition that Introduce Incompatibilities with the 3<sup>rd</sup> Edition	{ PAGEREF _Toc318131521 \h }286</div>
      </p>
      <p>
        <div>Annex F (informative)  Technically Significant Corrections and Clarifications in the 5.1 Edition	{ PAGEREF _Toc318131522 \h }290</div>
      </p>
      <p>
      </p>
      <p>
        <hr>
      </p>
      <p>
      </p>
      <p>Introduction</p>
      <p>This Ecma Standard is based on several originating technologies, the most well known being JavaScript (Netscape) and JScript (Microsoft). The language was invented by Brendan Eich at Netscape and first appeared in that company’s Navigator 2.0 browser. It has appeared in all subsequent browsers from Netscape and in all browsers from Microsoft starting with Internet Explorer 3.0.</p>
      <p>The development of this Standard started in November 1996. The first edition of this Ecma Standard was adopted by the Ecma General Assembly of June 1997.</p>
      <p>That Ecma Standard was submitted to ISO/IEC JTC 1 for adoption under the fast-track procedure, and approved as international standard ISO/IEC 16262, in April 1998. The Ecma General Assembly of June 1998 approved the second edition of ECMA-262 to keep it fully aligned with ISO/IEC 16262. Changes between the first and the second edition are editorial in nature.</p>
      <p>The third edition of the Standard introduced powerful regular expressions, better string handling, new control statements, try/catch exception handling, tighter definition of errors, formatting for numeric output and minor changes in anticipation of forthcoming internationalisation facilities and future language growth. The third edition of the ECMAScript standard was adopted by the Ecma General Assembly of December 1999 and published as ISO/IEC 16262:2002 in June 2002.</p>
      <p>Since publication of the third edition, ECMAScript has achieved massive adoption in conjunction with the World Wide Web where it has become the programming language that is supported by essentially all web browsers. Significant work was done to develop a fourth edition of ECMAScript. Although that work was not completed and not published as the fourth edition of ECMAScript, it informs continuing evolution of the language. The fifth edition of ECMAScript (published as ECMA-262 5<sup>th</sup> edition) codifies de facto interpretations of the language specification that have become common among browser implementations and adds support for new features that have emerged since the publication of the third edition. Such features include accessor properties, reflective creation and inspection of objects, program control of property attributes, additional array manipulation functions, support for the JSON object encoding format, and a strict mode that provides enhanced error checking and program security.</p>
      <p>The edition 5.1 of the ECMAScript Standard has been fully aligned with the third edition of the international standard ISO/IEC 16262:2011.</p>
      <p>This present sixth edition of the Standard………</p>
      <p>ECMAScript is a vibrant language and the evolution of the language is not complete. Significant technical enhancement will continue with future editions of this specification.</p>
      <p>
      </p>
      <p>
      </p>
      <p>
      </p>
      <p>This Ecma Standard has been adopted by the General Assembly of &lt;month&gt; &lt;year&gt;.</p>
      <p>
      </p>
      <p>
      </p>
      <p>
      </p>
      <p>
        <i>"DISCLAIMER</i>
      </p>
      <p>
        <i>This draft document may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published, and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this section are included on all such copies and derivative works. However, this document itself may not be modified in any way, including by removing the copyright notice or references to Ecma International, except as needed for the purpose of developing any document or deliverable produced by Ecma International.</i>
      </p>
      <p>
        <i>This disclaimer is valid only prior to final version of this document. After approval all rights on the standard are reserved by Ecma International.</i>
      </p>
      <p>
        <i>The limited permissions are granted through the standardization phase and will not be revoked by Ecma International or its successors or assigns during this time.</i>
      </p>
      <p>
        <i>This document and the information contained herein is provided on an "AS IS" basis and ECMA INTERNATIONAL DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE."</i>
      </p>
      <p>
      </p>
      <p>
      </p>
      <p>
      </p>
      <p>
      </p>
      <p>ECMAScript Language Specification</p>
      <h1>Scope</h1>
      <p>This Standard defines the ECMAScript scripting language.</p>
      <h1>Conformance</h1>
      <p>A conforming implementation of ECMAScript must provide and support all the types, values, objects, properties, functions, and program syntax and semantics described in this specification.</p>
      <p>A conforming implementation of this Standard shall interpret characters in conformance with the Unicode Standard, Version 3.0 or later and ISO/IEC 10646-1 with either UCS-2 or UTF-16 as the adopted encoding form, implementation level 3. If the adopted ISO/IEC 10646-1 subset is not otherwise specified, it is presumed to be the BMP subset, collection 300. If the adopted encoding form is not otherwise specified, it presumed to be the UTF-16 encoding form.</p>
      <p>A conforming implementation of ECMAScript is permitted to provide additional types, values, objects, properties, and functions beyond those described in this specification. In particular, a conforming implementation of ECMAScript is permitted to provide properties not described in this specification, and values for those properties, for objects that are described in this specification.</p>
      <p>A conforming implementation of ECMAScript is permitted to support program and regular expression syntax not described in this specification. In particular, a conforming implementation of ECMAScript is permitted to support program syntax that makes use of the “future reserved words” listed in 7.6.1.2 of this specification.</p>
      <h1>Normative references</h1>
      <p>The following referenced documents are indispensable for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</p>
      <p>ISO/IEC 9899:1996<i>,</i><i> Programming Languages – C, including amendment 1 and technical corrigenda 1 and 2</i></p>
      <p>ISO/IEC 10646-1:1993<i>, Information Technology – Universal Multiple-Octet Coded Character Set (UCS) plus its amendments and corrigenda</i></p>
      <h1>4<span>	Overview</span></h1>
      <p>This section contains a non-normative overview of the ECMAScript language.</p>
      <p>ECMAScript is an object-oriented programming language for performing computations and manipulating computational objects within a host environment. ECMAScript as defined here is not intended to be computationally self-sufficient; indeed, there are no provisions in this specification for input of external data or output of computed results. Instead, it is expected that the computational environment of an ECMAScript program will provide not only the objects and other facilities described in this specification but also certain environment-specific <i>host </i>objects, whose description and behaviour are beyond the scope of this specification except to indicate that they may provide certain properties that can be accessed and certain functions that can be called from an ECMAScript program.</p>
      <p>A <span style="font-weight: bold; font-style: italic">scripting language</span> is a programming language that is used to manipulate, customise, and automate the facilities of an existing system. In such systems, useful functionality is already available through a user interface, and the scripting language is a mechanism for exposing that functionality to program control. In this way, the existing system is said to provide a host environment of objects and facilities, which completes the capabilities of the scripting language. A scripting language is intended for use by both professional and non-professional programmers.</p>
      <p>ECMAScript was originally designed to be a <span style="font-weight: bold; font-style: italic">Web scripting language</span>, providing a mechanism to enliven Web pages in browsers and to perform server computation as part of a Web-based client-server architecture. ECMAScript can provide core scripting capabilities for a variety of host environments, and therefore the core scripting language is specified in this document apart from any particular host environment.</p>
      <p>Some of the facilities of ECMAScript are similar to those used in other programming languages; in particular Java™, Self, and Scheme as described in:</p>
      <p>Gosling, James, Bill Joy and Guy Steele. The Java<sup>™</sup> Language Specification. Addison Wesley Publishing Co., 1996.</p>
      <p>Ungar, David, and Smith, Randall B. Self: The Power of Simplicity. OOPSLA '87 Conference Proceedings, pp. 227–241, Orlando, FL, October 1987.</p>
      <p>IEEE Standard for the Scheme Programming Language. IEEE Std 1178-1990.</p>
      <h2>4.1<span>	Web Scripting</span></h2>
      <p>A web browser provides an ECMAScript host environment for client-side computation including, for instance, objects that represent windows, menus, pop-ups, dialog boxes, text areas, anchors, frames, history, cookies, and input/output. Further, the host environment provides a means to attach scripting code to events such as change of focus, page and image loading, unloading, error and abort, selection, form submission, and mouse actions. Scripting code appears within the HTML and the displayed page is a combination of user interface elements and fixed and computed text and images. The scripting code is reactive to user interaction and there is no need for a main program.</p>
      <p>A web server provides a different host environment for server-side computation including objects representing requests, clients, and files; and mechanisms to lock and share data. By using browser-side and server-side scripting together, it is possible to distribute computation between the client and server while providing a customised user interface for a Web-based application.</p>
      <p>Each Web browser and server that supports ECMAScript supplies its own host environment, completing the ECMAScript execution environment.</p>
      <h2>4.2<span>	Language Overview</span></h2>
      <p>The following is an informal overview of ECMAScript—not all parts of the language are described. This overview is not part of the standard proper.</p>
      <p>ECMAScript is object-based: basic language and host facilities are provided by objects, and an ECMAScript program is a cluster of communicating objects. An ECMAScript <span style="font-weight: bold; font-style: italic">object</span> is a collection of <span style="font-weight: bold; font-style: italic">properties</span> each with zero or more <span style="font-weight: bold; font-style: italic">attributes</span> that determine how each property can be used—for example, when the Writable attribute for a property is set to <b>false</b>, any attempt by executed ECMAScript code to change the value of the property fails. Properties are containers that hold other objects, <span style="font-weight: bold; font-style: italic">primitive values</span>, or <span style="font-weight: bold; font-style: italic">functions</span>. A primitive value is a member of one of the following built-in types: <b>Undefined</b>, <b>Null</b>, <b>Boolean</b>, <b>Number</b>, and <b>String</b>; an object is a member of the remaining built-in type <b>Object</b>; and a function is a callable object. A function that is associated with an object via a property is a <span style="font-weight: bold; font-style: italic">method</span>.</p>
      <p>ECMAScript defines a collection of <span style="font-weight: bold; font-style: italic">built-in objects</span> that round out the definition of ECMAScript entities. These built-in objects include the global object, the <b>Object</b> object, the <b>Function</b> object, the <b>Array</b> object, the <b>String</b> object, the <b>Boolean</b> object, the <b>Number</b> object, the <b>Math</b> object, the <b>Date</b> object, the <b>RegExp</b> object, the <b>JSON</b> object, and the Error objects <b>Error, EvalError</b>, <b>RangeError, ReferenceError, SyntaxError, TypeError </b>and <b>URIError</b>.</p>
      <p>ECMAScript also defines a set of built-in <span style="font-weight: bold; font-style: italic">operators</span>. ECMAScript operators include various unary operations, multiplicative operators, additive operators, bitwise shift operators, relational operators, equality operators, binary bitwise operators, binary logical operators, assignment operators, and the comma operator.</p>
      <p>ECMAScript syntax intentionally resembles Java syntax. ECMAScript syntax is relaxed to enable it to serve as an easy-to-use scripting language. For example, a variable is not required to have its type declared nor are types associated with properties, and defined functions are not required to have their declarations appear textually before calls to them.</p>
      <h2>4.2.1<span>	Objects</span></h2>
      <p>ECMAScript does not use classes such as those in C++, Smalltalk, or Java. Instead objects may be created in various ways including via a literal notation or via <span style="font-weight: bold; font-style: italic">constructors</span> which create objects and then execute code that initialises all or part of them by assigning initial values to their properties. Each constructor is a function that has a property named “<b>prototype</b>” that is used to implement <span style="font-weight: bold; font-style: italic">prototype-based inheritance</span> and <span style="font-weight: bold; font-style: italic">shared properties</span>. Objects are created by using constructors in <b>new</b> expressions; for example, <b>new Date(2009,11)</b> creates a new Date object. Invoking a constructor without using <b>new</b> has consequences that depend on the constructor. For example, <b>Date()</b> produces a string representation of the current date and time rather than an object.</p>
      <p>Every object created by a constructor has an implicit reference (called the object’s<i> prototype</i>) to the value of its constructor’s “<b>prototype</b>” property. Furthermore, a prototype may have a non-null implicit reference to its prototype, and so on; this is called the <i>prototype chain</i>. When a reference is made to a property in an object, that reference is to the property of that name in the first object in the prototype chain that contains a property of that name. In other words, first the object mentioned directly is examined for such a property; if that object contains the named property, that is the property to which the reference refers; if that object does not contain the named property, the prototype for that object is examined next; and so on.</p>
      <p>
        <div>
          <div>
            <div>
              <div>
                <p>
                  <b> cf</b>
                  <span style="font-weight: bold; vertical-align: sub">5</span>
                </p>
                <p> q1</p>
                <p> q2</p>
              </div>
              <div>
                <div>
                  <p>
                    <b> cf</b>
                    <span style="font-weight: bold; vertical-align: sub">4</span>
                  </p>
                  <p> q1</p>
                  <p> q2</p>
                </div>
                <div>
                  <div>
                    <p>
                      <b> cf</b>
                      <span style="font-weight: bold; vertical-align: sub">3</span>
                    </p>
                    <p> q1</p>
                    <p> q2</p>
                  </div>
                  <div>
                    <div>
                      <div>
                        <div>
                          <p>
                            <b> CF</b>
                            <span style="font-weight: bold; vertical-align: sub">p</span>
                          </p>
                          <p> CFP1</p>
                        </div>
                        <div>
                          <p> <b>CF</b></p>
                          <p> prototype</p>
                          <p> P1</p>
                          <p> P2</p>
                        </div>
                      </div>
                      <div>
                        <p>
                          <b> cf</b>
                          <span style="font-weight: bold; vertical-align: sub">1</span>
                        </p>
                        <p> q1</p>
                        <p> q2</p>
                      </div>
                    </div>
                    <div>
                      <p>
                        <b> cf</b>
                        <span style="font-weight: bold; vertical-align: sub">2</span>
                      </p>
                      <p> q1</p>
                      <p> q2</p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <p>implicit prototype link</p>
          </div>
          <p>explicit prototype property</p>
        </div>
      </p>
      <p>Figure 1 — Object/Prototype Relationships</p>
      <p>In a class-based object-oriented language, in general, state is carried by instances, methods are carried by classes, and inheritance is only of structure and behaviour. In ECMAScript, the state and methods are carried by objects, and structure, behaviour, and state are all inherited.</p>
      <p>All objects that do not directly contain a particular property that their prototype contains share that property and its value. Figure 1 illustrates this:</p>
      <p><b>CF</b> is a constructor (and also an object). Five objects have been created by using <b>new</b> expressions: <b>cf</b><span style="font-weight: bold; vertical-align: sub">1</span>, <b>cf</b><span style="font-weight: bold; vertical-align: sub">2</span>, <b>cf</b><span style="font-weight: bold; vertical-align: sub">3</span>, <b>cf</b><span style="font-weight: bold; vertical-align: sub">4</span>, and <b>cf</b><span style="font-weight: bold; vertical-align: sub">5</span>. Each of these objects contains properties named q1 and q2. The dashed lines represent the implicit prototype relationship; so, for example, <b>cf</b><span style="font-weight: bold; vertical-align: sub">3</span>’s prototype is <b>CF</b><span style="font-weight: bold; vertical-align: sub">p</span>. The constructor, <b>CF</b>, has two properties itself, named P1 and P2, which are not visible to <b>CF</b><span style="font-weight: bold; vertical-align: sub">p</span>, <b>cf</b><span style="font-weight: bold; vertical-align: sub">1</span>, <b>cf</b><span style="font-weight: bold; vertical-align: sub">2</span>, <b>cf</b><span style="font-weight: bold; vertical-align: sub">3</span>, <b>cf</b><span style="font-weight: bold; vertical-align: sub">4</span>, or <b>cf</b><span style="font-weight: bold; vertical-align: sub">5</span>. The property named CFP1 in <b>CF</b><span style="font-weight: bold; vertical-align: sub">p</span> is shared by <b>cf</b><span style="font-weight: bold; vertical-align: sub">1</span>, <b>cf</b><span style="font-weight: bold; vertical-align: sub">2</span>, <b>cf</b><span style="font-weight: bold; vertical-align: sub">3</span>, <b>cf</b><span style="font-weight: bold; vertical-align: sub">4</span>, and <b>cf</b><span style="font-weight: bold; vertical-align: sub">5</span> (but not by <b>CF</b>), as are any properties found in <b>CF</b><span style="font-weight: bold; vertical-align: sub">p</span>’s implicit prototype chain that are not named q1, q2, or CFP1. Notice that there is no implicit prototype link between <b>CF</b> and <b>CF</b><span style="font-weight: bold; vertical-align: sub">p</span>.</p>
      <p>Unlike class-based object languages, properties can be added to objects dynamically by assigning values to them. That is, constructors are not required to name or assign values to all or any of the constructed object’s properties. In the above diagram, one could add a new shared property for <b>cf</b><span style="font-weight: bold; vertical-align: sub">1</span>, <b>cf</b><span style="font-weight: bold; vertical-align: sub">2</span>, <b>cf</b><span style="font-weight: bold; vertical-align: sub">3</span>, <b>cf</b><span style="font-weight: bold; vertical-align: sub">4</span>, and <b>cf</b><span style="font-weight: bold; vertical-align: sub">5 </span>by assigning a new value to the property in <b>CF</b><span style="font-weight: bold; vertical-align: sub">p</span>.</p>
      <h2>4.2.2<span>	The Strict Variant of ECMAScript</span></h2>
      <p>The ECMAScript Language recognises the possibility that some users of the language may wish to restrict their usage of some features available in the language. They might do so in the interests of security, to avoid what they consider to be error-prone features, to get enhanced error checking, or for other reasons of their choosing. In support of this possibility, ECMAScript defines a strict variant of the language. The strict variant of the language excludes some specific syntactic and semantic features of the regular ECMAScript language and modifies the detailed semantics of some features. The strict variant also specifies additional error conditions that must be reported by throwing error exceptions in situations that are not specified as errors by the non-strict form of the language.</p>
      <p>The strict variant of ECMAScript is commonly referred to as the <i>strict mode</i> of the language. Strict mode selection and use of the strict mode syntax and semantics of ECMAScript is explicitly made at the level of individual ECMAScript code units. Because strict mode is selected at the level of a syntactic code unit, strict mode only imposes restrictions that have local effect within such a code unit. Strict mode does not restrict or modify any aspect of the ECMAScript semantics that must operate consistently across multiple code units. A complete ECMAScript program may be composed for both strict mode and non-strict mode ECMAScript code units. In this case, strict mode only applies when actually executing code that is defined within a strict mode code unit. </p>
      <p>In order to conform to this specification, an ECMAScript implementation must implement both the full unrestricted ECMAScript language and the strict mode variant of the ECMAScript language as defined by this specification. In addition, an implementation must support the combination of unrestricted and strict mode code units into a single composite program.</p>
      <h2>4.3<span>	Terms and definitions</span></h2>
      <p>For the purposes of this document, the following terms and definitions apply.</p>
      <p>4.3.1</p>
      <p>type</p>
      <p>set of data values as defined in Clause 8 of this specification</p>
      <p>4.3.2</p>
      <p>primitive value</p>
      <p>member of one of the types Undefined, Null, Boolean, Number, or String as defined in Clause 8</p>
      <p>NOTE<span>	A primitive value is a datum that is represented directly at the lowest level of the language implementation.</span></p>
      <p>4.3.3</p>
      <p>object</p>
      <p>member of the type Object</p>
      <p>NOTE<span>	An object is a collection of properties</span> and has a single prototype object. The prototype may be the null value.</p>
      <p>4.3.4</p>
      <p>constructor</p>
      <p>function object that creates and initialises objects</p>
      <p>NOTE<span>	The value of a constructor’s “</span>prototype” property is a prototype object that is used to implement inheritance and shared properties.</p>
      <p>4.3.5</p>
      <p>prototype</p>
      <p>object that provides shared properties for other objects</p>
      <p>NOTE<span>	When a constructor creates an object, that object implicitly references the constructor’s “</span><b>prototype</b>” property for the purpose of resolving property references. The constructor’s “<b>prototype</b>” property can be referenced by the program expression <i>constructor</i><b>.prototype</b>, and properties added to an object’s prototype are shared, through inheritance, by all objects sharing the prototype. Alternatively, a new object may be created with an explicitly specified prototype by using the <b>Object.create</b> built-in function.</p>
      <p>4.3.6</p>
      <p>native object</p>
      <p>object in an ECMAScript implementation whose semantics are fully defined by this specification rather than by  the host environment</p>
      <p>NOTE<span>	Standard native objects are defined in this specification. Some native objects are built-in; others may be constructed during the course of execution of an ECMAScript program.</span></p>
      <p>4.3.7</p>
      <p>built-in object</p>
      <p>object supplied by an ECMAScript implementation, independent of the host environment, that is present at the start of the execution of an ECMAScript program</p>
      <p>NOTE<span>	Standard built-in objects are defined in this specification, and an ECMAScript implementation may specify and define others. Every built-in object is a native object.</span> A <i>built-in constructor</i><span style="font-weight: bold; font-style: italic"> </span>is a built-in object that is also a constructor.</p>
      <p>4.3.8</p>
      <p>host object</p>
      <p>object supplied by the host environment to complete the execution environment of ECMAScript</p>
      <p>NOTE<span>	Any object that is not native is a host object.</span></p>
      <p>4.3.9</p>
      <p>undefined value</p>
      <p>primitive value used when a variable has not been assigned a value</p>
      <p>4.3.10</p>
      <p>Undefined type</p>
      <p>type whose sole value is the undefined value</p>
      <p>4.3.11</p>
      <p>null value</p>
      <p>primitive value that represents the intentional absence of any object value</p>
      <p>4.3.12</p>
      <p>Null type</p>
      <p>type whose sole value is the null value</p>
      <p>4.3.13</p>
      <p>Boolean value</p>
      <p>member of the Boolean type</p>
      <p>NOTE<span>	There are only two Boolean values, </span><b>true</b> and <b>false</b>.</p>
      <p>4.3.14</p>
      <p>Boolean type</p>
      <p>type consisting of the primitive values <b>true</b> and <b>false</b></p>
      <p>4.3.15</p>
      <p>Boolean object</p>
      <p>member of the Object type that is an instance of the standard built-in <b>Boolean</b> constructor</p>
      <p>NOTE<span>	A Boolean object is created by using the </span><b>Boolean</b> constructor in a <b>new</b> expression, supplying a Boolean value as an argument. The resulting object has an internal property whose value is the Boolean value. A Boolean object can be coerced to a Boolean value.</p>
      <p>4.3.16</p>
      <p>String value</p>
      <p>primitive value that is a finite ordered sequence of zero or more 16-bit unsigned integer</p>
      <p>NOTE<span>	A String value is a member of the String type. Each integer value in the sequence usually represents a single 16-bit unit of UTF-16 text. However, ECMAScript does not place any restrictions or requirements on the values except that they must be 16-bit unsigned integers.</span></p>
      <p>4.3.17</p>
      <p>String type</p>
      <p>set of all possible String values</p>
      <p>4.3.18</p>
      <p>String object</p>
      <p>member of the Object type that is an instance of the standard built-in <b>String</b> constructor</p>
      <p>NOTE<span>	A String object is created by using the </span><b>String</b> constructor in a <b>new</b> expression, supplying a String value as an argument. The resulting object has an internal property whose value is the String value. A String object can be coerced to a String value by calling the <b>String</b> constructor as a function (15.5.1).</p>
      <p>4.3.19</p>
      <p>Number value</p>
      <p>primitive value corresponding to a double-precision 64-bit binary format IEEE 754 value</p>
      <p>NOTE<span>	A Number value is a member of the Number</span><b> </b>type and is a direct representation of a number.</p>
      <p>4.3.20</p>
      <p>Number type</p>
      <p>set of all possible Number values including the special “Not-a-Number” (NaN) values, positive infinity, and negative infinity</p>
      <p>4.3.21</p>
      <p>Number object</p>
      <p>member of the Object type that is an instance of the standard built-in <b>Number</b> constructor</p>
      <p>NOTE<span>	A Number object is created by using the </span><b>Number</b> constructor in a <b>new</b> expression, supplying a Number value as an argument. The resulting object has an internal property whose value is the Number value. A Number object can be coerced to a Number value by calling the <b>Number</b> constructor as a function (15.7.1).</p>
      <p>4.3.22</p>
      <p>Infinity</p>
      <p>number value that is the positive infinite Number value</p>
      <p>4.3.23</p>
      <p>NaN</p>
      <p>number value that is a IEEE 754 “Not-a-Number” value</p>
      <p>4.3.24</p>
      <p>function</p>
      <p>member of the Object type that is an instance of the standard built-in <b>Function</b> constructor and that may be invoked as a subroutine</p>
      <p>NOTE<span>	In addition to its named properties, a function contains executable code and state that determine how it behaves when invoked. A function’s code may or may not be written in ECMAScript.</span></p>
      <p>4.3.25</p>
      <p>built-in function</p>
      <p>built-in object that is a function</p>
      <p>NOTE<span>	Examples of built-in functions include </span><b>parseInt</b> and <b>Math.exp</b>. An implementation may provide implementation-dependent built-in functions that are not described in this specification. </p>
      <p>4.3.26</p>
      <p>property</p>
      <p>association between a name and a value that is a part of an object</p>
      <p>NOTE<span>	Depending upon the form of the property the value may be represented either directly as a data value (a primitive value, an object, or a function object) or indirectly by a pair of accessor functions.</span></p>
      <p>4.3.27</p>
      <p>method</p>
      <p>function that is the value of a property</p>
      <p>NOTE<span>	When a function is called as a method of an object, the object is passed to the function as its </span><b>this</b> value.</p>
      <p>4.3.28</p>
      <p>built-in method</p>
      <p>method that is a built-in function</p>
      <p>NOTE<span>	Standard built-in methods are defined in this specification, and an ECMAScript implementation may specify and provide other additional built-in methods. </span></p>
      <p>4.3.29</p>
      <p>attribute</p>
      <p>internal value that defines some characteristic of a property</p>
      <p>4.3.30</p>
      <p>own property</p>
      <p>property that is directly contained by its object</p>
      <p>4.3.31</p>
      <p>inherited property</p>
      <p>property of an object that is not an own property but is a property (either own or inherited) of the object’s prototype</p>
      <h1>5<span>	Notational Conventions</span></h1>
      <h2>5.1<span>	Syntactic and Lexical Grammar</span>s</h2>
      <h2>5.1.1<span>	Context-Free Grammar</span>s</h2>
      <p>A <i>context-free grammar</i> consists of a number of <i>productions</i>. Each production has an abstract symbol called a <i>nonterminal</i> as its <i>left-hand side</i>, and a sequence of zero or more nonterminal and <i>terminal</i> symbols as its <i>right-hand side</i>. For each grammar, the terminal symbols are drawn from a specified alphabet.</p>
      <p>Starting from a sentence consisting of a single distinguished nonterminal, called the <i>goal symbol</i>, a given context-free grammar specifies a <i>language</i>, namely, the (perhaps infinite) set of possible sequences of terminal symbols that can result from repeatedly replacing any nonterminal in the sequence with a right-hand side of a production for which the nonterminal is the left-hand side.</p>
      <h2>5.1.2<span>	The Lexical and RegExp Gramma</span>rs</h2>
      <p>A <i>lexical grammar</i> for ECMAScript is given in clause 7. This grammar has as its terminal symbols characters (Unicode code units) that conform to the rules for SourceCharacter defined in Clause 6. It defines a set of productions, starting from the goal symbol InputElementDiv or InputElementRegExp, that describe how sequences of such characters are translated into a sequence of input elements.</p>
      <p>Input elements other than white space and comments form the terminal symbols for the syntactic grammar for ECMAScript and are called ECMAScript <i>tokens</i>. These tokens are the reserved words, identifiers, literals, and punctuators of the ECMAScript language. Moreover, line terminators, although not considered to be tokens, also become part of the stream of input elements and guide the process of automatic semicolon insertion (7.9). Simple white space and single-line comments are discarded and do not appear in the stream of input elements for the syntactic grammar. A <i>MultiLineComment</i> (that is, a comment of the form “/*…*/” regardless of whether it spans more than one line) is likewise simply discarded if it contains no line terminator; but if a <i>MultiLineComment</i> contains one or more line terminators, then it is replaced by a single line terminator, which becomes part of the stream of input elements for the syntactic grammar.</p>
      <p>A <i>RegExp grammar</i> for ECMAScript is given in 15.10. This grammar also has as its terminal symbols the characters as defined by SourceCharacter. It defines a set of productions, starting from the goal symbol Pattern, that describe how sequences of characters are translated into regular expression patterns.</p>
      <p>Productions of the lexical and RegExp grammars are distinguished by having two colons “<b>::</b>” as separating punctuation. The lexical and RegExp grammars share some productions.</p>
      <h2>5.1.3<span>	The Numeric String Gramma</span>r</h2>
      <p>Another grammar is used for translating Strings into numeric values. This grammar is similar to the part of the lexical grammar having to do with numeric literals and has as its terminal symbols SourceCharacter. This grammar appears in 9.3.1.</p>
      <p>Productions of the numeric string grammar are distinguished by having three colons “<b>:::</b>” as punctuation.</p>
      <h2>5.1.4<span>	The Syntactic Gramma</span>r</h2>
      <p>The <i>syntactic grammar</i> for ECMAScript is given in clauses 11, 12, 13 and 14. This grammar has ECMAScript tokens defined by the lexical grammar as its terminal symbols (5.1.2). It defines a set of productions, starting from the goal symbol Program, that describe how sequences of tokens can form syntactically correct ECMAScript programs.</p>
      <p>When a stream of characters is to be parsed as an ECMAScript program, it is first converted to a stream of input elements by repeated application of the lexical grammar; this stream of input elements is then parsed by a single application of the syntactic grammar. The program is syntactically in error if the tokens in the stream of input elements cannot be parsed as a single instance of the goal nonterminal Program, with no tokens left over.</p>
      <p>Productions of the syntactic grammar are distinguished by having just one colon “<b>:</b>” as punctuation.</p>
      <p>The syntactic grammar as presented in clauses 11, 12, 13 and 14 is actually not a complete account of which token sequences are accepted as correct ECMAScript programs. Certain additional token sequences are also accepted, namely, those that would be described by the grammar if only semicolons were added to the sequence in certain places (such as before line terminator characters). Furthermore, certain token sequences that are described by the grammar are not considered acceptable if a terminator character appears in certain “awkward” places.</p>
      <p>In certain cases in order to avoid ambiguities the syntactic grammar uses productions that permit token sequences that are not valid ECMAScript programs.  In such cases a more restrictive <i>supplemental grammar</i> is provided that further restricts the acceptable token sequences. In such situations, when explicitly specific, the input elements corresponding to such a production is parsed again using a goal symbol of a supplemental grammar.  The program is syntactically in error if the tokens in the stream of input elements cannot be parsed as a single instance of the supplemental goal symbol, with no tokens left over.</p>
      <h2>5.1.5<span>	The JSON Grammar</span></h2>
      <p>The JSON grammar is used to translate a String describing a set of ECMAScript objects into actual objects. The JSON grammar is given in 15.12.1.</p>
      <p>The JSON grammar consists of the JSON lexical grammar and the JSON syntactic grammar. The JSON lexical grammar is used to translate character sequences into tokens and is similar to parts of the ECMAScript lexical grammar. The JSON syntactic grammar describes how sequences of tokens from the JSON lexical grammar can form syntactically correct JSON object descriptions.</p>
      <p>Productions of the JSON lexical grammar are distinguished by having two colons “<b>::</b>” as separating punctuation. The JSON lexical grammar uses some productions from the ECMAScript lexical grammar. The JSON syntactic grammar is similar to parts of the ECMAScript syntactic grammar. Productions of the JSON syntactic grammar are distinguished by using one colon “<b>:</b>” as separating punctuation.</p>
      <h2>5.1.6<span>	Grammar Notatio</span>n</h2>
      <p>Terminal symbols of the lexical, RegExp, and numeric string grammars, and some of the terminal symbols of the other grammars, are shown in <b>fixed width</b> font, both in the productions of the grammars and throughout this specification whenever the text directly refers to such a terminal symbol. These are to appear in a program exactly as written. All terminal symbol characters specified in this way are to be understood as the appropriate Unicode character from the ASCII range, as opposed to any similar-looking characters from other Unicode ranges.</p>
      <p>Nonterminal symbols are shown in <i>italic</i> type. The definition of a nonterminal is introduced by the name of the nonterminal being defined followed by one or more colons. (The number of colons indicates to which grammar the production belongs.) One or more alternative right-hand sides for the nonterminal then follow on succeeding lines. For example, the syntactic definition:</p>
      <p>WhileStatement <b>:</b></p>
      <p><b>while</b><b> </b><b>(</b><b> </b>Expression<b> </b><b>)</b><b> </b>Statement</p>
      <p>states that the nonterminal WhileStatement represents the token <b>while</b>, followed by a left parenthesis token, followed by an Expression, followed by a right parenthesis token, followed by a Statement. The occurrences of Expression and Statement are themselves nonterminals. As another example, the syntactic definition:</p>
      <p>ArgumentList<b> </b><b>:</b></p>
      <p>AssignmentExpression<span><br>ArgumentList</span><b> , </b>AssignmentExpression</p>
      <p>states that an ArgumentList may represent either a single AssignmentExpression or an ArgumentList, followed by a comma, followed by an AssignmentExpression. This definition of ArgumentList is recursive, that is, it is defined in terms of itself. The result is that an ArgumentList may contain any positive number of arguments, separated by commas, where each argument expression is an AssignmentExpression. Such recursive definitions of nonterminals are common.</p>
      <p>The subscripted suffix “<sub>opt</sub>”, which may appear after a terminal or nonterminal, indicates an optional symbol. The alternative containing the optional symbol actually specifies two right-hand sides, one that omits the optional element and one that includes it. This means that:</p>
      <p>VariableDeclaration<b> </b><b>:</b></p>
      <p>Identifier Initialiser<sub>opt</sub></p>
      <p>is a convenient abbreviation for:</p>
      <p>VariableDeclaration<b> </b><b>:</b></p>
      <p>Identifier<span><br>Identifier Initialiser</span></p>
      <p>and that:</p>
      <p>IterationStatement<b> </b><b>:</b></p>
      <p><b>for ( </b>ExpressionNoIn<sub>opt</sub><b> ; </b>Expression<sub>opt</sub><b> ; </b>Expression<sub>opt</sub><b> ) </b>Statement</p>
      <p>is a convenient abbreviation for:</p>
      <p>IterationStatement<b> </b><b>:</b></p>
      <p><b>for ( ; </b>Expression<sub>opt</sub><b> ; </b>Expression<sub>opt</sub><b> ) </b>Statement<b><br>for ( </b>ExpressionNoIn<b> ; </b>Expression<sub>opt</sub><b> ; </b>Expression<sub>opt</sub><b> ) </b>Statement</p>
      <p>which in turn is an abbreviation for:</p>
      <p>IterationStatement<b> </b><b>:</b></p>
      <p><b>for ( ; ; </b>Expression<sub>opt</sub><b> ) </b>Statement<b><br>for ( ; </b>Expression<b> ; </b>Expression<sub>opt</sub><sub> </sub><b>) </b>Statement<b><br>for ( </b>ExpressionNoIn<b> ; ; </b>Expression<sub>opt</sub><sub> </sub><b>) </b>Statement<b><br>for ( </b>ExpressionNoIn<b> ; </b>Expression<b> ; </b>Expression<sub>opt</sub><sub> </sub><b>) </b>Statement</p>
      <p>which in turn is an abbreviation for:</p>
      <p>IterationStatement<b> </b><b>:</b></p>
      <p><b>for ( ; ; ) </b>Statement<br><b>for ( ; ; </b>Expression<b> ) </b>Statement<b><br>for ( ; </b>Expression<b> ; ) </b>Statement<b><br>for ( ; </b>Expression<b> ; </b>Expression<b> ) </b>Statement<b><br>for ( </b>ExpressionNoIn <b>; ; ) </b>Statement<b><br>for ( </b>ExpressionNoIn <b>; ; </b>Expression<b> ) </b>Statement<b><br>for ( </b>ExpressionNoIn <b>; </b>Expression<b> ; ) </b>Statement<b><br>for ( </b>ExpressionNoIn <b>; </b>Expression<b> ; </b>Expression<b> ) </b>Statement</p>
      <p>so the nonterminal IterationStatement actually has eight alternative right-hand sides.</p>
      <p>When the words “<b>one of</b>” follow the colon(s) in a grammar definition, they signify that each of the terminal symbols on the following line or lines is an alternative definition. For example, the lexical grammar for ECMAScript contains the production:</p>
      <p>NonZeroDigit <b>::</b><b> </b><b>one of</b></p>
      <p>
        <b>1  2  3  4  5  6  7  8  9</b>
      </p>
      <p>which is merely a convenient abbreviation for:</p>
      <p>NonZeroDigit <b>::</b></p>
      <p>
        <b>1</b>
        <b><br>2</b>
        <b><br>3</b>
        <b><br>4</b>
        <b><br>5</b>
        <b><br>6</b>
        <b><br>7</b>
        <b><br>8</b>
        <b><br>9</b>
      </p>
      <p>If the phrase “[empty]” appears as the right-hand side of a production, it indicates that the production's right-hand side contains no terminals or nonterminals.</p>
      <p>If the phrase “[lookahead ∈ <i>set</i>]” appears in the right-hand side of a production, it indicates that the production may not be used if the immediately following input token is a member of the given set. The set can be written as a list of terminals enclosed in curly braces. For convenience, the set can also be written as a nonterminal, in which case it represents the set of all terminals to which that nonterminal could expand. For example, given the definitions</p>
      <p>DecimalDigit <b>::</b><b> </b><b>one of</b></p>
      <p>
        <b>0  1  2  3  4  5  6  7  8  9</b>
      </p>
      <p>DecimalDigits<b> </b><b>::</b></p>
      <p>DecimalDigit<span><br>DecimalDigits DecimalDigit</span></p>
      <p>the definition</p>
      <p>LookaheadExample<b> </b><b>::</b></p>
      <p><b>n</b> [lookahead ∈ {<b>1</b>, <b>3</b>, <b>5</b>, <b>7</b>, <b>9</b>}] DecimalDigits<span><br>DecimalDigit </span> [lookahead ∈ DecimalDigit ]</p>
      <p>matches either the letter <b>n</b> followed by one or more decimal digits the first of which is even, or a decimal digit not followed by another decimal digit.</p>
      <p>If the phrase “[no <i>LineTerminator</i> here]” appears in the right-hand side of a production of the syntactic grammar, it indicates that the production is <i>a restricted production</i>: it may not be used if a LineTerminator occurs in the input stream at the indicated position. For example, the production:</p>
      <p>ThrowStatement<b> </b><b>:</b></p>
      <p><b>throw </b>[no LineTerminator here]<b> </b>Expression <b>;</b></p>
      <p>indicates that the production may not be used if a LineTerminator occurs in the program between the <b>throw</b> token and the Expression.</p>
      <p>Unless the presence of a LineTerminator is forbidden by a restricted production, any number of occurrences of LineTerminator may appear between any two consecutive tokens in the stream of input elements without affecting the syntactic acceptability of the program.</p>
      <p>When an alternative in a production of the lexical grammar or the numeric string grammar appears to be a multi-character token, it represents the sequence of characters that would make up such a token.</p>
      <p>The right-hand side of a production may specify that certain expansions are not permitted by using the phrase “<b>but not</b>” and then indicating the expansions to be excluded. For example, the production:</p>
      <p>Identifier<b> </b><b>::</b></p>
      <p>IdentifierName <b>but not</b> ReservedWord</p>
      <p>means that the nonterminal Identifier may be replaced by any sequence of characters that could replace IdentifierName provided that the same sequence of characters could not replace ReservedWord.</p>
      <p>Finally, a few nonterminal symbols are described by a descriptive phrase in sans-serif type in cases where it would be impractical to list all the alternatives:</p>
      <p>SourceCharacter<b> </b><b>::</b></p>
      <p>any Unicode code unit</p>
      <h2>5.2<span>	Algorithm Convention</span>s</h2>
      <p>The specification often uses a numbered list to specify steps in an algorithm. These algorithms are used to precisely specify the required semantics of ECMAScript language constructs. The algorithms are not intended to imply the use of any specific implementation technique. In practice, there may be more efficient algorithms available to implement a given feature.</p>
      <p>In order to facilitate their use in multiple parts of this specification, some algorithms, called <i>abstract</i> <i>operations</i>, are named and written in parameterised functional form so that they may be referenced by name from within other algorithms.</p>
      <p>When an algorithm is to produce a value as a result, the directive “return <i>x</i>” is used to indicate that the result of the algorithm is the value of <i>x</i> and that the algorithm should terminate. The notation Result(<i>n</i>) is used as shorthand for “the result of step <i>n</i>”. </p>
      <p>For clarity of expression, algorithm steps may be subdivided into sequential substeps. Substeps are indented and may themselves be further divided into indented substeps.  Outline numbering conventions are used to identify substeps with the first level of substeps labelled with lower case alphabetic characters and the second level of substeps labelled with lower case roman numerals.  If more than three levels are required these rules repeat with the fourth level using numeric labels. For example:</p>
      <p>Top-level step</p>
      <p>Substep.</p>
      <p>Substep </p>
      <p>Subsubstep.</p>
      <p>Subsubstep.</p>
      <p>Subsubsubstep</p>
      <p>Subsubsubsubstep</p>
      <p>A step or substep may be written as an “if” predicate that conditions its substeps.  In this case, the substeps are only applied if the predicate is true. If a step or substep begins with the word “else”, it is a predicate that is the negation of the preceding “if” predicate step at the same level.</p>
      <p>A step may specify the iterative application of its substeps.</p>
      <p>A step may assert an invariant condition of its algorithm.  Such assertions are used to make explicit algorithmic invariants that would otherwise be implicit. Such assertions add no additional semantic requirements and hence need not be checked by an implementation.  They are used simply to clarify algorithms.</p>
      <p>Mathematical operations such as addition, subtraction, negation, multiplication, division, and the mathematical functions defined later in this clause should always be understood as computing exact mathematical results on mathematical real numbers, which do not include infinities and do not include a negative zero that is distinguished from positive zero. Algorithms in this standard that model floating-point arithmetic include explicit steps, where necessary, to handle infinities and signed zero and to perform rounding. If a mathematical operation or function is applied to a floating-point number, it should be understood as being applied to the exact mathematical value represented by that floating-point number; such a floating-point number must be finite, and if it is <b>+0</b> or <b>−</b><b>0</b> then the corresponding mathematical value is simply <b>0</b>.</p>
      <p>The mathematical function abs(<i>x</i>) yields the absolute value of <i>x</i>, which is −<i>x</i> if <i>x</i> is negative (less than zero) and otherwise is <i>x</i> itself.</p>
      <p>The mathematical function sign(<i>x</i>) yields 1 if <i>x</i> is positive and −1 if <i>x</i> is negative. The sign function is not used in this standard for cases when <i>x</i> is zero.</p>
      <p>The notation “<i>x </i>modulo<i> y</i>” (<i>y</i> must be finite and nonzero) computes a value <i>k</i> of the same sign as <i>y</i> (or zero) such that abs(<i>k</i>) &lt; abs(<i>y</i>) and <i>x</i>−<i>k </i>= <i>q</i> × <i>y</i> for some integer <i>q</i>.</p>
      <p>The mathematical function floor(<i>x</i>) yields the largest integer (closest to positive infinity) that is not larger than <i>x</i>.</p>
      <p>NOTE	floor(<i>x</i>) = <i>x</i>−(<i>x</i> modulo 1).</p>
      <p>If an algorithm is defined to “throw an exception”, execution of the algorithm is terminated and no result is returned. The calling algorithms are also terminated, until an algorithm step is reached that explicitly deals with the exception, using terminology such as “If an exception was thrown…”. Once such an algorithm step has been encountered the exception is no longer considered to have occurred.</p>
      <h2>5.3 Static Semantic Rules</h2>
      <p>Context-free grammars are not sufficiently powerful to express all the rules that define whether a stream of input elements make up a valid ECMAScript program that may be evaluated.  In some situations additional rules are needed that may be expressed using either ECMAScript algorithm conventions or prose requirements. Such rules are always associated with a production of a grammar and are called the <i>static semantics</i> of the production.</p>
      <p>An implementation must validate all of the static semantic rules used to parse a <i>Program</i> prior to the first evaluation of that <i>Program</i>. If any of the static semantic rules are violated the <i>Program</i> is invalid and can not be evaluated.  Static semantic rule violations are early errors (see clause 16) and reported in the same manner as syntax errors. </p>
      <h1>6<span>	Source Tex</span>t</h1>
      <p>ECMAScript source text is represented as a sequence of characters in the Unicode character encoding, version 3.0 or later. The text is expected to have been normalised to Unicode Normalization Form C (canonical composition), as described in Unicode Technical Report #15. Conforming ECMAScript implementations are not required to perform any normalisation of text, or behave as though they were performing normalisation of text, themselves.  ECMAScript source text is assumed to be a sequence of 16-bit code units for the purposes of this specification. Such a source text may include sequences of 16-bit code units that are not valid UTF-16 character encodings. If an actual source text is encoded in a form other than 16-bit code units it must be processed as if it was first converted to UTF-16.</p>
      <p>Syntax</p>
      <p>SourceCharacter <b>::</b></p>
      <p>any Unicode code unit</p>
      <p>Throughout the rest of this document, the phrase “code unit” and the word “character” will be used to refer to a 16-bit unsigned value used to represent a single 16-bit unit of text. The phrase “Unicode character” will be used to refer to the abstract linguistic or typographical unit represented by a single Unicode scalar value (which may be longer than 16 bits and thus may be represented by more than one code unit). The phrase “code point” refers to such a Unicode scalar value. “Unicode character” only refers to entities represented by single Unicode scalar values: the components of a combining character sequence are still individual “Unicode characters,” even though a user might think of the whole sequence as a single character.</p>
      <p>In string literals, regular expression literals, and identifiers, any character (code unit) may also be expressed as a Unicode escape sequence consisting of six characters, namely <b>\u</b> plus four hexadecimal digits. Within a comment, such an escape sequence is effectively ignored as part of the comment. Within a string literal or regular expression literal, the Unicode escape sequence contributes one character to the value of the literal. Within an identifier, the escape sequence contributes one character to the identifier.</p>
      <p>NOTE<span>	Although this document sometimes refers to a “transformation” between a “character” within a “string” and the 16-bit unsigned integer that is the code unit of that character, there is actually no transformation because a “character” within a “string” is actually represented using that 16-bit unsigned value.</span></p>
      <p>ECMAScript differs from the Java programming language in the behaviour of Unicode escape sequences. In a Java program, if the Unicode escape sequence <b>\u000A</b>, for example, occurs within a single-line comment, it is interpreted as a line terminator (Unicode character <b>000A</b> is line feed) and therefore the next character is not part of the comment. Similarly, if the Unicode escape sequence <b>\u000A</b> occurs within a string literal in a Java program, it is likewise interpreted as a line terminator, which is not allowed within a string literal—one must write <b>\n</b> instead of <b>\u000A</b> to cause a line feed to be part of the string value of a string literal. In an ECMAScript program, a Unicode escape sequence occurring within a comment is never interpreted and therefore cannot contribute to termination of the comment. Similarly, a Unicode escape sequence occurring within a string literal in an ECMAScript program always contributes a character to the String value of the literal and is never interpreted as a line terminator or as a quote mark that might terminate the string literal.</p>
      <h1>7<span>	Lexical Convention</span>s</h1>
      <p>The source text of an ECMAScript program is first converted into a sequence of input elements, which are tokens, line terminators, comments, or white space. The source text is scanned from left to right, repeatedly taking the longest possible sequence of characters as the next input element.</p>
      <p>There are two goal symbols for the lexical grammar. The InputElementDiv symbol is used in those syntactic grammar contexts where a leading division (<b>/</b>) or division-assignment (<b>/=</b>) operator is permitted. The InputElementRegExp symbol is used in other syntactic grammar contexts.</p>
      <p>NOTE<span>	There are no syntactic grammar contexts where both a leading division or division-assignment, and a leading </span>RegularExpressionLiteral are permitted. This is not affected by semicolon insertion (see 7.9); in examples such as the following:</p>
      <p>
        <b>a = b</b>
        <b><br>/hi/g.exec(c).map(d);</b>
      </p>
      <p>where the first non-whitespace, non-comment character after a <i>LineTerminator</i> is slash (<b>/</b>) and the syntactic context allows division or division-assignment, no semicolon is inserted at the <i>LineTerminator</i>. That is, the above example is interpreted in the same way as:</p>
      <p>
        <b>a = b / hi / g.</b>
        <b>exec</b>
        <b>(c).map(d);</b>
      </p>
      <p>Syntax</p>
      <p>InputElementDiv <b>::</b></p>
      <p>WhiteSpace<span><br>LineTerminator</span><span><br>Comment</span><span><br>Token</span><span><br>DivPunctuator</span><br></p>
      <p>InputElementRegExp <b>::</b></p>
      <p>WhiteSpace<span><br>LineTerminator</span><span><br>Comment</span><span><br>Token</span><span><br>RegularExpressionLiteral</span></p>
      <h2>7.1<span>	Unicode Format-Control Characters</span></h2>
      <p>The Unicode format-control characters (i.e., the characters in category “Cf” in the Unicode Character Database such as left-to-right mark or right-to-left mark) are control codes used to control the formatting of a range of text in the absence of higher-level protocols for this (such as mark-up languages).</p>
      <p>It is useful to allow format-control characters in source text to facilitate editing and display. All format control characters may be used within comments, and within string literals and regular expression literals.</p>
      <p>&lt;ZWNJ&gt; and &lt;ZWJ&gt; are format-control characters that are used to make necessary distinctions when forming words or phrases in certain languages. In ECMAScript source text, &lt;ZWNJ&gt; and &lt;ZWJ&gt; may also be used in an identifier after the first character. </p>
      <p>&lt;BOM&gt; is a format-control character used primarily at the start of a text to mark it as Unicode and to allow detection of the text's encoding and byte order. &lt;BOM&gt; characters intended for this purpose can sometimes also appear after the start of a text, for example as a result of concatenating files. &lt;BOM&gt; characters are treated as white space characters (see 7.2). </p>
      <p>The special treatment of certain format-control characters outside of comments, string literals, and regular expression literals is summarised in Table 1.</p>
      <p>Table 1 — Format-Control Character Usage</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Code Unit Value</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Name</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Formal Name</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Usage</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\u200C</b>
              </p>
            </td>
            <td>
              <p>Zero width non-joiner</p>
            </td>
            <td>
              <p>&lt;ZWNJ&gt;</p>
            </td>
            <td>
              <p>
                <i>IdentifierPart</i>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\u200D</b>
              </p>
            </td>
            <td>
              <p>Zero width joiner</p>
            </td>
            <td>
              <p>&lt;ZWJ&gt;</p>
            </td>
            <td>
              <p>
                <i>IdentifierPart</i>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\uFEFF</b>
              </p>
            </td>
            <td>
              <p>Byte Order Mark</p>
            </td>
            <td>
              <p>&lt;BOM&gt;</p>
            </td>
            <td>
              <p>
                <i>Whitespace</i>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <h2>7.2<span>	White Spac</span>e</h2>
      <p>White space characters are used to improve source text readability and to separate tokens (indivisible lexical units) from each other, but are otherwise insignificant. White space characters may occur between any two tokens and at the start or end of input. White space characters may also occur within a <i>StringLiteral</i> or a <i>RegularExpressionLiteral</i> (where they are considered significant characters forming part of the literal value) or within a <i>Comment</i>, but cannot appear within any other kind of token.</p>
      <p>The ECMAScript white space characters are listed in Table 2.</p>
      <p>Table 2 — Whitespace Characters</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Code Unit Value</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Name</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Formal Name</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\u0009</b>
              </p>
            </td>
            <td>
              <p>Tab</p>
            </td>
            <td>
              <p>&lt;TAB&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\u000B</b>
              </p>
            </td>
            <td>
              <p>Vertical Tab</p>
            </td>
            <td>
              <p>&lt;VT&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\u000C</b>
              </p>
            </td>
            <td>
              <p>Form Feed</p>
            </td>
            <td>
              <p>&lt;FF&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\u0020</b>
              </p>
            </td>
            <td>
              <p>Space</p>
            </td>
            <td>
              <p>&lt;SP&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\u00A0</b>
              </p>
            </td>
            <td>
              <p>No-break space</p>
            </td>
            <td>
              <p>&lt;NBSP&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\uFEFF</b>
              </p>
              <p>Other category “Zs”</p>
            </td>
            <td>
              <p>Byte Order Mark</p>
              <p>Any other Unicode “space separator”</p>
            </td>
            <td>
              <p>&lt;BOM&gt;</p>
              <p>&lt;USP&gt;</p>
              <p>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>ECMAScript implementations must recognise all of the white space characters defined in Unicode 3.0. Later editions of the Unicode Standard may define other white space characters. ECMAScript implementations may recognise white space characters from later editions of the Unicode Standard.</p>
      <p>Syntax</p>
      <p>WhiteSpace<b> </b><b>::</b></p>
      <p>&lt;TAB&gt;<span><br>&lt;VT&gt;</span><span><br>&lt;FF&gt;</span><span><br>&lt;SP&gt;</span><span><br>&lt;NBSP&gt;</span><span><br>&lt;BOM&gt;</span><span><br>&lt;USP&gt;</span></p>
      <h2>7.3<span>	Line Terminator</span>s</h2>
      <p>Like white space characters, line terminator characters are used to improve source text readability and to separate tokens (indivisible lexical units) from each other. However, unlike white space characters, line terminators have some influence over the behaviour of the syntactic grammar. In general, line terminators may occur between any two tokens, but there are a few places where they are forbidden by the syntactic grammar. Line terminators also affect the process of automatic semicolon insertion (7.9). A line terminator cannot occur within any token except a <i>StringLiteral</i>. Line terminators may only occur within a <i>StringLiteral</i> token as part of a <i>LineContinuation</i>. </p>
      <p>A line terminator can occur within a <i>MultiLineComment</i> (7.4) but cannot occur within a <i>SingleLineComment</i>. </p>
      <p>Line terminators are included in the set of white space characters that are matched by the <b>\s</b> class in regular expressions.</p>
      <p>The ECMAScript line terminator characters are listed in Table 3.</p>
      <p>Table 3 — Line Terminator Characters</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Code Unit Value</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Name</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Formal Name</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\u000A</b>
              </p>
            </td>
            <td>
              <p>Line Feed</p>
            </td>
            <td>
              <p>&lt;LF&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\u000D</b>
              </p>
            </td>
            <td>
              <p>Carriage Return </p>
            </td>
            <td>
              <p>&lt;CR&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\u2028</b>
              </p>
            </td>
            <td>
              <p>Line separator</p>
            </td>
            <td>
              <p>&lt;LS&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\u2029</b>
              </p>
            </td>
            <td>
              <p>Paragraph separator</p>
            </td>
            <td>
              <p>&lt;PS&gt;</p>
            </td>
          </tr>
        </table>
      </figure>
      <p>Only the characters in Table 3 are treated as line terminators. Other new line or line breaking characters are treated as white space but not as line terminators. The character sequence &lt;CR&gt;&lt;LF&gt; is commonly used as a line terminator. It should be considered a single character for the purpose of reporting line numbers.</p>
      <p>Syntax</p>
      <p>LineTerminator <b>::</b></p>
      <p>&lt;LF&gt;<span><br>&lt;CR&gt;</span><span><br>&lt;LS&gt;</span><span><br>&lt;PS&gt;</span></p>
      <p>LineTerminatorSequence <b>::</b></p>
      <p>&lt;LF&gt;<span><br>&lt;CR&gt; </span>[lookahead ∈ &lt;LF&gt; ]<span><br>&lt;LS&gt;</span><span><br>&lt;PS&gt;</span><span><br>&lt;CR&gt; &lt;LF&gt;</span></p>
      <h2>7.4<span>	Comment</span>s</h2>
      <p>Comments can be either single or multi-line. Multi-line comments cannot nest.</p>
      <p>Because a single-line comment can contain any character except a <i>LineTerminator</i> character, and because of the general rule that a token is always as long as possible, a single-line comment always consists of all characters from the <b>//</b> marker to the end of the line. However, the <i>LineTerminator</i> at the end of the line is not considered to be part of the single-line comment; it is recognised separately by the lexical grammar and becomes part of the stream of input elements for the syntactic grammar. This point is very important, because it implies that the presence or absence of single-line comments does not affect the process of automatic semicolon insertion (see 7.9).</p>
      <p>Comments behave like white space and are discarded except that, if a <i>MultiLineComment</i> contains a line terminator character, then the entire comment is considered to be a <i>LineTerminator</i> for purposes of parsing by the syntactic grammar.</p>
      <p>Syntax</p>
      <p>Comment <b>::</b></p>
      <p>MultiLineComment<span><br>SingleLineComment</span></p>
      <p>MultiLineComment <b>::</b></p>
      <p><b>/*</b> MultiLineCommentChars<sub>opt</sub> <b>*/</b></p>
      <p>MultiLineCommentChars <b>::</b></p>
      <p>MultiLineNotAsteriskChar MultiLineCommentChars<sub>opt</sub><br><b>*</b> PostAsteriskCommentChars<sub>opt</sub></p>
      <p>PostAsteriskCommentChars <b>::</b></p>
      <p>MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars<sub>opt</sub><br><b>*</b> PostAsteriskCommentChars<sub>opt</sub></p>
      <p>MultiLineNotAsteriskChar<b> </b><b>::</b></p>
      <p>SourceCharacter <b>but not</b> <b>*</b></p>
      <p>MultiLineNotForwardSlashOrAsteriskChar <b>::</b></p>
      <p>SourceCharacter<b> </b><b>but not one of</b> <b>/</b><b> </b><b>or</b> <b>*</b></p>
      <p>SingleLineComment <b>::</b></p>
      <p><b>//</b> SingleLineCommentChars<sub>opt</sub></p>
      <p>SingleLineCommentChars <b>::</b></p>
      <p>SingleLineCommentChar SingleLineCommentChars<sub>opt</sub></p>
      <p>SingleLineCommentChar <b>::</b></p>
      <p>SourceCharacter<b> </b><b>but not</b><b> </b>LineTerminator</p>
      <h2>7.5<span>	Token</span>s</h2>
      <p>Syntax</p>
      <p>Token <b>::</b></p>
      <p>IdentifierName<span><br>Punctuator</span><span><br>NumericLiteral</span><span><br>StringLiteral</span></p>
      <p>NOTE<span>	The </span><i>DivPunctuator</i> and <i>RegularExpressionLiteral</i> productions define tokens, but are not included in the <i>Token</i> production.</p>
      <h2>7.6<span>	Identifier Names and Identifier</span>s</h2>
      <p>Identifier Names are tokens that are interpreted according to the grammar given in the “Identifiers” section of chapter 5 of the Unicode standard, with some small modifications. An <i>Identifier</i> is an <i>IdentifierName</i> that is not a <i>ReservedWord</i> (see 7.6.1). The Unicode identifier grammar is based on both normative and informative character categories specified by the Unicode Standard. The characters in the specified categories in version 3.0 of the Unicode standard must be treated as in those categories by all conforming ECMAScript implementations.</p>
      <p>This standard specifies specific character additions: The dollar sign (<b>$</b>) and the underscore (<b>_</b>) are permitted anywhere in an <i>IdentifierName</i>.</p>
      <p>Unicode escape sequences are also permitted in an <i>IdentifierName</i>, where they contribute a single character to the <i>IdentifierName</i>, as computed by the CV of the <i>UnicodeEscapeSequence</i> (see 7.8.4). The <b>\</b> preceding the <i>UnicodeEscapeSequence</i> does not contribute a character to the <i>IdentifierName</i>. A <i>UnicodeEscapeSequence</i> cannot be used to put a character into an <i>IdentifierName </i>that would otherwise be illegal. In other words, if a <b>\ </b><i>UnicodeEscapeSequence</i> sequence were replaced by its <i>UnicodeEscapeSequence</i>'s CV, the result must still be a valid <i>IdentifierName </i>that has the exact same sequence of characters as the original <i>IdentifierName</i>. All interpretations of identifiers within this specification are based upon their actual characters regardless of whether or not an escape sequence was used to contribute any particular characters.</p>
      <p>Two <i>IdentifierName </i>that are canonically equivalent according to the Unicode standard are <i>not</i> equal unless they are represented by the exact same sequence of code units (in other words, conforming ECMAScript implementations are only required to do bitwise comparison on IdentifierName values). The intent is that the incoming source text has been converted to normalised form C before it reaches the compiler.</p>
      <p>ECMAScript implementations may recognise identifier characters defined in later editions of the Unicode Standard. If portability is a concern, programmers should only employ identifier characters defined in Unicode 3.0.</p>
      <p>Syntax</p>
      <p>Identifier <b>::</b></p>
      <p>IdentifierName <b>but not</b> ReservedWord</p>
      <p>IdentifierName<b> </b><b>::</b></p>
      <p>IdentifierStart<span><br>IdentifierName IdentifierPart</span></p>
      <p>IdentifierStart <b>::</b></p>
      <p>UnicodeLetter<br><b>$</b><b><br>_</b><br><b>\ </b>UnicodeEscapeSequence</p>
      <p>IdentifierPart <b>::</b></p>
      <p>IdentifierStart<span><br>UnicodeCombiningMark</span><span><br>UnicodeDigit</span><span><br>UnicodeConnectorPunctuation</span><br>&lt;ZWNJ&gt;<span><br>&lt;ZWJ&gt;</span></p>
      <p>UnicodeLetter <b>::</b></p>
      <p>any character in the Unicode categories “Uppercase letter (Lu)”, “Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter (Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.</p>
      <p>UnicodeCombiningMark <b>::</b></p>
      <p>any character in the Unicode categories “Non-spacing mark (Mn)” or “Combining spacing mark (Mc)”</p>
      <p>UnicodeDigit <b>::</b></p>
      <p>any character in the Unicode category “Decimal number (Nd)”</p>
      <p>UnicodeConnectorPunctuation <b>::</b></p>
      <p>any character in the Unicode category “Connector punctuation (Pc)”</p>
      <p>The definitions of the nonterminal <i>UnicodeEscapeSequence</i> is given in 7.8.4</p>
      <p>
        <b>Static Semantics:  </b>
        <b>String Value</b>
      </p>
      <p>Identifier <b>::</b> IdentifierName <b>but not</b> ReservedWord<span style="font-weight: bold; font-style: italic"> </span></p>
      <p>Return the String Value of IdentifierName.</p>
      <p>IdentifierName<b> </b><b>::</b></p>
      <p>IdentifierStart<span><br>IdentifierName IdentifierPart</span></p>
      <p>Return the String value consisting of the sequence of characters corresponding to IdentifierName.</p>
      <h2>7.6.1<span>	Reserved Words</span></h2>
      <p>A reserved word is an <i>IdentifierName</i> that cannot be used as an <i>Identifier</i>.</p>
      <p>Syntax</p>
      <p>ReservedWord<b> </b><b>::</b></p>
      <p>Keyword<span><br>FutureReservedWord</span><span><br>NullLiteral</span><span><br>BooleanLiteral</span></p>
      <h2>7.6.1.1<span>	Keywords</span></h2>
      <p>The following tokens are ECMAScript keywords and may not be used as <i>Identifiers</i> in ECMAScript programs.</p>
      <p>Syntax</p>
      <p>Keyword :: <b>one of</b></p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>break</p>
            </td>
            <td>
              <p>do </p>
            </td>
            <td>
              <p>instanceof </p>
            </td>
            <td>
              <p>typeof </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>case</p>
            </td>
            <td>
              <p>else</p>
            </td>
            <td>
              <p>new</p>
            </td>
            <td>
              <p>var</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>catch</p>
            </td>
            <td>
              <p>finally</p>
            </td>
            <td>
              <p>return</p>
            </td>
            <td>
              <p>void</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>continue</p>
            </td>
            <td>
              <p>for</p>
            </td>
            <td>
              <p>switch</p>
            </td>
            <td>
              <p>while</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>debugger </p>
            </td>
            <td>
              <p>function</p>
            </td>
            <td>
              <p>this</p>
            </td>
            <td>
              <p>with</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>default</p>
            </td>
            <td>
              <p>if</p>
            </td>
            <td>
              <p>throw</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>delete</p>
            </td>
            <td>
              <p>in</p>
            </td>
            <td>
              <p>try</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <h2>7.6.1.2<span>	Future Reserved Words</span></h2>
      <p>The following words are used as keywords in proposed extensions and are therefore reserved to allow for the possibility of future adoption of those extensions.</p>
      <p>Syntax</p>
      <p>FutureReservedWord<b> </b><b>::</b><b> </b><b>one of</b></p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>class</p>
            </td>
            <td>
              <p>enum</p>
            </td>
            <td>
              <p>extends</p>
            </td>
            <td>
              <p>super</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>const</p>
            </td>
            <td>
              <p>export</p>
            </td>
            <td>
              <p>import</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>The following tokens are also considered to be <i>FutureReservedWords</i> when they occur within strict mode code (see 10.1.1). The occurrence of any of these tokens within strict mode code in any context where the occurrence of a <i>FutureReservedWord</i> would produce an error must also produce an equivalent error:</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>implements</p>
            </td>
            <td>
              <p>let</p>
            </td>
            <td>
              <p>private</p>
            </td>
            <td>
              <p>public</p>
            </td>
            <td>
              <p>yield</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>interface</p>
            </td>
            <td>
              <p>package</p>
            </td>
            <td>
              <p>protected</p>
            </td>
            <td>
              <p>static</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <h2>7.7<span>	Punctuator</span>s</h2>
      <p>Syntax</p>
      <p>Punctuator <b>::</b> <b>one of</b></p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>{</p>
            </td>
            <td>
              <p>}</p>
            </td>
            <td>
              <p>(</p>
            </td>
            <td>
              <p>)</p>
            </td>
            <td>
              <p>[</p>
            </td>
            <td>
              <p>]</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>.</p>
            </td>
            <td>
              <p>;</p>
            </td>
            <td>
              <p>,</p>
            </td>
            <td>
              <p>&lt;</p>
            </td>
            <td>
              <p>&gt;</p>
            </td>
            <td>
              <p>&lt;=</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>&gt;=</p>
            </td>
            <td>
              <p>==</p>
            </td>
            <td>
              <p>!=</p>
            </td>
            <td>
              <p>===</p>
            </td>
            <td>
              <p>!==</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>+</p>
            </td>
            <td>
              <p>-</p>
            </td>
            <td>
              <p>*</p>
            </td>
            <td>
              <p>%</p>
            </td>
            <td>
              <p>++</p>
            </td>
            <td>
              <p>--</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>&lt;&lt;</p>
            </td>
            <td>
              <p>&gt;&gt;</p>
            </td>
            <td>
              <p>&gt;&gt;&gt;</p>
            </td>
            <td>
              <p>&amp;</p>
            </td>
            <td>
              <p>|</p>
            </td>
            <td>
              <p>^</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>!</p>
            </td>
            <td>
              <p>~</p>
            </td>
            <td>
              <p>&amp;&amp;</p>
            </td>
            <td>
              <p>||</p>
            </td>
            <td>
              <p>?</p>
            </td>
            <td>
              <p>:</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>=</p>
            </td>
            <td>
              <p>+=</p>
            </td>
            <td>
              <p>-=</p>
            </td>
            <td>
              <p>*=</p>
            </td>
            <td>
              <p>%=</p>
            </td>
            <td>
              <p>&lt;&lt;=</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>&gt;&gt;=</p>
            </td>
            <td>
              <p>&gt;&gt;&gt;=</p>
            </td>
            <td>
              <p>&amp;=</p>
            </td>
            <td>
              <p>|=</p>
            </td>
            <td>
              <p>^=</p>
            </td>
            <td>
              <p>&lt;|</p>
            </td>
          </tr>
        </table>
      </figure>
      <p>DivPunctuator <b>::</b> <b>one of</b></p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>/</p>
            </td>
            <td>
              <p>/=</p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <h2>7.8<span>	Literal</span>s</h2>
      <p>Syntax</p>
      <p>Literal <b>::</b></p>
      <p>NullLiteral<span><br>ValueLiteral</span></p>
      <p>ValueLiteral <b>::</b></p>
      <p>BooleanLiteral<span><br>NumericLiteral</span><span><br>StringLiteral</span> <span><br>RegularExpressionLiteral</span></p>
      <h2>7.8.1<span>	Null Literal</span>s</h2>
      <p>Syntax</p>
      <p>NullLiteral <b>::</b></p>
      <p>
        <b>null</b>
      </p>
      <p>Semantics</p>
      <p>The value of the null literal <b>null</b> is the sole value of the Null type, namely <b>null</b>.</p>
      <h2>7.8.2<span>	Boolean Literal</span>s</h2>
      <p>Syntax</p>
      <p>BooleanLiteral <b>::</b></p>
      <p>
        <b>true</b>
        <b><br>false</b>
      </p>
      <p>Semantics</p>
      <p>The value of the Boolean literal <b>true</b> is a value of the Boolean type, namely <b>true</b>.</p>
      <p>The value of the Boolean literal <b>false</b> is a value of the Boolean type, namely <b>false</b>.</p>
      <h2>7.8.3<span>	Numeric Literal</span>s</h2>
      <p>Syntax</p>
      <p>NumericLiteral<b> </b><b>::</b></p>
      <p>DecimalLiteral<span><br>HexIntegerLiteral</span></p>
      <p>DecimalLiteral <b>::</b></p>
      <p>DecimalIntegerLiteral <b>.</b> DecimalDigits<sub>opt</sub><sub> </sub>  ExponentPart<sub>opt</sub><br><b>.</b> DecimalDigits ExponentPart<sub>opt</sub><span><br>DecimalIntegerLiteral ExponentPart</span><sub>opt</sub></p>
      <p>DecimalIntegerLiteral<b> </b><b>::</b></p>
      <p>
        <b>0</b>
        <span><br>NonZeroDigit DecimalDigits</span>
        <sub>opt</sub>
      </p>
      <p>DecimalDigits <b>::</b></p>
      <p>DecimalDigit<span><br>DecimalDigits DecimalDigit</span></p>
      <p>DecimalDigit <b>::</b><b> </b><b>one of</b></p>
      <p>
        <b>0  1  2  3  4  5  6  7  8  9</b>
      </p>
      <p>NonZeroDigit <b>::</b><b> </b><b>one of</b></p>
      <p>
        <b>1  2  3  4  5  6  7  8  9</b>
      </p>
      <p>ExponentPart <b>::</b></p>
      <p>ExponentIndicator SignedInteger</p>
      <p>ExponentIndicator <b>::</b><b> </b><b>one of</b></p>
      <p>
        <b>e  E</b>
      </p>
      <p>SignedInteger<b> </b><b>::</b></p>
      <p>DecimalDigits<br><b>+</b> DecimalDigits<br><b>-</b> DecimalDigits</p>
      <p>HexIntegerLiteral <b>::</b></p>
      <p><b>0x</b> HexDigit<br><b>0X</b> HexDigit<span><br>HexIntegerLiteral HexDigit</span></p>
      <p>HexDigit :: one of	</p>
      <p>
        <b>0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  A  B  C  D  E  F</b>
      </p>
      <p>The source character immediately following a <i>NumericLiteral</i> must not be an <i>IdentifierStart</i> or <i>DecimalDigit</i>.</p>
      <p>NOTE<span>	For example:</span></p>
      <p>3in</p>
      <p>is an error and not the two input elements <b>3</b> and <b>in</b>.</p>
      <p>Semantics</p>
      <p>A numeric literal stands for a value of the Number type. This value is determined in two steps: first, a mathematical value (MV) is derived from the literal; second, this mathematical value is rounded as described below.</p>
      <p>The MV of <i>NumericLiteral</i> <b>::</b> <i>DecimalLiteral</i> is the MV of <i>DecimalLiteral</i>.</p>
      <p>The MV of <i>NumericLiteral</i> <b>::</b> <i>HexIntegerLiteral</i> is the MV of <i>HexIntegerLiteral</i>.</p>
      <p>The MV of <i>DecimalLiteral </i><b>::</b><b> </b><i>DecimalIntegerLiteral </i><b>.</b><span style="font-weight: bold; font-style: italic"> </span>is the MV of <i>DecimalIntegerLiteral</i>.</p>
      <p>The MV of <i>DecimalLiteral </i><b>::</b><b> </b><i>DecimalIntegerLiteral </i><b>.</b><i> DecimalDigits</i><span style="font-weight: bold; font-style: italic"> </span>is the MV of <i>DecimalIntegerLiteral</i> plus (the MV of <i>DecimalDigits</i><span style="font-weight: bold; font-style: italic"> </span>times 10<sup>–</sup><span style="vertical-align: super; font-style: italic">n</span>), where <i>n</i> is the number of characters in <i>DecimalDigit</i>s.</p>
      <p>The MV of <i>DecimalLiteral </i><b>::</b><b> </b><i>DecimalIntegerLiteral </i><b>.</b><i> ExponentPart </i>is the MV of <i>DecimalIntegerLiteral</i> times 10<span style="vertical-align: super; font-style: italic">e</span>, where <i>e</i> is the MV of <i>ExponentPart</i>.</p>
      <p>The MV of <i>DecimalLiteral </i><b>::</b><b> </b><i>DecimalIntegerLiteral </i><b>.</b><i> DecimalDigits ExponentPart </i>is (the MV of <i>DecimalIntegerLiteral</i> plus (the MV of <i>DecimalDigits</i><span style="font-weight: bold; font-style: italic"> </span>times 10<sup>–</sup><span style="vertical-align: super; font-style: italic">n</span>)) times 10<span style="vertical-align: super; font-style: italic">e</span>, where <i>n</i> is the number of characters in <i>DecimalDigit</i>s and e is the MV of <i>ExponentPart</i>.</p>
      <p>The MV of <i>DecimalLiteral </i><b>::</b><b>.</b><i> DecimalDigits</i> is the MV of <i>DecimalDigits</i><span style="font-weight: bold; font-style: italic"> </span>times 10<sup>–</sup><span style="vertical-align: super; font-style: italic">n</span>, where <i>n</i> is the number of characters in <i>DecimalDigit</i>s.</p>
      <p>The MV of <i>DecimalLiteral </i><b>::</b><b>.</b><i> DecimalDigits ExponentPart </i>is the MV of <i>DecimalDigits</i><span style="font-weight: bold; font-style: italic"> </span>times 10<span style="vertical-align: super; font-style: italic">e</span><sup>–</sup><span style="vertical-align: super; font-style: italic">n</span>, where <i>n</i> is the number of characters in <i>DecimalDigit</i>s and <i>e</i> is the MV of <i>ExponentPart</i>.</p>
      <p>The MV of <i>DecimalLiteral </i><b>::</b><b> </b><i>DecimalIntegerLiteral</i><span style="font-weight: bold; font-style: italic"> </span>is the MV of <i>DecimalIntegerLiteral</i>.</p>
      <p>The MV of <i>DecimalLiteral </i><b>::</b><b> </b><i>DecimalIntegerLiteral ExponentPart </i>is the MV of <i>DecimalIntegerLiteral</i> times 10<span style="vertical-align: super; font-style: italic">e</span>, where <i>e</i> is the MV of <i>ExponentPart</i>.</p>
      <p>The MV of <i>DecimalIntegerLiteral</i> <b>::</b> <b>0</b> is 0.</p>
      <p>The MV of <i>DecimalIntegerLiteral</i> <b>::</b> <i>NonZeroDigit</i> is the MV of <i>NonZeroDigit.</i></p>
      <p>The MV of <i>DecimalIntegerLiteral</i> <b>::</b> <i>NonZeroDigit</i> <i>DecimalDigits</i> is (the MV of <i>NonZeroDigit</i> times 10<span style="vertical-align: super; font-style: italic">n</span>) plus the MV of <i>DecimalDigits</i>, where <i>n</i> is the number of characters in <i>DecimalDigits</i>.</p>
      <p>The MV of <i>DecimalDigits</i> <b>::</b> <i>DecimalDigit</i> is the MV of <i>DecimalDigit</i>.</p>
      <p>The MV of <i>DecimalDigits</i> <b>::</b> <i>DecimalDigits</i> <i>DecimalDigit</i> is (the MV of <i>DecimalDigits</i> times 10) plus the MV of <i>DecimalDigit</i>.</p>
      <p>The MV of <i>ExponentPart </i><b>::</b><b> </b><i>ExponentIndicator SignedInteger</i><span style="font-weight: bold; font-style: italic"> </span>is the MV of <i>SignedInteger</i>.</p>
      <p>The MV of <i>SignedInteger </i><b>::</b><b> </b><i>DecimalDigits</i><span style="font-weight: bold; font-style: italic"> </span>is the MV of <i>DecimalDigits</i>.</p>
      <p>The MV of <i>SignedInteger </i><b>::</b><b> </b><b>+</b><i> DecimalDigits</i><span style="font-weight: bold; font-style: italic"> </span>is the MV of <i>DecimalDigits</i>.</p>
      <p>The MV of <i>SignedInteger </i><b>::</b><b> </b><b>-</b><i> DecimalDigits</i><span style="font-weight: bold; font-style: italic"> </span>is the negative of the MV of <i>DecimalDigits</i>.</p>
      <p>The MV of <i>DecimalDigit</i> <b>::</b> <b>0</b> or of <i>HexDigit</i> <b>::</b> <b>0</b> is 0.</p>
      <p>The MV of <i>DecimalDigit</i> <b>::</b> <b>1</b> or of <i>NonZeroDigit</i> <b>::</b> <b>1</b> or of <i>HexDigit</i> <b>::</b> <b>1</b> is 1.</p>
      <p>The MV of <i>DecimalDigit</i> <b>::</b> <b>2</b> or of <i>NonZeroDigit</i> <b>::</b> <b>2</b> or of <i>HexDigit</i> <b>::</b> <b>2</b> is 2.</p>
      <p>The MV of <i>DecimalDigit</i> <b>::</b> <b>3</b> or of <i>NonZeroDigit</i> <b>::</b> <b>3</b> or of <i>HexDigit</i> <b>::</b> <b>3</b> is 3.</p>
      <p>The MV of <i>DecimalDigit</i> <b>::</b> <b>4</b> or of <i>NonZeroDigit</i> <b>::</b> <b>4</b> or of <i>HexDigit</i> <b>::</b> <b>4</b> is 4.</p>
      <p>The MV of <i>DecimalDigit</i> <b>::</b> <b>5</b> or of <i>NonZeroDigit</i> <b>::</b> <b>5</b> or of <i>HexDigit</i> <b>::</b> <b>5</b> is 5.</p>
      <p>The MV of <i>DecimalDigit</i> <b>::</b> <b>6</b> or of <i>NonZeroDigit</i> <b>::</b> <b>6</b> or of <i>HexDigit</i> <b>::</b> <b>6</b> is 6.</p>
      <p>The MV of <i>DecimalDigit</i> <b>::</b> <b>7</b> or of <i>NonZeroDigit</i> <b>::</b> <b>7</b> or of <i>HexDigit</i> <b>::</b> <b>7</b> is 7.</p>
      <p>The MV of <i>DecimalDigit</i> <b>::</b> <b>8</b> or of <i>NonZeroDigit</i> <b>::</b> <b>8</b> or of <i>HexDigit</i> <b>::</b> <b>8</b> is 8.</p>
      <p>The MV of <i>DecimalDigit</i> <b>::</b> <b>9</b> or of <i>NonZeroDigit</i> <b>::</b> <b>9</b> or of <i>HexDigit</i> <b>::</b> <b>9</b> is 9.</p>
      <p>The MV of <i>HexDigit</i> <b>::</b> <b>a</b> or of <i>HexDigit</i> <b>::</b> <b>A</b> is 10.</p>
      <p>The MV of <i>HexDigit</i> <b>::</b> <b>b</b> or of <i>HexDigit</i> <b>::</b> <b>B</b> is 11.</p>
      <p>The MV of <i>HexDigit</i> <b>::</b> <b>c</b> or of <i>HexDigit</i> <b>::</b> <b>C</b> is 12.</p>
      <p>The MV of <i>HexDigit</i> <b>::</b> <b>d</b> or of <i>HexDigit</i> <b>::</b> <b>D</b> is 13.</p>
      <p>The MV of <i>HexDigit</i> <b>::</b> <b>e</b> or of <i>HexDigit</i> <b>::</b> <b>E</b> is 14.</p>
      <p>The MV of <i>HexDigit</i> <b>::</b> <b>f</b> or of <i>HexDigit</i> <b>::</b> <b>F</b> is 15.</p>
      <p>The MV of <i>HexIntegerLiteral </i><b>::</b> <b>0x</b> <i>HexDigit</i> is the MV of <i>HexDigit</i>.</p>
      <p>The MV of <i>HexIntegerLiteral </i><b>::</b> <b>0X</b> <i>HexDigit</i> is the MV of <i>HexDigit</i>.</p>
      <p>The MV of <i>HexIntegerLiteral </i><b>::</b> <i>HexIntegerLiteral</i> <i>HexDigit</i> is (the MV of <i>HexIntegerLiteral</i> times 16) plus the MV of <i>HexDigit</i>.</p>
      <p>Once the exact MV for a numeric literal has been determined, it is then rounded to a value of the Number type. If the MV is 0, then the rounded value is <b>+0</b>; otherwise, the rounded value must be the Number value for the MV (as specified in 8.5), unless the literal is a <i>DecimalLiteral</i> and the literal has more than 20 significant digits, in which case the Number value may be either the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a <b>0</b> digit or the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a <b>0</b> digit and then incrementing the literal at the 20th significant digit position. A digit is <i>significant</i> if it is not part of an <i>ExponentPart</i> and</p>
      <p>it is not <b>0</b>; or</p>
      <p>there is a nonzero digit to its left and there is a nonzero digit, not in the <i>ExponentPart</i>, to its right.</p>
      <p>A conforming implementation, when processing strict mode code (see 10.1.1), must not extend the syntax of <i>NumericLiteral</i> to include <i>OctalIntegerLiteral</i> as described in B.1.1.</p>
      <h2>7.8.4<span>	String Literal</span>s</h2>
      <p>A string literal is zero or more characters enclosed in single or double quotes. Each character may be represented by an escape sequence. All characters may appear literally in a string literal except for the closing quote character, backslash, carriage return, line separator, paragraph separator, and line feed. Any character may appear in the form of an escape sequence.</p>
      <p>Syntax</p>
      <p>StringLiteral <b>::</b></p>
      <p><b>"</b> DoubleStringCharacters<sub>opt</sub><b> </b><b>"</b><b><br>'</b> SingleStringCharacters<sub>opt</sub><sub> </sub> <b>'</b></p>
      <p>DoubleStringCharacters <b>::</b></p>
      <p>DoubleStringCharacter DoubleStringCharacters<sub>opt</sub></p>
      <p>SingleStringCharacters <b>::</b></p>
      <p>SingleStringCharacter SingleStringCharacters<sub>opt</sub></p>
      <p>DoubleStringCharacter <b>::</b></p>
      <p>SourceCharacter <b>but not one of</b> <b>"</b><b> </b><b>or</b><b> </b><b>\</b> <b>or</b><b> </b>LineTerminator<br><b>\ </b>EscapeSequence<span><br>LineContinuation</span></p>
      <p>SingleStringCharacter <b>::</b></p>
      <p>SourceCharacter <b>but not one of</b> <b>'</b><b> </b><b>or</b> <b>\</b> <b>or</b><b> </b>LineTerminator<br><b>\ </b>EscapeSequence<span><br>LineContinuation</span></p>
      <p>LineContinuation <b>::</b></p>
      <p><b>\ </b>LineTerminatorSequence</p>
      <p>EscapeSequence <b>::</b></p>
      <p>CharacterEscapeSequence<br><b>0</b>  [lookahead ∈ DecimalDigit]<span><br>HexEscapeSequence</span><span><br>UnicodeEscapeSequence</span></p>
      <p>CharacterEscapeSequence <b>::</b></p>
      <p>SingleEscapeCharacter<span><br>NonEscapeCharacter</span></p>
      <p>SingleEscapeCharacter <b>::</b><b>  </b><b>one of</b></p>
      <p>
        <b>'  "  \  b  f  n  r  t  v</b>
      </p>
      <p>NonEscapeCharacter<b> </b><b>::</b></p>
      <p>SourceCharacter<b> </b><b>but not one of</b> EscapeCharacter <b>or</b><b> </b>LineTerminator</p>
      <p>EscapeCharacter <b>::</b></p>
      <p>SingleEscapeCharacter<span><br>DecimalDigit</span><br><b>x</b><b><br></b><b>u</b></p>
      <p>HexEscapeSequence <b>::</b></p>
      <p><b>x </b>HexDigit HexDigit</p>
      <p>UnicodeEscapeSequence <b>::</b></p>
      <p><b>u</b> HexDigit HexDigit HexDigit HexDigit</p>
      <p>The definition of the nonterminal <i>HexDigit</i> is given in 7.8.3. <i>SourceCharacter</i> is defined in clause 6.</p>
      <p>Semantics</p>
      <p>A string literal stands for a value of the String type. The String value (SV) of the literal is described in terms of character values (CV) contributed by the various parts of the string literal. As part of this process, some characters within the string literal are interpreted as having a mathematical value (MV), as described below or in 7.8.3.</p>
      <p>The SV of <i>StringLiteral</i> <b>::</b> <b>""</b> is the empty character sequence.</p>
      <p>The SV of <i>StringLiteral</i> <b>::</b> <b>''</b> is the empty character sequence.</p>
      <p>The SV of <i>StringLiteral</i> <b>::</b> <b>"</b> <i>DoubleStringCharacters</i> <b>"</b> is the SV of <i>DoubleStringCharacters</i>.</p>
      <p>The SV of <i>StringLiteral</i> <b>::</b> <b>'</b> <i>SingleStringCharacters</i> <b>'</b> is the SV of <i>SingleStringCharacters</i>.</p>
      <p>The SV of <i>DoubleStringCharacters </i><b>::</b> <i>DoubleStringCharacter</i> is a sequence of one character, the CV of <i>DoubleStringCharacter</i>.</p>
      <p>The SV of <i>DoubleStringCharacters </i><b>::</b> <i>DoubleStringCharacter</i> <i>DoubleStringCharacters </i>is a sequence of the CV of <i>DoubleStringCharacter</i> followed by all the characters in the SV of <i>DoubleStringCharacters</i> in order.</p>
      <p>The SV of <i>SingleStringCharacters </i><b>::</b> <i>SingleStringCharacter</i> is a sequence of one character, the CV of <i>SingleStringCharacter</i>.</p>
      <p>The SV of <i>SingleStringCharacters </i><b>::</b> <i>SingleStringCharacter</i> <i>SingleStringCharacters</i> is a sequence of the CV of <i>SingleStringCharacter</i> followed by all the characters in the SV of <i>SingleStringCharacters</i> in order.</p>
      <p>The SV of <i>LineContinuation</i> <b>::</b> <b>\</b> <i>LineTerminatorSequence</i> is the empty character sequence.</p>
      <p>The CV of <i>DoubleStringCharacter</i> <b>::</b> <i>SourceCharacter</i> <b>but not one of</b> <b>"</b><b> </b><b>or</b><b> </b><b>\</b> <b>or</b><b> </b><i>LineTerminator</i> is the<i> SourceCharacter</i> character itself.</p>
      <p>The CV of <i>DoubleStringCharacter</i> <b>::</b> <b>\</b> <i>EscapeSequence</i> is the CV of the<i> EscapeSequence</i>.</p>
      <p>The CV of <i>DoubleStringCharacter</i> <b>::</b> <i>LineContinuation</i> is the empty character sequence.</p>
      <p>The CV of <i>SingleStringCharacter</i> <b>::</b> <i>SourceCharacter</i> <b>but not one of</b> <b>'</b><b> </b><b>or</b><b> </b><b>\</b> <b>or</b><b> </b><i>LineTerminator</i> is the<i> SourceCharacter</i> character itself.</p>
      <p>The CV of <i>SingleStringCharacter</i> <b>::</b><b> </b><b>\</b> <i>EscapeSequence</i> is the CV of the<i> EscapeSequence</i>.</p>
      <p>The CV of <i>SingleStringCharacter</i> <b>:: </b><i>LineContinuation</i> is the empty character sequence.</p>
      <p>The CV of <i>EscapeSequence </i><b>::</b> <i>CharacterEscapeSequence</i> is the CV of the<i> CharacterEscapeSequence</i>.</p>
      <p>The CV of <i>EscapeSequence </i><b>::</b> <b>0</b>  [lookahead ∈ <i>DecimalDigit</i>] is a &lt;NUL&gt; character (Unicode value 0000).</p>
      <p>The CV of <i>EscapeSequence </i><b>::</b> <i>HexEscapeSequence</i> is the CV of the<i> HexEscapeSequence</i>.</p>
      <p>The CV of <i>EscapeSequence </i><b>::</b> <i>UnicodeEscapeSequence</i> is the CV of the<i> UnicodeEscapeSequence</i>.</p>
      <p>The<i> </i>CV<i> </i>of<i> CharacterEscapeSequence </i><b>::</b><i> SingleEscapeCharacter </i>is the character whose code unit value is determined by  the<i> SingleEscapeCharacter </i>according to Table 4:</p>
      <p>Table 4 — String Single Character Escape Sequences</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Escape Sequence</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Code Unit Value</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Name</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Symbol</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\b</b>
              </p>
            </td>
            <td>
              <p>
                <b>\u0008</b>
              </p>
            </td>
            <td>
              <p>backspace</p>
            </td>
            <td>
              <p>&lt;BS&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\t</b>
              </p>
            </td>
            <td>
              <p>
                <b>\u0009</b>
              </p>
            </td>
            <td>
              <p>horizontal tab</p>
            </td>
            <td>
              <p>&lt;HT&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\n</b>
              </p>
            </td>
            <td>
              <p>
                <b>\u000A</b>
              </p>
            </td>
            <td>
              <p>line feed (new line)</p>
            </td>
            <td>
              <p>&lt;LF&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\v</b>
              </p>
            </td>
            <td>
              <p>
                <b>\u000B</b>
              </p>
            </td>
            <td>
              <p>vertical tab</p>
            </td>
            <td>
              <p>&lt;VT&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\f</b>
              </p>
            </td>
            <td>
              <p>
                <b>\u000C</b>
              </p>
            </td>
            <td>
              <p>form feed</p>
            </td>
            <td>
              <p>&lt;FF&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\r</b>
              </p>
            </td>
            <td>
              <p>
                <b>\u000D</b>
              </p>
            </td>
            <td>
              <p>carriage return</p>
            </td>
            <td>
              <p>&lt;CR&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\"</b>
              </p>
            </td>
            <td>
              <p>
                <b>\u0022</b>
              </p>
            </td>
            <td>
              <p>double quote</p>
            </td>
            <td>
              <p>
                <b>"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\'</b>
              </p>
            </td>
            <td>
              <p>
                <b>\u0027</b>
              </p>
            </td>
            <td>
              <p>single quote</p>
            </td>
            <td>
              <p>
                <b>'</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>\\</b>
              </p>
            </td>
            <td>
              <p>
                <b>\u005C</b>
              </p>
            </td>
            <td>
              <p>backslash</p>
            </td>
            <td>
              <p>
                <b>\</b>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>The CV of <i>CharacterEscapeSequence</i> <b>::</b> <i>NonEscapeCharacter</i> is the CV of the<i> NonEscapeCharacter</i>.</p>
      <p>The CV of <i>NonEscapeCharacter</i> <b>::</b> <i>SourceCharacter</i><b> </b><b>but not one of</b> <i>EscapeCharacter</i> <b>or</b><b> </b><i>LineTerminator</i> is the <i>SourceCharacter</i> character itself.</p>
      <p>The CV of <i>HexEscapeSequence</i> <b>::</b> <b>x</b><i> HexDigit</i> <i>HexDigit</i> is the character whose code unit value is (16 times the MV of the first <i>HexDigit</i>) plus the MV of the second <i>HexDigit</i>.</p>
      <p>The CV of <i>UnicodeEscapeSequence</i> <b>::</b> <b>u</b><i> </i>HexDigit <i>HexDigit</i> <i>HexDigit</i> <i>HexDigit</i> is the character whose code unit value is (4096 times the MV of the first <i>HexDigit</i>) plus (256 times the MV of the second <i>HexDigit</i>) plus (16 times the MV of the third <i>HexDigit</i>) plus the MV of the fourth <i>HexDigit</i>.</p>
      <p>A conforming implementation, when processing strict mode code (see 10.1.1), may not extend the syntax of <i>EscapeSequence</i> to include <i>OctalEscapeSequence</i> as described in B.1.2.</p>
      <p>NOTE<span>	A line terminator character cannot appear in a string literal, except as part of a </span>LineContinuation to produce the empty character sequence. The correct way to cause a line terminator character to be part of the String value of a string literal is to use an escape sequence such as <b>\n</b> or <b>\u000A</b>.</p>
      <h2>7.8.5<span>	Regular Expression Literals</span></h2>
      <p>A regular expression literal is an input element that is converted to a RegExp object (see 15.10) each time the literal is evaluated. Two regular expression literals in a program evaluate to regular expression objects that never compare as <b>===</b> to each other even if the two literals' contents are identical. A RegExp<b> </b>object may also be created at runtime by <b>new RegExp</b> (see 15.10.4) or calling the <b>RegExp</b> constructor as a function (15.10.3).</p>
      <p>The productions below describe the syntax for a regular expression literal and are used by the input element scanner to find the end of the regular expression literal. The Strings of characters comprising the RegularExpressionBody and the RegularExpressionFlags are passed uninterpreted to the regular expression constructor, which interprets them according to its own, more stringent grammar. An implementation may extend the regular expression constructor's grammar, but it must not extend the RegularExpressionBody and RegularExpressionFlags productions or the productions used by these productions.</p>
      <p>Syntax</p>
      <p>RegularExpressionLiteral <b>::</b></p>
      <p><b>/</b> RegularExpressionBody<b> </b><b>/</b><b> </b>RegularExpressionFlags</p>
      <p>RegularExpressionBody<b> </b><b>::</b></p>
      <p>RegularExpressionFirstChar RegularExpressionChars</p>
      <p>RegularExpressionChars <b>::</b></p>
      <p>[empty]<span><br>RegularExpressionChars RegularExpressionChar</span></p>
      <p>RegularExpressionFirstChar <b>::</b></p>
      <p>RegularExpressionNonTerminator <b>but not one of</b> <b>*</b><b> </b><b>or</b><b> </b><b>\</b> <b>or</b><b> </b><b>/ </b><b>or</b><b> [</b><span><br>RegularExpressionBackslashSequence</span><span><br>RegularExpressionClass</span></p>
      <p>RegularExpressionChar <b>::</b></p>
      <p>RegularExpressionNonTerminator<b> </b><b>but not one of</b><b> </b><b>\</b><b> </b><b>or</b><b> </b><b>/ </b><b>or</b><b> [</b><span><br>RegularExpressionBackslashSequence</span><span><br>RegularExpressionClass</span></p>
      <p>RegularExpressionBackslashSequence <b>::</b></p>
      <p><b>\</b> RegularExpressionNonTerminator</p>
      <p>RegularExpressionNonTerminator <b>::</b></p>
      <p>SourceCharacter<b> </b><b>but not</b><b> </b>LineTerminator</p>
      <p>RegularExpressionClass <b>::</b></p>
      <p><b>[ </b>RegularExpressionClassChars<b> ]</b></p>
      <p>RegularExpressionClassChars<b> </b><b>::</b></p>
      <p>[empty]<span><br>RegularExpressionClassChars</span><b> </b>RegularExpressionClassChar</p>
      <p>RegularExpressionClassChar<b> </b><b>::</b></p>
      <p>RegularExpressionNonTerminator<b> </b><b>but not one of</b><b> </b><b>]</b><b> </b><b>or</b><b> </b><b>\</b><b><br></b>RegularExpressionBackslashSequence</p>
      <p>RegularExpressionFlags<b> </b><b>::</b></p>
      <p>[empty]<span><br>RegularExpressionFlags IdentifierPart</span></p>
      <p>NOTE<span>	Regular expression literals may not be empty; instead of representing an empty regular expression literal, the characters </span><b>//</b> start a single-line comment. To specify an empty regular expression, use:  <b>/(?:)/</b>.</p>
      <p>Semantics</p>
      <p>A regular expression literal evaluates to a value of the Object type that is an instance of the standard built-in constructor RegExp. This value is determined in two steps: first, the characters comprising the regular expression's <i>RegularExpressionBody</i> and <i>RegularExpressionFlags</i> production expansions are collected uninterpreted into two Strings Pattern and Flags, respectively. Then each time the literal is evaluated, a new object is created as if by the expression <b>new RegExp(</b>Pattern, Flags<b>)</b> where RegExp is the standard built-in constructor with that name. The newly constructed object becomes the value of the <i>RegularExpressionLiteral</i>. If the call to <b>new RegExp</b> would generate an error as specified in 15.10.4.1, the error must be treated as an early error (Clause 16).</p>
      <h2>7.9<span>	Automatic Semicolon Insertio</span>n</h2>
      <p>Certain ECMAScript statements (empty statement, variable statement, expression statement, <b>do</b>-<b>while</b> statement, <b>continue</b> statement, <b>break</b> statement, <b>return</b> statement, and <b>throw</b> statement) must be terminated with semicolons. Such semicolons may always appear explicitly in the source text. For convenience, however, such semicolons may be omitted from the source text in certain situations. These situations are described by saying that semicolons are automatically inserted into the source code token stream in those situations.</p>
      <h2>7.9.1<span>	Rules of Automatic Semicolon Insertio</span>n</h2>
      <p>There are three basic rules of semicolon insertion:</p>
      <p>When, as the program is parsed from left to right, a token (called the <i>offending token</i>) is encountered that is not allowed by any production of the grammar, then a semicolon is automatically inserted before the offending token if one or more of the following conditions is true:</p>
      <p>The offending token is separated from the previous token by at least one LineTerminator.</p>
      <p>The offending token is <b>}</b>.</p>
      <p>When, as the program is parsed from left to right, the end of the input stream of tokens is encountered and the parser is unable to parse the input token stream as a single complete ECMAScript Program, then a semicolon is automatically inserted at the end of the input stream.</p>
      <p>When, as the program is parsed from left to right, a token is encountered that is allowed by some production of the grammar, but the production is a <i>restricted production</i> and the token would be the first token for a terminal or nonterminal immediately following the annotation “[no <i>LineTerminator</i> here]” within the restricted production (and therefore such a token is called a restricted token), and the restricted token is separated from the previous token by at least one LineTerminator, then a semicolon is automatically inserted before the restricted token.</p>
      <p>However, there is an additional overriding condition on the preceding rules: a semicolon is never inserted automatically if the semicolon would then be parsed as an empty statement or if that semicolon would become one of the two semicolons in the header of a <b>for</b> statement (see 12.6.3).</p>
      <p>NOTE<span>	The following are the only restricted productions in the grammar:</span></p>
      <p>PostfixExpression <b>:</b></p>
      <p>LeftHandSideExpression<b> </b>[no LineTerminator here]<b> ++</b><br>LeftHandSideExpression<b> </b>[no LineTerminator here]<b> --</b></p>
      <p>ContinueStatement <b>:</b></p>
      <p><b>continue </b>[no LineTerminator here] Identifier <b>;</b></p>
      <p>BreakStatement <b>:</b></p>
      <p><b>break </b>[no LineTerminator here] Identifier <b>;</b></p>
      <p>ReturnStatement <b>:</b></p>
      <p><b>return </b>[no LineTerminator here]<b> </b>Expression <b>;</b></p>
      <p>ThrowStatement<b> </b><b>:</b></p>
      <p><b>throw</b> [no LineTerminator here] Expression <b>;</b></p>
      <p>The practical effect of these restricted productions is as follows:</p>
      <p>When a <b>++</b> or <b>--</b> token is encountered where the parser would treat it as a postfix operator, and at least one LineTerminator occurred between the preceding token and the <b>++</b> or <b>--</b> token, then a semicolon is automatically inserted before the <b>++</b> or <b>--</b> token.</p>
      <p>When a <b>continue</b>, <b>break</b>, <b>return</b>, or <b>throw</b> token is encountered and a LineTerminator is encountered before the next token, a semicolon is automatically inserted after the <b>continue</b>, <b>break</b>, <b>return</b>, or <b>throw</b> token.</p>
      <p>The resulting practical advice to ECMAScript programmers is:</p>
      <p>A postfix <b>++</b> or <b>--</b> operator should appear on the same line as its operand.</p>
      <p>An Expression in a <b>return</b> or <b>throw</b> statement should start on the same line as the <b>return</b> or <b>throw</b> token.</p>
      <p>An Identifier in a <b>break</b> or <b>continue</b> statement should be on the same line as the <b>break</b> or <b>continue</b> token.</p>
      <h2>7.9.2<span>	Examples of Automatic Semicolon Insertio</span>n</h2>
      <p>The source</p>
      <p>{ 1 2 } 3</p>
      <p>is not a valid sentence in the ECMAScript grammar, even with the automatic semicolon insertion rules. In contrast, the source</p>
      <p>{ 1<span><br>2 } 3</span></p>
      <p>is also not a valid ECMAScript sentence, but is transformed by automatic semicolon insertion into the following:</p>
      <p>{ 1<span><br>;2 ;} 3;</span></p>
      <p>which is a valid ECMAScript sentence.</p>
      <p>The source</p>
      <p>for (a; b<span><br>)</span></p>
      <p>is not a valid ECMAScript sentence and is not altered by automatic semicolon insertion because the semicolon is needed for the header of a <b>for</b> statement. Automatic semicolon insertion never inserts one of the two semicolons in the header of a <b>for</b> statement.</p>
      <p>The source</p>
      <p>return<span><br>a + b</span></p>
      <p>is transformed by automatic semicolon insertion into the following:</p>
      <p>return;<span><br>a + b;</span></p>
      <p>NOTE<span>	The expression </span><b>a + b</b> is not treated as a value to be returned by the <b>return</b> statement, because a LineTerminator separates it from the token <b>return</b>.</p>
      <p>The source</p>
      <p>a = b<span><br>++c</span></p>
      <p>is transformed by automatic semicolon insertion into the following:</p>
      <p>a = b;<span><br>++c;</span></p>
      <p>NOTE<span>	The token </span><b>++</b> is not treated as a postfix operator applying to the variable <b>b</b>, because a LineTerminator occurs between <b>b</b> and <b>++</b>.</p>
      <p>The source</p>
      <p>if (a &gt; b)<span><br>else c = d</span></p>
      <p>is not a valid ECMAScript sentence and is not altered by automatic semicolon insertion before the <b>else</b> token, even though no production of the grammar applies at that point, because an automatically inserted semicolon would then be parsed as an empty statement.</p>
      <p>The source</p>
      <p>a = b + c<span><br>(d + e).print()</span></p>
      <p>is <i>not</i> transformed by automatic semicolon insertion, because the parenthesised expression that begins the second line can be interpreted as an argument list for a function call:</p>
      <p>a = b + c(d + e).print()</p>
      <p>In the circumstance that an assignment statement must begin with a left parenthesis, it is a good idea for the programmer to provide an explicit semicolon at the end of the preceding statement rather than to rely on automatic semicolon insertion.</p>
      <h1>8<span>	Type</span>s</h1>
      <p>Algorithms within this specification manipulate values each of which has an associated type. The possible value types are exactly those defined in this clause. Types are further subclassified into ECMAScript language types and specification types.</p>
      <p>An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object.</p>
      <p>A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record. Specification type values are specification artefacts that do not necessarily correspond to any specific entity within an ECMAScript implementation. Specification type values may be used to describe intermediate results of ECMAScript expression evaluation but such values cannot be stored as properties of objects or values of ECMAScript language variables.</p>
      <p>Within this specification, the notation “Type(<i>x</i>)” is used as shorthand for “the type of <i>x</i>” where “type” refers to the ECMAScript language and specification types defined in this clause.</p>
      <h2>8.1<span>	The Undefined Typ</span>e</h2>
      <p>The Undefined type has exactly one value, called <b>undefined</b>. Any variable that has not been assigned a value has the value <b>undefined</b>.</p>
      <h2>8.2<span>	The Null Typ</span>e</h2>
      <p>The Null type has exactly one value, called <b>null</b>.</p>
      <h2>8.3<span>	The Boolean Typ</span>e</h2>
      <p>The Boolean type represents a logical entity having two values, called <b>true </b>and <b>false</b>.</p>
      <h2>8.4<span>	The String </span>Type</h2>
      <p>The String type is the set of all finite ordered sequences of zero or more 16-bit unsigned integer values (“elements”). The String type is generally used to represent textual data in a running ECMAScript program, in which case each element in the String is treated as a code unit value (see Clause 6). Each element is regarded as occupying a position within the sequence. These positions are indexed with nonnegative integers. The first element (if any) is at position 0, the next element (if any) at position 1, and so on. The length of a String is the number of elements (i.e., 16-bit values) within it. The empty String has length zero and therefore contains no elements.</p>
      <p>When a String contains actual textual data, each element is considered to be a single UTF-16 code unit. Whether or not this is the actual storage format of a String, the characters within a String are numbered by their initial code unit element position as though they were represented using UTF-16. All operations on Strings (except as otherwise stated) treat them as sequences of undifferentiated 16-bit unsigned integers; they do not ensure the resulting String is in normalised form, nor do they ensure language-sensitive results.</p>
      <p>NOTE<span>	The rationale behind this design was to keep the implementation of Strings as simple and high-performing as possible. The intent is that textual data coming into the execution environment from outside (e.g., user input, text read from a file or received over the network, etc.) be converted to Unicode Normalised Form C before the running program sees it. Usually this would occur at the same time incoming text is converted from its original character encoding to Unicode (and would impose no additional overhead). Since it is recommended that ECMAScript source code be in Normalised Form C, string literals are guaranteed to be normalised (if source text is guaranteed to be normalised), as long as they do not contain any Unicode escape sequences.</span></p>
      <h2>8.5<span>	The Number Typ</span>e</h2>
      <p>The Number type has exactly 18437736874454810627 (that is, 2<sup>64</sup>−2<sup>53</sup>+3) values, representing the double-precision 64-bit format IEEE 754 values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except that the 9007199254740990 (that is, 2<sup>53</sup>−2) distinct “Not-a-Number” values of the IEEE Standard are represented in ECMAScript as a single special <b>NaN</b> value. (Note that the <b>NaN</b> value is produced by the program expression <b>NaN</b>.) In some implementations, external code might be able to detect a difference between various Not-a-Number values, but such behaviour is implementation-dependent; to ECMAScript code, all NaN values are indistinguishable from each other.</p>
      <p>There are two other special values, called <b>positive Infinity</b> and <b>negative Infinity</b>. For brevity, these values are also referred to for expository purposes by the symbols <b>+</b><b>∞</b> and <b>−</b><b>∞</b>, respectively. (Note that these two infinite Number values are produced by the program expressions <b>+Infinity</b> (or simply <b>Infinity</b>) and <b>-Infinity</b>.)</p>
      <p>The other 18437736874454810624 (that is, 2<sup>64</sup>−2<sup>53</sup>) values are called the finite numbers. Half of these are positive numbers and half are negative numbers; for every finite positive Number value there is a corresponding negative value having the same magnitude.</p>
      <p>Note that there is both a <b>positive zero</b> and a <b>negative zero</b>. For brevity, these values are also referred to for expository purposes by the symbols <b>+0</b> and <b>−</b><b>0</b>, respectively. (Note that these two different zero Number values are produced by the program expressions <b>+0</b> (or simply <b>0</b>) and <b>-0</b>.)</p>
      <p>The 18437736874454810622 (that is, 2<sup>64</sup>−2<sup>53</sup>−2) finite nonzero values are of two kinds:</p>
      <p>18428729675200069632 (that is, 2<sup>64</sup>−2<sup>54</sup>) of them are normalised, having the form</p>
      <p><i>s</i> × <i>m</i> × 2<span style="vertical-align: super; font-style: italic">e</span></p>
      <p>where <i>s</i> is +1 or −1, <i>m</i> is a positive integer less than 2<sup>53</sup> but not less than 2<sup>52</sup>, and <i>e</i> is an integer ranging from −1074 to 971, inclusive.</p>
      <p>The remaining 9007199254740990 (that is, 2<sup>53</sup>−2) values are denormalised, having the form</p>
      <p><i>s</i> × <i>m</i> × 2<span style="vertical-align: super; font-style: italic">e</span></p>
      <p>where <i>s</i> is +1 or −1, <i>m</i> is a positive integer less than 2<sup>52</sup>, and <i>e</i> is −1074.</p>
      <p>Note that all the positive and negative integers whose magnitude is no greater than 2<sup>53</sup> are representable in the Number type (indeed, the integer 0 has two representations, <b>+0</b> and <b>-0</b>).</p>
      <p>A finite number has an <i>odd significand</i> if it is nonzero and the integer <i>m</i> used to express it (in one of the two forms shown above) is odd. Otherwise, it has an <i>even significand</i>.</p>
      <p>In this specification, the phrase “the Number value for <i>x</i>” where <i>x</i> represents an exact nonzero real mathematical quantity (which might even be an irrational number such as π) means a Number value chosen in the following manner. Consider the set of all finite values of the Number type, with <b>−</b><b>0</b> removed and with two additional values added to it that are not representable in the Number type, namely 2<sup>1024</sup> (which is +1 × 2<sup>53</sup> × 2<sup>971</sup>) and −2<sup>1024</sup> (which is −1 × 2<sup>53</sup> × 2<sup>971</sup>). Choose the member of this set that is closest in value to <i>x</i>. If two values of the set are equally close, then the one with an even significand is chosen; for this purpose, the two extra values 2<sup>1024</sup> and −2<sup>1024</sup> are considered to have even significands. Finally, if 2<sup>1024</sup> was chosen, replace it with <b>+</b><b>∞</b>; if −2<sup>1024</sup> was chosen, replace it with <b>−</b><b>∞</b>; if <b>+0</b> was chosen, replace it with <b>−</b><b>0</b> if and only if <i>x</i> is less than zero; any other chosen value is used unchanged. The result is the Number value for <i>x</i>. (This procedure corresponds exactly to the behaviour of the IEEE 754 “round to nearest” mode.)</p>
      <p>Some ECMAScript operators deal only with integers in the range −2<sup>31</sup> through 2<sup>31</sup>−1, inclusive, or in the range 0 through 2<sup>32</sup>−1, inclusive. These operators accept any value of the Number type but first convert each such value to one of 2<sup>32</sup> integer values. See the descriptions of the ToInt32 and ToUint32 operators in 9.5 and 9.6, respectively.</p>
      <h2>8.6<span>	The Object Typ</span>e</h2>
      <p>An Object is a collection of properties.<i> </i>Each property is either a named data property, a named accessor property, or an internal property:</p>
      <p>A <i>named data property</i> associates a name with an ECMAScript language value and a set of Boolean attributes.</p>
      <p>A <i>named accessor property</i> associates a name with one or two accessor functions, and a set of Boolean attributes. The accessor functions are used to store or retrieve an ECMAScript language value that is associated with the property. </p>
      <p>An <i>internal property</i> has no name and is not directly accessible via ECMAScript language operators. Internal properties exist purely for specification purposes. </p>
      <p>There are two kinds of access for named (non-internal) properties: <i>get </i>and <i>put</i>, corresponding to retrieval and assignment, respectively.</p>
      <h2>8.6.1<span>	Property Attribute</span>s</h2>
      <p>Attributes are used in this specification to define and explain the state of named properties. A named data property associates a name with the attributes listed in Table 5</p>
      <p>Table 5 — Attributes of a Named Data Property</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Attribute Name</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Value Domain</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Description</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Value]] </p>
            </td>
            <td>
              <p>Any ECMAScript language type</p>
            </td>
            <td>
              <p>The value retrieved by reading the property.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Writable]] </p>
            </td>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>If <b>false</b>, attempts by ECMAScript code to change the property’s [[Value]] attribute using [[Put]] will not succeed.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Enumerable]]</p>
            </td>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>If <b>true</b>, the property will be enumerated by a for-in enumeration (see 12.6.4). Otherwise, the property is said to be non-enumerable.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Configurable]]</p>
            </td>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>If <b>false</b>, attempts to delete the property, change the property to be an accessor property, or change its attributes (other than [[Value]]) will fail.</p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>A named accessor property associates a name with the attributes listed in Table 6.</p>
      <p>Table 6 — Attributes of a Named Accessor Property</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Attribute Name</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Value Domain</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Description</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Get]]</p>
            </td>
            <td>
              <p>Object <i>or </i>Undefined</p>
            </td>
            <td>
              <p>If the value is an Object it must be a function Object.  The function’s [[Call]] internal method (8.6.2) is called with an empty arguments list to return the property value each time a get access of the property is performed.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Set]]</p>
            </td>
            <td>
              <p>Object <i>or </i> Undefined</p>
            </td>
            <td>
              <p>If the value is an Object it must be a function Object.  The function’s [[Call]] internal method (8.6.2) is called with an arguments list containing the assigned value as its sole argument each time a set access of the property is performed. The effect of a property's [[Set]] internal method may, but is not required to, have an effect on the value returned by subsequent calls to the property's [[Get]] internal method.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Enumerable]]</p>
            </td>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>If <b>true</b>, the property is to be enumerated by a for-in enumeration (see 12.6.4). Otherwise, the property is said to be non-enumerable.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Configurable]]</p>
            </td>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>If <b>false</b>, attempts to delete the property, change the property to be a data property, or change its attributes will fail.</p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>If the value of an attribute is not explicitly specified by this specification for a named property, the default value defined in Table 7 is used.</p>
      <p>Table 7 — Default Attribute Values</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <b>Attribute Name</b>
              </p>
            </td>
            <td>
              <p>
                <b>Default Value</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Value]]</p>
            </td>
            <td>
              <p>
                <b>undefined</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Get]]</p>
            </td>
            <td>
              <p>
                <b>undefined</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Set]]</p>
            </td>
            <td>
              <p>
                <b>undefined</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Writable]]</p>
            </td>
            <td>
              <p>
                <b>false</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Enumerable]]</p>
            </td>
            <td>
              <p>
                <b>false</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Configurable]]</p>
            </td>
            <td>
              <p>
                <b>false</b>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <h2>8.6.2<span>	Object Internal Properties and Method</span>s</h2>
      <p>This specification uses various internal properties to define the semantics of object values. These internal properties are not part of the ECMAScript language. They are defined by this specification purely for expository purposes. An implementation of ECMAScript must behave as if it produced and operated upon internal properties in the manner described here. The names of internal properties are enclosed in double square brackets [[ ]]. When an algorithm uses an internal property of an object and the object does not implement the indicated internal property, a <b>TypeError</b> exception is thrown.</p>
      <p>The Table 8 summarises the internal properties used by this specification that are applicable to all ECMAScript objects. The Table 9 summarises the internal properties used by this specification that are only applicable to some ECMAScript objects. The descriptions in these tables indicate their behaviour for native ECMAScript objects, unless stated otherwise in this document for particular kinds of native ECMAScript objects. Host objects may support these internal properties with any implementation-dependent behaviour as long as it is consistent with the specific host object restrictions stated in this document.</p>
      <p>The “Value Type Domain” columns of the following tables define the types of values associated with internal properties. The type names refer to the types defined in Clause 8 augmented by the following additional names. “<i>any</i>” means the value may be any ECMAScript language type. “<i>primitive</i>” means Undefined, Null, Boolean, String, or Number. “<i>SpecOp</i>” means the internal property is an internal method, an implementation provided procedure defined by an abstract operation specification. “SpecOp” is followed by a list of descriptive parameter names. If a parameter name is the same as a type name then the name describes the type of the parameter. If a “SpecOp” returns a value, its parameter list is followed by the symbol “→” and the type of the returned value.</p>
      <p>Table 8 — Internal Properties Common to All Objects</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Internal Property</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Value Type Domain</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Description</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Prototype]]</p>
            </td>
            <td>
              <p>Object <i>or </i>Null</p>
            </td>
            <td>
              <p>The prototype of this object.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Extensible]]</p>
            </td>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>If <b>true</b>, own properties may be added to the object.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Get]]</p>
            </td>
            <td>
              <p>SpecOp(<i>propertyName</i>) <span style="font-weight: bold; font-style: italic">→</span> any</p>
            </td>
            <td>
              <p>Returns the value of the named property.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[GetOwnProperty]]</p>
            </td>
            <td>
              <p>SpecOp (<i>propertyName</i>) <span style="font-weight: bold; font-style: italic">→</span></p>
              <p>Undefined<i> or </i>Property Descriptor</p>
            </td>
            <td>
              <p>Returns the Property Descriptor of the named own property of this object, or <b>undefined </b>if absent.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[GetProperty]]</p>
            </td>
            <td>
              <p>SpecOp (<i>propertyName</i>) <span style="font-weight: bold; font-style: italic">→</span></p>
              <p>Undefined<i> or </i>Property Descriptor</p>
            </td>
            <td>
              <p>Returns the fully populated Property Descriptor of the named property of this object, or <b>undefined </b>if absent.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Put]]</p>
            </td>
            <td>
              <p>SpecOp (<i>propertyName</i>, <i>any, Boolean</i>)</p>
            </td>
            <td>
              <p>Sets the specified named property to the value of the second parameter. The flag controls failure handling.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[CanPut]]</p>
            </td>
            <td>
              <p>SpecOp (<i>propertyName</i>) <span style="font-weight: bold; font-style: italic">→</span> Boolean</p>
            </td>
            <td>
              <p>Returns a Boolean value indicating whether a [[Put]] operation with <i>PropertyName</i> can be performed.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[HasProperty]]</p>
            </td>
            <td>
              <p>SpecOp (<i>propertyName</i>) <span style="font-weight: bold; font-style: italic">→</span> <i>Boolean</i></p>
            </td>
            <td>
              <p>Returns a Boolean value indicating whether the object already has a property with the given name.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Delete]]</p>
            </td>
            <td>
              <p>SpecOp (<i>propertyName, Boolean</i>) <span style="font-weight: bold; font-style: italic">→</span> Boolean</p>
            </td>
            <td>
              <p>Removes the specified named own property from the object. The flag controls failure handling.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[DefaultValue]]</p>
            </td>
            <td>
              <p>SpecOp (<i>Hint</i>) <span style="font-weight: bold; font-style: italic">→</span> <i>primitive</i></p>
            </td>
            <td>
              <p>Hint is a String. Returns a default value for the object.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[DefineOwnProperty]]</p>
            </td>
            <td>
              <p>SpecOp (<i>propertyName, PropertyDescriptor, Boolean</i>)<span style="font-weight: bold; font-style: italic"> →</span> Boolean</p>
            </td>
            <td>
              <p>Creates or alters the named own property to have the state described by a Property Descriptor. The flag controls failure handling.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Enumerate]]</p>
            </td>
            <td>
              <p>SpecOp()<span style="font-weight: bold; font-style: italic">→</span>Object</p>
            </td>
            <td>
              <p>Returns an object that can enumerate the string values of the keys of the enumerable properties of the object. The returned object is an Iterator object.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Iterate]]</p>
            </td>
            <td>
              <p>SpecOp()<span style="font-weight: bold; font-style: italic">→</span>Object</p>
            </td>
            <td>
              <p>Returns an object that can enumate the logical component values of the object. The returned object is an Iterator object.</p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>Every object (including host objects) must implement all of the internal properties listed in Table 8. However, the [[DefaultValue]] internal method may, for some objects, simply throw a <b>TypeError</b> exception.</p>
      <p>All objects have an internal property called [[Prototype]]. The value of this property is either <b>null</b> or an object and is used for implementing inheritance. Whether or not a native object can have a host object as its [[Prototype]] depends on the implementation. Every [[Prototype]] chain must have finite length (that is, starting from any object, recursively accessing the [[Prototype]] internal property must eventually lead to a <b>null</b> value). Named data properties of the [[Prototype]] object are inherited (are visible as properties of the child object) for the purposes of get access, but not for put access. Named accessor properties are inherited for both get access and put access.</p>
      <p>Every ECMAScript object has a Boolean-valued [[Extensible]] internal property that controls whether or not named properties may be added to the object. If the value of the [[Extensible]] internal property is <b>false</b> then additional named properties may not be added to the object.  In addition, if [[Extensible]] is <b>false</b> the value of [[Prototype]] internal properties of the object may not be modified.  Once the value of an [[Extensible]] internal property has been set to <b>false</b> it may not be subsequently changed to <b>true</b>.</p>
      <p>NOTE<span>	This specification defines no ECMAScript language operators or built-in functions that permit a program to modify an object’s [[Prototype]] internal properties or to change the value of [[Extensible]] from </span><b>false</b> to <b>true</b>. Implementation specific extensions that modify [[Prototype]] or [[Extensible]] must not violate the invariants defined in the preceding paragraph.</p>
      <p>Unless otherwise specified, the common internal methods of native ECMAScript objects behave as described in 8.12. Array objects have a slightly different implementation of the [[DefineOwnProperty]] internal method (see 15.4.5.1) and String objects have a slightly different implementation of the [[GetOwnProperty]] internal method (see 15.5.5.2). Arguments objects (10.6) have different implementations of [[Get]], [[GetOwnProperty]], [[DefineOwnProperty]], and [[Delete]]. Function objects (15.3) have a different implementation of [[Get]].</p>
      <p>Host objects may implement these internal methods in any manner unless specified otherwise; for example, one possibility is that [[Get]] and [[Put]] for a particular host object indeed fetch and store property values but [[HasProperty]] always generates <b>false</b>. However, if any specified manipulation of a host object's internal properties is not supported by an implementation, that manipulation must throw a <b>TypeError</b> exception when attempted.</p>
      <p>The [[GetOwnProperty]] internal method of a host object must conform to the following invariants for each property of the host object:</p>
      <p>If a property is described as a data property and it may return different values over time, then either or both of the [[Writable]] and [[Configurable]] attributes must be <b>true</b> even if no mechanism to change the value is exposed via the other internal methods.</p>
      <p>If a property is described as a data property and its [[Writable]] and [[Configurable]] are both <b>false</b>, then the SameValue (according to 9.12) must be returned for the [[Value]] attribute of the property on all calls to [[GetOwnProperty]].</p>
      <p>If the attributes other than [[Writable]] may change over time or if the property might disappear, then the [[Configurable]] attribute must be <b>true</b>.</p>
      <p>If the [[Writable]] attribute may change from <b>false</b> to <b>true</b>, then the [[Configurable]] attribute must be <b>true</b>.</p>
      <p>If the value of the host object’s [[Extensible]] internal property has been observed by ECMAScript code to be <b>false</b>, then if a call to [[GetOwnProperty]] describes a property as non-existent all subsequent calls must also describe that property as non-existent.</p>
      <p>The [[DefineOwnProperty]] internal method of a host object must not permit the addition of a new property to a host object if the [[Extensible]] internal property of that host object has been observed by ECMAScript code to be <b>false</b>. </p>
      <p>If the [[Extensible]] internal property of that host object has been observed by ECMAScript code to be <b>false</b> then it must not subsequently become <b>true</b>.</p>
      <p><hr>Table 9 — Internal Properties Only Defined for Some Objects</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Internal Property</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Value Type Domain</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Description</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[NativeBrand]]</p>
            </td>
            <td>
              <p>Members of the NativeBrand enumeration.</p>
            </td>
            <td>
              <p>A tag value used by this specification to categorize various kinds of native ECMAScript objects defined in this specification. Host objects do not have this internal property.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[PrimitiveValue]]</p>
            </td>
            <td>
              <p>
                <i>primitive</i>
              </p>
            </td>
            <td>
              <p>Internal state information associated with this object. Of the standard built-in ECMAScript objects, only Boolean, Date, Number, and String objects implement [[PrimitiveValue]].</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Construct]]</p>
            </td>
            <td>
              <p>SpecOp(a List of <i>any</i>) <span style="font-weight: bold; font-style: italic">→</span> Object</p>
            </td>
            <td>
              <p>Creates an object. Invoked via the <b>new</b> operator. The arguments to the SpecOp are the arguments passed to the <b>new</b> operator. Objects that implement this internal method are called <i>constructors</i>.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Call]]</p>
            </td>
            <td>
              <p>SpecOp(<i>any</i>, a List of <i>any</i>) <span style="font-weight: bold; font-style: italic">→</span> <i>any </i>or Reference</p>
            </td>
            <td>
              <p>Executes code associated with the object. Invoked via a function call expression. The arguments to the SpecOp are this object and a list containing the arguments passed to the function call expression. Objects that implement this internal method are <i>callable</i>. Only callable objects that are host objects may return Reference values.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[HasInstance]]</p>
            </td>
            <td>
              <p>SpecOp(<i>any</i>) <span style="font-weight: bold; font-style: italic">→</span> Boolean</p>
            </td>
            <td>
              <p>Returns a Boolean value indicating whether the argument is likely an Object that was constructed by this object. Of the standard built-in ECMAScript objects, only Function objects implement [[HasInstance]].</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Scope]]</p>
            </td>
            <td>
              <p>Lexical Environment</p>
            </td>
            <td>
              <p>A lexical environment that is the environment in which a Function object is executed. Of the standard built-in ECMAScript objects, only Function objects implement [[Scope]].</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[FormalParameters]]</p>
            </td>
            <td>
              <p>Parse Tree</p>
            </td>
            <td>
              <p>A parse tree for ECMAScript code parsed with FormalParameterList as the goal symbol. Of the standard built-in ECMAScript objects, only Function objects implement [[FormalParameters]].</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Code]]</p>
            </td>
            <td>
              <p>Parse Tree</p>
            </td>
            <td>
              <p>A parse tree for ECMAScript code parsed with FunctionBody as the goal symbol.  Of the standard built-in ECMAScript objects, only Function objects implement [[Code]].</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Strict]]</p>
            </td>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>True if a Function object is a strict mode function. Of the standard built-in ECMAScript objects, only Function objects implement [[Strict]].</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[TargetFunction]]</p>
            </td>
            <td>
              <p>Object</p>
            </td>
            <td>
              <p>The target function of a function object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a [[TargetFunction]] internal property.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[BoundThis]]</p>
            </td>
            <td>
              <p>
                <i>any</i>
              </p>
            </td>
            <td>
              <p>The pre-bound this value of a function Object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a [[BoundThis]] internal property.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[BoundArguments]]</p>
            </td>
            <td>
              <p>List of <i>any</i></p>
            </td>
            <td>
              <p>The pre-bound argument values of a function Object created by the standard built-in Function.prototype.bind method. Only objects created by Function.prototype.bind have a [[BoundArguments]] internal property.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[Match]]</p>
            </td>
            <td>
              <p>SpecOp(<i>String</i>, <i>index</i>) <span style="font-weight: bold; font-style: italic">→</span> <i>MatchResult</i></p>
            </td>
            <td>
              <p>Tests for a regular expression match and returns a MatchResult value (see 15.10.2.1). Of the standard built-in ECMAScript objects, only RegExp objects implement [[Match]].</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[ParameterMap]]</p>
            </td>
            <td>
              <p>Object</p>
            </td>
            <td>
              <p>Provides a mapping between the properties of an arguments object (see 10.6) and the formal parameters of the associated function. Only objects that are arguments objects have a [[ParameterMap]] internal property.</p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>The [[NativeBrand]] internal property is used to identify native ECMASCript objects as objects that conform to specific parts of this specification. The value of a [[NativeBrand]] property is a single member of this set of enumerated values: NativeFunction, NativeArray, StringWrapper, BooleanWrapper, NumberWrapper, NativeMath, NativeDate, NativeRegExp, NativeError, NativeJSON, NativeArguments. The actual value of the [[NativeBrand]] internal property is only used to identify specific kinds of native ECMAScript objects. Host objects do not have this internal property,</p>
      <p>Table 10 — Values of the [[NativeBrand]]  Internal Property</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Internal Property</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Category</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Description</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeFunction</p>
            </td>
            <td>
              <p>Function objects</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeArray</p>
            </td>
            <td>
              <p>Array objects</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>StringWrapper</p>
            </td>
            <td>
              <p>String objects</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>BooleanWrapper</p>
            </td>
            <td>
              <p>Boolean objects</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NumberWrapper</p>
            </td>
            <td>
              <p>Number objects</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeMath</p>
            </td>
            <td>
              <p>The Math object</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeDate</p>
            </td>
            <td>
              <p>Date objects</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeRegExp</p>
            </td>
            <td>
              <p>RegExp objects</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeError</p>
            </td>
            <td>
              <p>Error objects</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeJSON</p>
            </td>
            <td>
              <p>The JSON object</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeArguments</p>
            </td>
            <td>
              <p>Arguments objects</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <h2>8.7<span>	The List </span>and Record Specification Type</h2>
      <p>The List type is used to explain the evaluation of argument lists (see 11.2.4) in <b>new</b> expressions, in function calls, and in other algorithms where a simple list of values is needed. Values of the List type are simply ordered sequences of values. These sequences may be of any length.</p>
      <p>The Record type is used to describe data aggrations within the algorithms of this specifation. A Record type value consists of one or more named fields.  The value of each field is either the ECMAScript type value or a an abstract value represented by a name assocatiated with the Record type. Field names are always enclosed in double brackets.  For example, [[value]]</p>
      <p>For notational convenience within this specification, an object literal-like syntax can be used to express a Record value. For example, {[[field1]]: 42, [[field2]]: <b>false</b>, [[field3]]: <b>empty</b>} defines a Record value that has fields three fields each of why is initialized to a specific value. Field name order is not significant. Any fields that are not explicitly listed are considered to be absent.</p>
      <p>In specification text and algorithms, dot notation may be used to refer to a specific field of a Record value. For example, if D is the record shown in the previous paragraph then D.[[field2]] is shorthand for “the field of D named [[Field2]]”.</p>
      <p>Schema for commonly used Record field combination may be named and that name may be used as a prefix to a literal Record value to identify the specific kind of aggrations that is being described.  For example: Property Descriptor {[[Value]]: 42, [[Writable]]: <b>false</b>, [[Configurable]]: <b>true</b>}</p>
      <h2>8.8<span>	The Completion</span> Record Specification Type</h2>
      <p>The Completion type is a Record used to explain the runtime propagation of values and control flow such as the behaviour of statements (<b>break</b>, <b>continue</b>, <b>return</b> and <b>throw</b>) that perform nonlocal transfers of control.</p>
      <p>Values of the Completion type are Record value whole fileds are defined as by Table xxx.</p>
      <p>Table xxx — Completion Record Fields</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Field Name</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Value</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Meaning</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[type]]</p>
            </td>
            <td>
              <p>One of <b>normal</b>, <b>break</b>, <b>continue</b>, <b>return</b>, or <b>throw</b></p>
            </td>
            <td>
              <p>The type of completion that occurred.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[value]]</p>
            </td>
            <td>
              <p>any ECMAScript language value or <b>empty</b></p>
            </td>
            <td>
              <p>The value that was produced.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>[[target]]</p>
            </td>
            <td>
              <p>any ECMAScript identifier or <b>empty</b></p>
            </td>
            <td>
              <p>The target label for directed control transfers.</p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>The term “abrupt completion” refers to any completion with a [[type]] value other than <b>normal</b>.</p>
      <p>The algorithms of this specification often implicitly return Completion Records whose [[type]] is <b>normal</b>.  Unless it is otherwise obvious from the context, an algorithm statement that returns a value that is not a Completion Record, such as:</p>
      <p>Return the String <b>"Infinity"</b>.</p>
      <p>mean the same things as:</p>
      <p>Return Completion {[[type]]: normal, [[value]]: String <b>"Infinity"</b>, [[target]]:empty}.</p>
      <p>Similarly, any reference to a Completion Record value that is in a context that does not explicitly require a complete Completion Record value is equivalent to an explicit reference to the [[value]] field of the Completion Record value unless the Completion Record is an abrupt completion.</p>
      <p>The abstraction operation NormalValue with a single <i>argument</i> is a short hand that is defined as follows:</p>
      <p>If <i>argument</i> is not a Completion Record, return <i>argument</i>.</p>
      <p>If <i>argument</i> is an abrupt completion, return <i>argument</i>.</p>
      <p>Return<b> </b><i>argument</i>.[[value]]. </p>
      <p>The abstraction operation NormalCompletion with a single <i>argument</i> is a short hand that is defined as follows:</p>
      <p>Return Completion {[[type]]: normal, [[value]]: <i>argument</i>, [[target]]:empty}.</p>
      <p>Algorithms steps that say to throw an exception, such as </p>
      <p>Throw a <b>TypeError</b> exception.</p>
      <p>mean the same things as:</p>
      <p>Return Completion {[[type]]: throw, [[value]]: a newly created <b>TypeError</b> object, [[target]]:empty}.</p>
      <p>Algorithms steps that say ReturnIfAbrupt(<i>argument</i>),  mean the same things as:</p>
      <p>If <i>argument</i> is an abrupt completion, return <i>argument</i>..</p>
      <h2>8.9<span>	The Reference Specification Typ</span>e</h2>
      <p>NOTE	The Reference type is used to explain the behaviour of such operators as <b>delete</b>, <b>typeof</b>, and the assignment operators. For example, the left-hand operand of an assignment is expected to produce a reference. The behaviour of assignment could, instead, be explained entirely in terms of a case analysis on the syntactic form of the left-hand operand of an assignment operator, but for one difficulty: function calls are permitted to return references. This possibility is admitted purely for the sake of host objects. No built-in ECMAScript function defined by this specification returns a reference and there is no provision for a user-defined function to return a reference. (Another reason not to use a syntactic case analysis is that it would be lengthy and awkward, affecting many parts of the specification.)</p>
      <p>A <b>Reference </b>is a resolved name binding. A Reference consists of three components, the <i>base </i>value, the <i>referenced name</i> and the Boolean valued <i>strict reference </i>flag. The <i>base</i> value is either <b>undefined</b>, an Object, a Boolean, a String, a Number, or an environment record (10.2.1). A <i>base</i> value of <b>undefined</b> indicates that the Reference could not be resolved to a binding. The <i>referenced name</i> is a String.</p>
      <p>A Super Reference is a Reference that is used to represents a name binding that was expressed using the <b>super</b> keyword.  A Super Reference has an additional <i>thisValue</i> component and its <i>base</i> value will never be an environment record. </p>
      <p>The following abstract operations are used in this specification to access the components of references:</p>
      <p>GetBase(V). Returns the base value component of the reference V.</p>
      <p>GetReferencedName(V). Returns the referenced name component of the reference V.</p>
      <p>IsStrictReference(V). Returns the strict reference component of the reference V.</p>
      <p>HasPrimitiveBase(V). Returns <b>true</b><b> </b>if the base value is a Boolean, String, or Number.</p>
      <p>IsPropertyReference(V). Returns <b>true</b> if either the base value is an object or HasPrimitiveBase(V) is <b>true</b>; otherwise returns <b>false</b>. </p>
      <p>IsUnresolvableReference(V). Returns <b>true</b> if the base value is <b>undefined</b> and <b>false</b> otherwise.</p>
      <p>IsSuperReference(V).  Returns <b>true</b> if this reference has a <i>thisValue</i> component.</p>
      <p>The following abstract operations are used in this specification to operate on references:</p>
      <h2>8.9.1<span>	GetValu</span>e (V)</h2>
      <p>ReturnIfAbrupt(<i>V</i>).</p>
      <p>Let <i>V</i> be NormalValue(<i>V</i>).</p>
      <p>If Type(<i>V</i>) is not Reference, return <i>V</i>.</p>
      <p>Let <i>base </i>be the result of calling GetBase(<i>V</i>).</p>
      <p>If IsUnresolvableReference(<i>V</i>), throw a <b>ReferenceError</b> exception.</p>
      <p>If IsPropertyReference(<i>V</i>), then</p>
      <p>If HasPrimitiveBase(<i>V</i>) is <b>false</b>, then let <i>get</i> be the [[Get]] internal method of <i>base</i>, otherwise let <i>get</i> be the special [[Get]] internal method defined below.</p>
      <p>Return the result of calling <i>get</i> as an internal method of <i>base </i>passing GetReferencedName(<i>V</i>) for the argument.</p>
      <p>Else, <i>base</i> must be an environment record.</p>
      <p>Return the result of calling the GetBindingValue (see 10.2.1)  concrete method of <i>base</i> passing GetReferencedName(<i>V</i>) and IsStrictReference(<i>V</i>) as arguments.</p>
      <p>The following [[Get]] internal method is used by GetValue when <i>V</i> is a property reference with a primitive base value. <i>base</i> is the value the internal method is called upon with property name <i>P</i> as its argument. The following steps are taken:</p>
      <p>Let <i>O</i> be ToObject(<i>base</i>).</p>
      <p>Let <i>desc </i>be the result of calling the [[GetProperty]] internal method of <i>O </i>with property name <i>P</i>.</p>
      <p>If <i>desc </i>is <b>undefined</b>, return <b>undefined</b>.</p>
      <p>If IsDataDescriptor(<i>desc</i>) is <b>true</b>, return <i>desc</i>.[[Value]].</p>
      <p>Otherwise, IsAccessorDescriptor(<i>desc</i>) must be <b>true</b> so, let <i>getter</i> be <i>desc</i>.[[Get]] (see 8.10).</p>
      <p>If <i>getter </i>is <b>undefined</b>, return <b>undefined</b>.</p>
      <p>Return the result of calling the [[Call]] internal method of <i>getter </i>providing <i>base </i>as the <b>this</b> value and providing no arguments.</p>
      <p>NOTE<span>	The object that may be created in step 1 is not accessible outside of the above method. An implementation might choose to avoid the actual creation of the object. The only situation where such an actual property access that uses this internal method can have visible effect is when it invokes an accessor function.</span></p>
      <h2>8.9.2<span>	PutValu</span>e (V, W)</h2>
      <p>ReturnIfAbrupt(<i>V</i>).</p>
      <p>ReturnIfAbrupt(<i>W</i>).</p>
      <p>Let <i>V</i> be NormalValue(<i>V</i>).</p>
      <p>Let <i>W</i> be NormalValue(<i>W</i>).</p>
      <p>If Type(<i>V</i>) is not Reference, throw a <b>ReferenceError</b> exception.</p>
      <p>Let <i>base</i> be the result of calling GetBase(<i>V</i>).</p>
      <p>If IsUnresolvableReference(<i>V</i>), then</p>
      <p>If IsStrictReference(<i>V</i>) is <b>true</b>, then</p>
      <p>Throw <b>ReferenceError</b> exception.</p>
      <p>Return the result of calling the [[Put]] internal method of the global object, passing GetReferencedName(<i>V</i>) for the property name, <i>W</i> for the value, and <b>false</b> for the <i>Throw</i> flag.</p>
      <p>Else if IsPropertyReference(<i>V</i>), then</p>
      <p>If HasPrimitiveBase(<i>V</i>) is <b>false</b>, then let <i>put</i> be the [[Put]] internal method of <i>base</i>, otherwise let <i>put</i> be the special [[Put]] internal method defined below.</p>
      <p>Return the result of calling <i>put </i>as an<i> </i>internal method of <i>base </i>passing GetReferencedName(<i>V</i>) for the property name, <i>W </i>for the value, and IsStrictReference(<i>V</i>) for the <i>Throw </i>flag.</p>
      <p>Else <i>base </i>must be a reference whose base is an environment record. So,</p>
      <p>Return the result of calling the SetMutableBinding (10.2.1) concrete method of <i>base</i>, passing GetReferencedName(<i>V</i>), <i>W</i>, and IsStrictReference(<i>V</i>) as arguments.</p>
      <p>Return <b>undefined</b>.</p>
      <p>The following [[Put]] internal method is used by PutValue when <i>V</i> is a property reference with a primitive base value. <i>base</i> is the value the internal method is called upon with property name <i>P</i>, value <i>W</i>, and Boolean flag <i>Throw</i> as arguments. The following steps are taken:</p>
      <p>Let <i>O</i> be ToObject(<i>base</i>).</p>
      <p>If the result of calling the [[CanPut]] internal method of <i>O</i> with argument <i>P</i> is <b>false</b>, then</p>
      <p>If <i>Throw</i> is <b>true</b>, then throw a <b>TypeError</b> exception.</p>
      <p>Else return <b>undefined</b>.</p>
      <p>Let <i>ownDesc</i> be the result of calling the [[GetOwnProperty]] internal method of <i>O</i> with argument <i>P</i>.</p>
      <p>If IsDataDescriptor(<i>ownDesc</i>) is <b>true</b>, then</p>
      <p>If <i>Throw</i> is <b>true</b>, then throw a <b>TypeError</b> <b>exception</b>.</p>
      <p>Else return<b> </b><b>undefined</b>.</p>
      <p>Let <i>desc</i> be the result of calling the [[GetProperty]] internal method of <i>O</i> with argument <i>P</i>. This may be either an own or inherited accessor property descriptor or an inherited data property descriptor.</p>
      <p>If IsAccessorDescriptor(<i>desc</i>) is <b>true</b>, then</p>
      <p>Let <i>setter</i> be <i>desc</i>.[[Set]] (see 8.10) which cannot be <b>undefined</b>.</p>
      <p>Return the result of calling the [[Call]] internal method of <i>setter</i> providing <i>base</i> as the <b>this</b> value and an argument list containing only <i>W</i>.</p>
      <p>Else, this is a request to create an own property on the transient object <i>O</i></p>
      <p>If <i>Throw</i> is <b>true</b>, then throw a <b>TypeError</b> exception.</p>
      <p>Return <b>undefined</b>.</p>
      <p>NOTE<span>	The object that may be created in step 1 is not accessible outside of the above method.  An implementation might choose to avoid the actual creation of that transient object. The only situations where such an actual property assignment that uses this internal method can have visible effect are when it either invokes an accessor function or is in violation of a </span><i>Throw</i> predicated error check. When <i>Throw</i> is <b>true</b> any property assignment that would create a new property on the transient object throws an error.</p>
      <h2>8.10 <span>	The Property Descriptor and </span>Property Identifier Specification Types</h2>
      <p>The Property Descriptor type is used to explain the manipulation and reification of named property attributes. Values of the Property Descriptor type are records composed of named fields where each field’s name is an attribute name and its value is a corresponding attribute value as specified in 8.6.1. In addition, any field may be present or absent.</p>
      <p>Property Descriptor values may be further classified as data property descriptors and accessor property descriptors based upon the existence or use of certain fields. A data property descriptor is one that includes any fields named either [[Value]] or [[Writable]]. An accessor property descriptor is one that includes any fields named either [[Get]] or [[Set]]. Any property descriptor may have fields named [[Enumerable]] and [[Configurable]]. A Property Descriptor value may not be both a data property descriptor and an accessor property descriptor; however, it may be neither. A generic property descriptor is a Property Descriptor value that is neither a data property descriptor nor an accessor property descriptor. A fully populated property descriptor is one that is either an accessor property descriptor or a data property descriptor and that has all of the fields that correspond to the property attributes defined in either 8.6.1 Table 5 or Table 6.</p>
      <p>For notational convenience within this specification, an object literal-like syntax can be used to define a property descriptor value. For example, Property Descriptor {[[Value]]: 42, [[Writable]]: <b>false</b>, [[Configurable]]: <b>true</b>} defines a data property descriptor. Field name order is not significant. Any fields that are not explicitly listed are considered to be absent.</p>
      <p>In specification text and algorithms, dot notation may be used to refer to a specific field of a Property Descriptor. For example, if D is a property descriptor then D.[[Value]] is shorthand for “the field of D named [[Value]]”.</p>
      <p>The Property Identifier type is used to associate a property name with a Property Descriptor.  Values of the Property Identifier type are pairs of the form (name, descriptor), where name is a String and descriptor is a Property Descriptor value. </p>
      <p>The following abstract operations are used in this specification to operate upon Property Descriptor values:</p>
      <h2>8.10.1<span>	IsAccessorDescriptor ( Desc )</span></h2>
      <p>When the abstract operation IsAccessorDescriptor is called with property descriptor <i>Desc</i>, the following steps are taken:</p>
      <p>If <i>Desc</i> is <b>undefined</b>, then return <b>false</b>.</p>
      <p>If both <i>Desc</i>.[[Get]] and <i>Desc</i>.[[Set]] are absent, then return <b>false</b>.</p>
      <p>Return <b>true</b>.</p>
      <h2>8.10.2<span>	IsDataDescriptor ( Desc )</span></h2>
      <p>When the abstract operation IsDataDescriptor is called with property descriptor <i>Desc</i>, the following steps are taken:</p>
      <p>If <i>Desc</i> is <b>undefined</b>, then return <b>false</b>.</p>
      <p>If both <i>Desc</i>.[[Value]] and <i>Desc</i>.[[Writable]] are absent, then return <b>false</b>.</p>
      <p>Return <b>true</b>.</p>
      <h2>8.10.3<span>	IsGenericDescriptor ( Desc )</span></h2>
      <p>When the abstract operation IsGenericDescriptor is called with property descriptor <i>Desc</i>, the following steps are taken:</p>
      <p>If <i>Desc</i> is <b>undefined</b>, then return <b>false</b>.</p>
      <p>If IsAccessorDescriptor(<i>Desc</i>) and IsDataDescriptor(<i>Desc</i>) are both <b>false</b>, then return <b>true</b>.</p>
      <p>Return <b>false</b>.</p>
      <h2>8.10.4<span>	FromPropertyDescriptor ( Desc )</span></h2>
      <p>When the abstract operation FromPropertyDescriptor is called with property descriptor <i>Desc</i>, the following steps are taken:</p>
      <p>The following algorithm assumes that <i>Desc </i>is a fully populated Property Descriptor, such as that returned from [[GetOwnProperty]] (see 8.12.1).</p>
      <p>If <i>Desc</i> is <b>undefined</b>, then return <b>undefined</b>.</p>
      <p>Let <i>obj </i>be the result of creating a new object as if by the expression <b>new Object() </b>where<b> Object </b>is the standard built-in constructor with that name.</p>
      <p>If IsDataDescriptor(<i>Desc</i>) is <b>true</b>, then </p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>obj</i> with arguments "<b>value</b>", Property Descriptor {[[Value]]: <i>Desc</i>.[[Value]], [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>. </p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>obj</i> with arguments "<b>writable</b>", Property Descriptor {[[Value]]: <i>Desc</i>.[[Writable]], [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>. </p>
      <p>Else, IsAccessorDescriptor(<i>Desc</i>) must be <b>true</b>, so</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>obj</i> with arguments "<b>get"</b>, Property Descriptor {[[Value]]: <i>Desc</i>.[[Get]], [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>obj</i> with arguments "<b>set</b>", Property Descriptor {[[Value]]: <i>Desc</i>.[[Set]], [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>. </p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>obj</i> with arguments "<b>enumerable</b>", Property Descriptor {[[Value]]: <i>Desc</i>.[[Enumerable]], [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>. </p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>obj</i> with arguments "<b>configurable</b>", Property Descriptor {[[Value]]: <i>Desc</i>.[[Configurable]], [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>. </p>
      <p>Return <i>obj</i>.</p>
      <h2>8.10.5<span>	ToPropertyDescriptor ( Obj )</span></h2>
      <p>When the abstract operation ToPropertyDescriptor is called with object <i>Obj</i>, the following steps are taken:</p>
      <p>ReturnIfAbrupt(<i>Obj</i>).</p>
      <p>If Type(<i>Obj</i>) is not Object throw a <b>TypeError </b>exception.</p>
      <p>Let <i>desc</i> be the result of creating a new Property Descriptor that initially has no fields.</p>
      <p>If the result of calling the [[HasProperty]] internal method of <i>Obj</i> with argument "<b>enumerable</b>" is <b>true</b>, then</p>
      <p>Let <i>enum</i> be the result of calling the [[Get]] internal method of <i>Obj</i> with "<b>enumerable</b>".</p>
      <p>ReturnIfAbrupt(<i>enum</i>).</p>
      <p>Set the [[Enumerable]] field of <i>desc</i> to ToBoolean(<i>enum</i>).</p>
      <p>If the result of calling the [[HasProperty]] internal method of <i>Obj</i> with argument "<b>configurable</b>" is <b>true</b>, then</p>
      <p>Let <i>conf</i>  be the result of calling the [[Get]] internal method of <i>Obj</i> with argument "<b>configurable</b>".</p>
      <p>ReturnIfAbrupt(cong).</p>
      <p>Set the [[Configurable]] field of <i>desc</i> to ToBoolean(<i>conf</i>).</p>
      <p>If the result of calling the [[HasProperty]] internal method of <i>Obj</i> with argument "<b>value</b>" is <b>true</b>, then</p>
      <p>Let <i>value</i> be the result of calling the [[Get]] internal method of <i>Obj</i> with argument “<b>value</b>”.</p>
      <p>ReturnIfAbrupt(<i>value</i>).</p>
      <p>Set the [[Value]] field of <i>desc</i> to <i>value</i>.</p>
      <p>If the result of calling the [[HasProperty]] internal method of <i>Obj</i> with argument "<b>writable</b>" is <b>true</b>, then</p>
      <p>Let <i>writable</i> be the result of calling the [[Get]] internal method of <i>Obj</i> with argument "<b>writable</b>".</p>
      <p>ReturnIfAbrupt(<i>writable</i>).</p>
      <p>Set the [[Writable]] field of <i>desc</i> to ToBoolean(<i>writable</i>).</p>
      <p>If the result of calling the [[HasProperty]] internal method of <i>Obj</i> with argument "<b>get</b>" is <b>true</b>, then</p>
      <p>Let <i>getter</i> be the result of calling the [[Get]] internal method of <i>Obj</i> with argument "<b>get</b>".</p>
      <p>ReturnIfAbrupt(<i>getter</i>).</p>
      <p>If IsCallable(<i>getter</i>) is <b>false </b>and <i>getter</i> is not <b>undefined</b>, then throw a <b>TypeError </b>exception.</p>
      <p>Set the [[Get]] field of <i>desc</i> to <i>getter</i>.</p>
      <p>If the result of calling the [[HasProperty]] internal method of <i>Obj</i> with argument "<b>set</b>" is <b>true</b>, then</p>
      <p>Let <i>setter</i> be the result of calling the [[Get]] internal method of <i>Obj</i> with argument "<b>set</b>".</p>
      <p>ReturnIfAbrupt(<i>setter</i>).</p>
      <p>If IsCallable(<i>setter</i>) is <b>false </b>and <i>setter</i> is not <b>undefined</b>, then throw a <b>TypeError</b> exception.</p>
      <p>Set the [[Set]] field of <i>desc</i> to <i>setter</i>.</p>
      <p>If either <i>desc</i>.[[Get]] or <i>desc</i>.[[Set]] are present, then</p>
      <p>If either <i>desc</i>.[[Value]] or <i>desc</i>.[[Writable]] are present, then throw a <b>TypeError</b> exception.</p>
      <p>Return <i>desc</i>.</p>
      <h2>8.11<span>	The Lexical Environment and Environment Record Specification Types</span></h2>
      <p>The Lexical Environment and Environment Record types are used to explain the behaviour of name resolution in nested functions and blocks. These types and the operations upon them are defined in Clause 10.</p>
      <h2>8.12<span>	Algorithms for Object Internal Methods</span></h2>
      <p>In the following algorithm descriptions, assume <i>O</i> is a native ECMAScript object, <i>P</i> is a String, <i>Desc</i> is a Property Description record, and <i>Throw</i> is a Boolean flag.</p>
      <h2>8.12.1<span>	[[GetOwnProperty]] (P)</span></h2>
      <p>When the [[GetOwnProperty]] internal method of <i>O</i> is called with property name <i>P</i>, the following steps are taken:</p>
      <p>ReturnIfAbrupt(<i>O</i>).</p>
      <p>If <i>O </i>doesn’t have an own property with name <i>P</i>, return <b>undefined</b>.</p>
      <p>Let <i>D </i>be a newly created Property Descriptor with no fields.</p>
      <p>Let <i>X </i>be <i>O</i>’s own property named <i>P</i>.</p>
      <p>If <i>X </i>is a data property, then</p>
      <p>Set <i>D</i>.[[Value]] to the value of <i>X</i>’s [[Value]] attribute.</p>
      <p>Set <i>D</i>.[[Writable]] to the value of <i>X</i>’s [[Writable]] attribute</p>
      <p>Else <i>X </i>is an accessor property, so</p>
      <p>Set <i>D</i>.[[Get]] to the value of <i>X</i>’s [[Get]] attribute.</p>
      <p>Set <i>D</i>.[[Set]] to the value of <i>X</i>’s [[Set]] attribute.</p>
      <p>Set <i>D</i>.[[Enumerable]] to the value of <i>X</i>’s [[Enumerable]] attribute.</p>
      <p>Set <i>D</i>.[[Configurable]] to the value of <i>X</i>’s [[Configurable]] attribute.</p>
      <p>Return <i>D</i>.</p>
      <p>However, if <i>O </i>is a String object it has a more elaborate [[GetOwnProperty]] internal method defined in 15.5.5.2.</p>
      <h2>8.12.2<span>	[[GetProperty]] (P)</span></h2>
      <p>When the [[GetProperty]] internal method of <i>O</i> is called with property name <i>P</i>, the following steps are taken:</p>
      <p>ReturnIfAbrupt(<i>O</i>).</p>
      <p>Let <i>prop </i>be the result of calling the [[GetOwnProperty]] internal method of <i>O </i>with property name <i>P</i>.</p>
      <p>If <i>prop </i>is not <b>undefined</b>, return <i>prop</i>.</p>
      <p>Let <i>proto</i> be the value of the [[Prototype]] internal property of <i>O.</i></p>
      <p>If <i>proto </i>is <b>null</b>, return <b>undefined</b>.</p>
      <p>Return the result of calling the [[GetProperty]] internal method of <i>proto</i> with argument <i>P</i>.</p>
      <h2>8.12.3<span>	[[Get]] (P)</span></h2>
      <p>When the [[Get]] internal method of <i>O</i> is called with property name <i>P</i>, the following steps are taken:</p>
      <p>ReturnIfAbrupt(<i>O</i>).</p>
      <p>Let <i>desc </i>be the result of calling the [[GetProperty]] internal method of <i>O </i>with property name <i>P</i>.</p>
      <p>If <i>desc </i>is <b>undefined</b>, return <b>undefined</b>.</p>
      <p>If IsDataDescriptor(<i>desc</i>) is <b>true</b>, return <i>desc</i>.[[Value]].</p>
      <p>Otherwise, IsAccessorDescriptor(<i>desc</i>) must be true so, let <i>getter</i> be <i>desc</i>.[[Get]].</p>
      <p>If <i>getter </i>is <b>undefined</b>, return <b>undefined</b>.</p>
      <p>Return the result calling the [[Call]] internal method of <i>getter </i>providing <i>O </i>as the <b>this</b> value and providing no arguments.</p>
      <h2>8.12.4<span>	[[CanPut]] (P)</span></h2>
      <p>When the [[CanPut]] internal method of <i>O </i>is called with property name <i>P</i>, the following steps are taken:</p>
      <p>ReturnIfAbrupt(<i>O</i>).</p>
      <p>Let <i>desc</i> be the result of calling the [[GetOwnProperty]] internal method of <i>O</i> with argument <i>P</i>.</p>
      <p>If <i>desc</i> is not <b>undefined</b>, then</p>
      <p>If IsAccessorDescriptor(<i>desc</i>) is <b>true</b>, then</p>
      <p>If <i>desc</i>.[[Set]] is <b>undefined</b>, then return <b>false</b>.</p>
      <p>Else return <b>true</b>.</p>
      <p>Else, <i>desc</i> must be a DataDescriptor so return the value of <i>desc</i>.[[Writable]].</p>
      <p>Let <i>proto</i> be the [[Prototype]] internal property of <i>O</i>.</p>
      <p>If <i>proto</i> is <b>null</b>, then return the value of the [[Extensible]] internal property of <i>O</i>.</p>
      <p>Let <i>inherited</i> be the result of calling the [[GetProperty]] internal method of <i>proto</i> with property name <i>P</i>.</p>
      <p>If <i>inherited</i> is <b>undefined</b>, return the value of the [[Extensible]] internal property of <i>O</i>.</p>
      <p>If IsAccessorDescriptor(<i>inherited</i>) is <b>true</b>, then</p>
      <p>If <i>inherited</i>.[[Set]] is <b>undefined</b>, then return <b>false</b>.</p>
      <p>Else return <b>true</b>.</p>
      <p>Else, <i>inherited</i> must be a DataDescriptor</p>
      <p>If the [[Extensible]] internal property of <i>O</i> is <b>false</b>, return <b>false</b>.</p>
      <p>Else return the value of <i>inherited</i>.[[Writable]].</p>
      <p>Host objects may define additional constraints upon [[Put]] operations. If possible, host objects should not allow [[Put]] operations in situations where this definition of [[CanPut]] returns false.</p>
      <h2>8.12.5<span>	[[Put]] ( P, V, Throw )</span></h2>
      <p>When the [[Put]] internal method of <i>O</i> is called with property <i>P</i>, value <i>V</i>, and Boolean flag <i>Throw</i>, the following steps are taken:</p>
      <p>ReturnIfAbrupt(<i>O</i>).</p>
      <p>If the result of calling the [[CanPut]] internal method of <i>O </i>with argument <i>P </i>is <b>false</b>, then</p>
      <p>If <i>Throw </i>is <b>true</b>, then throw a <b>TypeError </b>exception.</p>
      <p>Else return<b> </b><b>undefined</b>.</p>
      <p>Let <i>ownDesc </i>be the result of calling the [[GetOwnProperty]] internal method of <i>O </i>with argument <i>P</i>.</p>
      <p>If IsDataDescriptor(<i>ownDesc</i>) is <b>true</b>, then</p>
      <p>Let <i>valueDesc</i> be the Property Descriptor {[[Value]]: <i>V</i>}.</p>
      <p>Return the result of calling the [[DefineOwnProperty]] internal method of <i>O</i> passing <i>P</i>, <i>valueDesc</i>, and <i>Throw</i> as arguments.</p>
      <p>Return.</p>
      <p>Let <i>desc </i>be the result of calling the [[GetProperty]] internal method of <i>O </i>with argument <i>P</i>. This may be either an own or inherited accessor property descriptor or an inherited data property descriptor.</p>
      <p>If IsAccessorDescriptor(<i>desc</i>) is <b>true</b>, then</p>
      <p>Let <i>setter </i>be <i>desc</i>.[[Set]] which cannot be <b>undefined</b>.</p>
      <p>Return the result of calling the [[Call]] internal method of <i>setter </i>providing <i>O </i>as the <b>this </b>value and providing <i>V </i>as the sole argument.</p>
      <p>Else, create a named data property named <i>P </i>on object <i>O </i>as follows</p>
      <p>Let <i>newDesc</i> be the Property Descriptor<span><br>{[[Value]]: </span><i>V</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}.</p>
      <p>Return the result of calling the [[DefineOwnProperty]] internal method of <i>O</i> passing <i>P</i>, <i>newDesc</i>, and <i>Throw</i> as arguments.</p>
      <h2>8.12.6<span>	[[HasProperty]] (P)</span></h2>
      <p>When the [[HasProperty]] internal method of <i>O</i> is called with property name <i>P</i>, the following steps are taken:</p>
      <p>ReturnIfAbrupt(<i>O</i>).</p>
      <p>Let <i>desc </i>be the result of calling the [[GetProperty]] internal method of <i>O </i>with property name <i>P</i>.</p>
      <p>If <i>desc</i> is <b>undefined</b>, then return <b>false</b>.</p>
      <p>Else return <b>true</b>.</p>
      <h2>8.12.7<span>	[[Delete]] (P, Throw)</span></h2>
      <p>When the [[Delete]] internal method of <i>O</i> is called with property name <i>P </i>and the Boolean flag <i>Throw</i>, the following steps are taken:</p>
      <p>ReturnIfAbrupt(<i>O</i>).</p>
      <p>Let <i>desc</i> be the result of calling the [[GetOwnProperty]] internal method of <i>O</i> with property name <i>P</i>.</p>
      <p>If <i>desc</i> is <b>undefined</b>, then return <b>true</b>.</p>
      <p>If <i>desc</i>.[[Configurable]] is <b>true</b>, then</p>
      <p>Remove the own property with name <i>P</i> from <i>O</i>.</p>
      <p>Return <b>true</b>.</p>
      <p>Else if <i>Throw</i>, then throw a <b>TypeError</b> exception.</p>
      <p>Return <b>false</b>.</p>
      <h2>8.12.8<span>	[[DefaultValue]] (hint)</span></h2>
      <p>When the [[DefaultValue]] internal method of <i>O</i> is called with hint String, the following steps are taken:</p>
      <p>ReturnIfAbrupt(<i>O</i>).</p>
      <p>Let <i>toString</i> be the result of calling the [[Get]] internal method of object <i>O</i> with argument "<b>toString</b>".</p>
      <p>ReturnIfAbrupt(<i>toString</i>).</p>
      <p>If IsCallable(<i>toString)</i> is <b>true </b>then,</p>
      <p>Let <i>str</i> be the result of calling the [[Call]] internal method of <i>toString</i>, with <i>O</i> as the <b>this</b> value and an empty argument list.</p>
      <p>ReturnIfAbrupt(<i>str</i>).</p>
      <p>If <i>str</i> is a primitive value, return <i>str</i>.</p>
      <p>Let <i>valueOf</i> be the result of calling the [[Get]] internal method of object <i>O</i> with argument "<b>valueOf</b>".</p>
      <p>ReturnIfAbrupt(<i>valueOf</i>).</p>
      <p>If IsCallable(<i>valueOf)</i> is <b>true</b> then, </p>
      <p>Let <i>val</i> be the result of calling the [[Call]] internal method of <i>valueOf</i>, with <i>O</i> as the this value and an empty argument list.</p>
      <p>ReturnIfAbrupt(<i>val</i>).</p>
      <p>If <i>val</i> is a primitive value, return <i>val</i>.</p>
      <p>Throw a <b>TypeError</b> exception.</p>
      <p>When the [[DefaultValue]] internal method of <i>O</i> is called with hint Number, the following steps are taken:</p>
      <p>ReturnIfAbrupt(<i>O</i>).</p>
      <p>Let <i>valueOf</i> be the result of calling the [[Get]] internal method of object <i>O</i> with argument "<b>valueOf</b>".</p>
      <p>ReturnIfAbrupt(<i>valueOf</i>).</p>
      <p>If IsCallable(<i>valueOf)</i> is <b>true</b> then,</p>
      <p>Let <i>val</i> be the result of calling the [[Call]] internal method of <i>valueOf</i>, with <i>O</i> as the <b>this</b> value and an empty argument list.</p>
      <p>ReturnIfAbrupt(<i>val</i>).</p>
      <p>If <i>val</i> is a primitive value, return <i>val</i>.</p>
      <p>Let <i>toString</i> be the result of calling the [[Get]] internal method of object <i>O</i> with argument "<b>toString</b>".</p>
      <p>ReturnIfAbrupt(<i>toString</i>).</p>
      <p>If IsCallable(<i>toString)</i> is <b>true</b> then,</p>
      <p>Let <i>str</i> be the result of calling the [[Call]] internal method of <i>toString</i>, with <i>O</i> as the this value and an empty argument list.</p>
      <p>ReturnIfAbrupt(<i>str</i>).</p>
      <p>If <i>str</i> is a primitive value, return <i>str</i>.</p>
      <p>Throw a <b>TypeError </b>exception.</p>
      <p>When the [[DefaultValue]] internal method of <i>O</i> is called with no hint, then it behaves as if the hint were Number, unless <i>O</i> is a Date object (see 15.9.6), in which case it behaves as if the hint were String.</p>
      <p>The above specification of [[DefaultValue]] for native objects can return only primitive values. If a host object implements its own [[DefaultValue]] internal method, it must ensure that its [[DefaultValue]] internal method can return only primitive values.</p>
      <h2>8.12.9<span>	[[DefineOwnProperty]] (P, Desc, Throw)</span></h2>
      <p>In the following algorithm, the term “Reject” means “If Throw is <b>true</b>, then throw a <b>TypeError</b> exception, otherwise return <b>false</b>”. The algorithm contains steps that test various fields of the Property Descriptor <i>Desc</i> for specific values. The fields that are tested in this manner need not actually exist in <i>Desc</i>.  If a field is absent then its value is considered to be <b>false</b>.</p>
      <p>When the [[DefineOwnProperty]] internal method of <i>O</i> is called with property name <i>P</i>, property descriptor <i>Desc</i>, and Boolean flag <i>Throw</i>, the following steps are taken:</p>
      <p>ReturnIfAbrupt(<i>O</i>).</p>
      <p>Let <i>current</i> be the result of calling the [[GetOwnProperty]] internal method of <i>O</i> with property name <i>P</i>.</p>
      <p>Let <i>extensible</i> be the value of the [[Extensible]] internal property of <i>O</i>.</p>
      <p>If <i>current </i>is <b>undefined</b> and <i>extensible</i> is <b>false</b>, then Reject.</p>
      <p>If <i>current</i> is <b>undefined</b> and <i>extensible</i> is <b>true</b>, then</p>
      <p>If  IsGenericDescriptor(<i>Desc</i>) or IsDataDescriptor(<i>Desc</i>) is <b>true</b>, then</p>
      <p>Create an own data property named <i>P</i> of object <i>O</i> whose [[Value]], [[Writable]], [[Enumerable]] and [[Configurable]] attribute values are described by <i>Desc</i>. If the value of an attribute field of <i>Desc</i> is absent, the attribute of the newly created property is set to its default value.</p>
      <p>Else, <i>Desc</i> must be an accessor Property Descriptor so,</p>
      <p>Create an own accessor property named <i>P</i> of object <i>O</i> whose [[Get]], [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by <i>Desc</i>. If the value of an attribute field of <i>Desc</i> is absent, the attribute of the newly created property is set to its default value.</p>
      <p>Return <b>true</b>.</p>
      <p>Return <b>true</b>, if every field in <i>Desc</i> is absent.</p>
      <p>Return <b>true</b>, if every field in <i>Desc </i>also occurs in <i>current</i> and the value of every field in <i>Desc </i>is the same value as the corresponding field in <i>current </i>when compared using the SameValue algorithm (9.12).</p>
      <p>If the [[Configurable]] field of <i>current</i> is <b>false</b> then</p>
      <p>Reject, if the [[Configurable]] field of <i>Desc</i> is <b>true</b>.</p>
      <p>Reject, if the [[Enumerable]] field of <i>Desc</i> is present and the [[Enumerable]] fields of <i>current</i> and <i>Desc</i> are the Boolean negation of each other.</p>
      <p>If IsGenericDescriptor(<i>Desc</i>) is <b>true</b>, then no further validation is required.</p>
      <p>Else, if IsDataDescriptor(<i>current</i>) and IsDataDescriptor(<i>Desc</i>) have different results, then</p>
      <p>Reject, if the [[Configurable]] field of <i>current</i> is <b>false</b>. </p>
      <p>If IsDataDescriptor(<i>current</i>) is <b>true</b>, then</p>
      <p>Convert the property named <i>P</i> of object <i>O</i> from a data property to an accessor property. Preserve the existing values of the converted property’s [[Configurable]] and [[Enumerable]] attributes and set the rest of the property’s attributes to their default values.</p>
      <p>Else,</p>
      <p>Convert the property named <i>P</i> of object <i>O</i> from an accessor property to a data property. Preserve the existing values of the converted property’s [[Configurable]] and [[Enumerable]] attributes and set the rest of the property’s attributes to their default values.</p>
      <p>Else, if IsDataDescriptor(<i>current</i>) and IsDataDescriptor(<i>Desc</i>) are both <b>true</b>, then</p>
      <p>If the [[Configurable]] field of <i>current</i> is <b>false</b>, then</p>
      <p>Reject, if the [[Writable]] field of <i>current</i> is <b>false</b> and the [[Writable]] field of <i>Desc</i> is <b>true</b>.</p>
      <p>If the [[Writable]] field of <i>current</i> is <b>false</b>, then</p>
      <p>Reject, if the [[Value]] field of <i>Desc</i> is present and SameValue(<i>Desc</i>.[[Value]], <i>current</i>.[[Value]]) is <b>false</b>. </p>
      <p>else, the [[Configurable]] field of <i>current</i> is <b>true</b>, so any change is acceptable.</p>
      <p>Else, IsAccessorDescriptor(<i>current</i>) and IsAccessorDescriptor(<i>Desc</i>) are both <b>true</b> so,</p>
      <p>If the [[Configurable]] field of <i>current</i> is <b>false</b>, then</p>
      <p>Reject, if the [[Set]] field of <i>Desc</i> is present and SameValue(<i>Desc</i>.[[Set]], <i>current</i>.[[Set]]) is <b>false</b>.</p>
      <p>Reject, if the [[Get]] field of <i>Desc</i> is present and SameValue(<i>Desc</i>.[[Get]], <i>current</i>.[[Get]]) is <b>false</b>.</p>
      <p>For each attribute field of <i>Desc</i> that is present, set the correspondingly named attribute of the property named <i>P</i> of object <i>O</i> to the value of the field.</p>
      <p>Return <b>true</b>.</p>
      <p>However, if <i>O</i> has an [[NativeBrand]] internal property whose value is NativeArray <i>O</i> also has a more elaborate [[DefineOwnProperty]] internal method defined in 15.4.5.1.</p>
      <p>NOTE<span>	Step 10.b allows any field of Desc to be different from the corresponding field of current if current’s [[Configurable]] field is </span><b>true</b>. This even permits changing the [[Value]] of a property whose [[Writable]] attribute is <b>false</b>. This is allowed because a <b>true</b> [[Configurable]] attribute would permit an equivalent sequence of calls where [[Writable]] is first set to <b>true</b>, a new [[Value]] is set, and then [[Writable]] is set to <b>false</b>.</p>
      <h2>8.12.10<span>	[[</span>Enumerate]] (includePrototype, onlyEnumerable )</h2>
      <p>When the [[Enumerate]] internal method of <i>O</i> is called with Boolean arguments <i>includePrototype</i> and <i>onlyEnumerable</i>,  the following steps are taken:</p>
      <p>Return an Iterator object (reference xxxx) whose next method iterates over all the keys of enumerable property keys of <i>O</i>. If <i>includePrototype</i> is <b>false</b>, then only own properties of <i>O</i> are included. If <i>onlyEnumerable</i> is <b>false</b>, then all properties that do not have private name keys are included. The mechanics and order of enumerating the properties  is not specified but must conform to the rules specified below.  </p>
      <p>
      </p>
      <p>Enumerated properties do not include properties whose property key is a private name. Properties of the object being enumerated may be deleted during enumeration. If a property that has not yet been visited during enumeration is deleted, then it will not be visited. If new properties are added to the object being enumerated during enumeration, the newly added properties are not guaranteed to be visited in the active enumeration. A property name must not be visited more than once in any enumeration.</p>
      <p>Enumerating the properties of an object includes enumerating properties of its prototype, and the prototype of the prototype, and so on, recursively; but a property of a prototype is not enumerated if it is “shadowed” because some previous object in the prototype chain has a property with the same name. The values of [[Enumerable]] attributes are not considered when determining if a property of a prototype object is shadowed by a previous object on the prototype chain.</p>
      <p>The following is an informative algorithm that conforms to these rules</p>
      <p>Let <i>obj </i>be <i>O</i>.</p>
      <p>Let <i>proto</i> be the value of the [[Prototype]] internal property of <i>O</i>.</p>
      <p>If <i>includePrototype</i> is false or <i>proto</i> is the value <b>null</b>, then</p>
      <p>Let <i>propList</i> be a new empty List.</p>
      <p>Else</p>
      <p>Let <i>propList</i> be the result of calling the [[Enumerate]] internal method of <i>proto</i> with arguments <b>true</b> and<i> </i><i>onlyEnumerable</i>.</p>
      <p>For each string <i>name</i> that is the property key of an own propoperty of <i>O</i></p>
      <p>Let <i>desc</i> be the result of calling the [[GetOwnProperty]] internal method of <i>O</i> with argument <i>name</i>.</p>
      <p>If <i>name</i> is an element of <i>propList</i>, then remove <i>name</i> as an element of <i>propList</i>.</p>
      <p>If <i>onlyEnumerable</i> is <b>false </b>or <i>desc</i>.[[Enumerable]] is <b>true</b>, then add <i>name</i> as an element of <i>propList</i>.</p>
      <p>Order the elements of <i>propList</i> in an implementation defined order. </p>
      <p>Return <i>propList</i>.</p>
      <h2>8.12.11<span>	[[</span>Iterate]] ( )</h2>
      <p>When the [[Iterate]] internal method of <i>O</i> is called  the following steps are taken:</p>
      <p>Let <i>itr</i> be the result of performing Invoke with arguments %iterator%, <i>O</i> and an empty argument List.</p>
      <p>Return <i>itr</i>.</p>
      <h1>9 Abstract Operations </h1>
      <p>These operations are not a part of the ECMAScript language; they are defined here to solely to aid the specification of the semantics of the ECMAScript Language.</p>
      <h2>9.1<span>	Type Conversio</span>n and Testing</h2>
      <p>The ECMAScript language implicitly performs automatic type conversion as needed. To clarify the semantics of certain constructs it is useful to define a set of conversion abstract operations.. The conversion abstract operations are polymorphic; that is, they can accept a value of any ECMAScript language type, but not of specification types.</p>
      <h2>9.1.1	ToPrimitive</h2>
      <p>The abstract operation ToPrimitive takes an input <i>argument</i> and an optional argument <i>PreferredType</i>. The abstract operation ToPrimitive converts its <i>input</i> argument to a non-Object type. If an object is capable of converting to more than one primitive type, it may use the optional hint <i>PreferredType</i> to favour that type. Conversion occurs according to Table 11:</p>
      <p>Table 11 — ToPrimitive Conversions</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Input Type</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Result</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Completion Record</p>
            </td>
            <td>
              <p>If <i>argument</i> is an abrupt completion, return <i>argument</i>. Otherwise return ToPrimitive(<i>argument</i>.[[value]])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Undefined</p>
            </td>
            <td>
              <p>Return <i>argument</i> t (no conversion).</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Null</p>
            </td>
            <td>
              <p>Return <i>argument</i> (no conversion).</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>Return <i>argument</i> (no conversion).</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Number</p>
            </td>
            <td>
              <p>Return <i>argument</i> (no conversion).</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>String</p>
            </td>
            <td>
              <p>Return <i>argument</i> (no conversion).</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Object</p>
            </td>
            <td>
              <p>Perform the following steps:</p>
              <p>Let <i>default</i> be the result of calling the [[DefaultValue]] internal method of <i>argument</i>, passing the optional hint <i>PreferredType</i>.</p>
              <p>Return ToPrimitive(<i>default</i>).</p>
              <p>The behaviour of the [[DefaultValue]] internal method is defined by this specification for all native ECMAScript objects in 8.12.8.</p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <h2>9.1.2<span>	ToBoolea</span>n</h2>
      <p>The abstract operation ToBoolean converts its <i>argument</i> to a value of type Boolean according to Table 12:</p>
      <p>Table 12 — ToBoolean Conversions</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Argument Type</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Result</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Completion Record</p>
            </td>
            <td>
              <p>If <i>argument</i> is an abrupt completion, return the argument. Otherwise return ToBoolean(<i>argument</i>.[[value]])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Undefined</p>
            </td>
            <td>
              <p>Return <b>false</b></p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Null</p>
            </td>
            <td>
              <p>Return <b>false</b></p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>Return the input argument (no conversion).</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Number</p>
            </td>
            <td>
              <p>Return <b>false</b> if the argument is <b>+0</b>, <b>−</b><b>0</b>, or <b>NaN</b>; otherwise return <b>true</b>. </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>String</p>
            </td>
            <td>
              <p>Return <b>false</b> if the argument is the empty String (its length is zero); otherwise return <b>true</b>.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Object</p>
            </td>
            <td>
              <p>Return <b>true</b></p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <h2>9.1.3<span>	ToNumbe</span>r</h2>
      <p>The abstract operation ToNumber converts its <i>argument</i> to a value of type Number according to Table 13:</p>
      <p>Table 13 — To Number Conversions</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Argument Type</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Result</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Completion Record</p>
            </td>
            <td>
              <p>If <i>argument</i> is an abrupt completion, return <i>argument</i>. Otherwise return ToNumber(<i>argument</i>.[[value]])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Undefined</p>
            </td>
            <td>
              <p>Return <b>NaN</b></p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Null</p>
            </td>
            <td>
              <p>Return <b>+0</b></p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>Return <b>1</b> if <i>argument</i> is <b>true</b>. Return <b>+0</b> if <i>argument</i> is <b>false</b>.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Number</p>
            </td>
            <td>
              <p>Return <i>argument</i> (no conversion).</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>String</p>
            </td>
            <td>
              <p>See grammar and note below.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Object</p>
            </td>
            <td>
              <p>Apply the following steps:</p>
              <p>Let <i>primValue</i> be ToPrimitive(<i>argument</i>, hint Number).</p>
              <p>Return ToNumber(<i>primValue</i>).</p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <h2>9.1.3.1<span>	ToNumber Applied to the String Typ</span>e</h2>
      <p>ToNumber applied to Strings applies the following grammar to the input String. If the grammar cannot interpret the String as an expansion of StringNumericLiteral, then the result of ToNumber is <b>NaN</b>.</p>
      <p>Syntax </p>
      <p>StringNumericLiteral <b>:::</b></p>
      <p>StrWhiteSpace<sub>opt</sub><span><br>StrWhiteSpace</span><sub>opt</sub> StrNumericLiteral StrWhiteSpace<sub>opt</sub></p>
      <p>StrWhiteSpace <b>:::</b></p>
      <p>StrWhiteSpaceChar StrWhiteSpace<sub>opt</sub></p>
      <p>StrWhiteSpaceChar <b>:::</b></p>
      <p>WhiteSpace<span><br>LineTerminator</span></p>
      <p>StrNumericLiteral <b>:::</b></p>
      <p>StrDecimalLiteral<span><br>HexIntegerLiteral</span></p>
      <p>StrDecimalLiteral <b>:::</b></p>
      <p>StrUnsignedDecimalLiteral<br><b>+ </b>StrUnsignedDecimalLiteral<br><b>- </b>StrUnsignedDecimalLiteral</p>
      <p>StrUnsignedDecimalLiteral <b>:::</b></p>
      <p><b>Infinity</b><span><br> DecimalDigits </span><b>.</b> DecimalDigits<sub>opt</sub><sub> </sub>ExponentPart<sub>opt</sub><br><b>.</b> DecimalDigits ExponentPart<sub>opt</sub><span><br>DecimalDigits ExponentPart</span><sub>opt</sub></p>
      <p>DecimalDigits <b>:::</b></p>
      <p>DecimalDigit<span><br>DecimalDigits DecimalDigit</span></p>
      <p>DecimalDigit <b>:::</b><b> </b><b>one of</b></p>
      <p>
        <b>0  1  2  3  4  5  6  7  8  9</b>
      </p>
      <p>ExponentPart <b>:::</b></p>
      <p>ExponentIndicator SignedInteger</p>
      <p>ExponentIndicator <b>:::</b><b> </b><b>one of</b></p>
      <p>
        <b>e  E</b>
      </p>
      <p>SignedInteger <b>:::</b></p>
      <p>DecimalDigits<br><b>+ </b>DecimalDigits<br><b>- </b>DecimalDigits</p>
      <p>HexIntegerLiteral <b>:::</b></p>
      <p><b>0x</b> HexDigit<br><b>0X</b> HexDigit<span><br>HexIntegerLiteral HexDigit</span></p>
      <p>HexDigit ::: <b>one of</b></p>
      <p>
        <b>0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  A  B  C  D  E  F</b>
      </p>
      <p>Some differences should be noted between the syntax of a StringNumericLiteral and a NumericLiteral (see 7.8.3):</p>
      <p>A StringNumericLiteral may be preceded and/or followed by white space and/or line terminators.</p>
      <p>A StringNumericLiteral that is decimal may have any number of leading <b>0</b> digits.</p>
      <p>A StringNumericLiteral that is decimal may be preceded by <b>+</b> or <b>-</b> to indicate its sign.</p>
      <p>A StringNumericLiteral that is empty or contains only white space is converted to <b>+0</b>.</p>
      <p>The conversion of a String to a Number value is similar overall to the determination of the Number value for a numeric literal (see 7.8.3), but some of the details are different, so the process for converting a String numeric literal to a value of Number type is given here in full. This value is determined in two steps: first, a mathematical value (MV) is derived from the String numeric literal; second, this mathematical value is rounded as described below.</p>
      <p>The MV of StringNumericLiteral <b>:::</b> [empty] is 0.</p>
      <p>The MV of StringNumericLiteral <b>:::</b> StrWhiteSpace is 0.</p>
      <p>The MV of StringNumericLiteral <b>:::</b> StrWhiteSpace<sub>opt</sub> StrNumericLiteral StrWhiteSpace<sub>opt</sub> is the MV of StrNumericLiteral, no matter whether white space is present or not.</p>
      <p>The MV of StrNumericLiteral <b>:::</b> StrDecimalLiteral is the MV of StrDecimalLiteral.</p>
      <p>The MV of StrNumericLiteral <b>:::</b> HexIntegerLiteral is the MV of HexIntegerLiteral.</p>
      <p>The MV of StrDecimalLiteral <b>:::</b> StrUnsignedDecimalLiteral is the MV of StrUnsignedDecimalLiteral.</p>
      <p>The MV of StrDecimalLiteral <b>:::</b> <b>+</b> StrUnsignedDecimalLiteral is the MV of StrUnsignedDecimalLiteral.</p>
      <p>The MV of StrDecimalLiteral <b>:::</b> <b>-</b> StrUnsignedDecimalLiteral is the negative of the MV of StrUnsignedDecimalLiteral. (Note that if the MV of <i>StrUnsignedDecimalLiteral</i> is 0, the negative of this MV is also 0. The rounding rule described below handles the conversion of this signless mathematical zero to a floating-point <b>+0</b> or <b>−</b><b>0</b> as appropriate.)</p>
      <p>The MV of StrUnsignedDecimalLiteral<b>::: </b><b>Infinity</b><b> </b>is 10<sup>10000</sup> (a value so large that it will round to <b>+</b><b>∞</b>).</p>
      <p>The MV of StrUnsignedDecimalLiteral<b>::: </b>DecimalDigits<b>.</b><b> </b>is the MV of DecimalDigits.</p>
      <p>The MV of StrUnsignedDecimalLiteral<b>::: </b>DecimalDigits <b>.</b><i> </i>DecimalDigits<b> </b>is the MV of the first <i>DecimalDigits</i> plus (the MV of the second DecimalDigits<b> </b>times 10<sup>−</sup><span style="vertical-align: super; font-style: italic">n</span>), where <i>n</i> is the number of characters in the second DecimalDigits.</p>
      <p>The MV of <i>StrUnsignedDecimalLiteral</i><b>::: </b><i>DecimalDigits</i><b>.</b><i> ExponentPart </i>is the MV of <i>DecimalDigits</i> times 10<span style="vertical-align: super; font-style: italic">e</span>, where <i>e</i> is the MV of <i>ExponentPart</i>.</p>
      <p>The MV of <i>StrUnsignedDecimalLiteral</i><b>::: </b><i>DecimalDigits</i><b>.</b><i> DecimalDigits ExponentPart </i>is (the MV of the first <i>DecimalDigits</i> plus (the MV of the second <i>DecimalDigits</i><span style="font-weight: bold; font-style: italic"> </span>times 10<sup>−</sup><span style="vertical-align: super; font-style: italic">n</span>)) times 10<span style="vertical-align: super; font-style: italic">e</span>, where <i>n</i> is the number of characters in the second <i>DecimalDigit</i>s and <i>e</i> is the MV of <i>ExponentPart</i>.</p>
      <p>The MV of <i>StrUnsignedDecimalLiteral</i><b>:::</b><b>.</b><i> DecimalDigits</i> is the MV of <i>DecimalDigits</i><span style="font-weight: bold; font-style: italic"> </span>times 10<sup>−</sup><span style="vertical-align: super; font-style: italic">n</span>, where <i>n</i> is the number of characters in <i>DecimalDigit</i>s.</p>
      <p>The MV of <i>StrUnsignedDecimalLiteral</i><b>:::</b><b>.</b><i> DecimalDigits ExponentPart </i>is the MV of <i>DecimalDigits</i><span style="font-weight: bold; font-style: italic"> </span>times 10<span style="vertical-align: super; font-style: italic">e</span><sup>−</sup><span style="vertical-align: super; font-style: italic">n</span>, where <i>n</i> is the number of characters in <i>DecimalDigit</i>s and <i>e</i> is the MV of <i>ExponentPart</i>.</p>
      <p>The MV of <i>StrUnsignedDecimalLiteral</i><b>::: </b><i>DecimalDigits</i> is the MV of <i>DecimalDigits</i>.</p>
      <p>The MV of <i>StrUnsignedDecimalLiteral</i><b>::: </b><i>DecimalDigits</i> <i>ExponentPart </i>is the MV of <i>DecimalDigits</i> times 10<span style="vertical-align: super; font-style: italic">e</span>, where <i>e</i> is the MV of <i>ExponentPart</i>.</p>
      <p>The MV of <i>DecimalDigits</i> <b>:::</b> <i>DecimalDigit</i> is the MV of <i>DecimalDigit</i>.</p>
      <p>The MV of <i>DecimalDigits</i> <b>:::</b> <i>DecimalDigits</i> <i>DecimalDigit</i> is (the MV of <i>DecimalDigits</i> times 10) plus the MV of <i>DecimalDigit</i>.</p>
      <p>The MV of <i>ExponentPart </i><b>::: </b><i>ExponentIndicator SignedInteger</i><span style="font-weight: bold; font-style: italic"> </span>is the MV of <i>SignedInteger</i>.</p>
      <p>The MV of <i>SignedInteger </i><b>::: </b><i>DecimalDigits</i><span style="font-weight: bold; font-style: italic"> </span>is the MV of <i>DecimalDigits</i>.</p>
      <p>The MV of <i>SignedInteger </i><b>::: </b><b>+</b><i> DecimalDigits</i><span style="font-weight: bold; font-style: italic"> </span>is the MV of <i>DecimalDigits</i>.</p>
      <p>The MV of <i>SignedInteger </i><b>::: </b><b>-</b><i> DecimalDigits</i><span style="font-weight: bold; font-style: italic"> </span>is the negative of the MV of <i>DecimalDigits</i>.</p>
      <p>The MV of <i>DecimalDigit</i> <b>:::</b> <b>0</b> or of <i>HexDigit</i> <b>:::</b> <b>0</b> is 0.</p>
      <p>The MV of <i>DecimalDigit</i> <b>:::</b> <b>1</b> or of <i>HexDigit</i> <b>:::</b> <b>1</b> is 1.</p>
      <p>The MV of <i>DecimalDigit</i> <b>:::</b> <b>2</b> or of <i>HexDigit</i> <b>:::</b> <b>2</b> is 2.</p>
      <p>The MV of <i>DecimalDigit</i> <b>:::</b> <b>3</b> or of <i>HexDigit</i> <b>:::</b> <b>3</b> is 3.</p>
      <p>The MV of <i>DecimalDigit</i> <b>:::</b> <b>4</b> or of <i>HexDigit</i> <b>:::</b> <b>4</b> is 4.</p>
      <p>The MV of <i>DecimalDigit</i> <b>:::</b> <b>5</b> or of <i>HexDigit</i> <b>:::</b> <b>5</b> is 5.</p>
      <p>The MV of <i>DecimalDigit</i> <b>:::</b> <b>6</b> or of <i>HexDigit</i> <b>:::</b> <b>6</b> is 6.</p>
      <p>The MV of <i>DecimalDigit</i> <b>:::</b> <b>7</b> or of <i>HexDigit</i> <b>:::</b> <b>7</b> is 7.</p>
      <p>The MV of <i>DecimalDigit</i> <b>:::</b> <b>8</b> or of <i>HexDigit</i> <b>:::</b> <b>8</b> is 8.</p>
      <p>The MV of <i>DecimalDigit</i> <b>:::</b> <b>9</b> or of <i>HexDigit</i> <b>:::</b> <b>9</b> is 9.</p>
      <p>The MV of <i>HexDigit</i> <b>:::</b> <b>a</b> or of <i>HexDigit</i> <b>:::</b> <b>A</b> is 10.</p>
      <p>The MV of <i>HexDigit</i> <b>:::</b> <b>b</b> or of <i>HexDigit</i> <b>:::</b> <b>B</b> is 11.</p>
      <p>The MV of <i>HexDigit</i> <b>:::</b> <b>c</b> or of <i>HexDigit</i> <b>:::</b> <b>C</b> is 12.</p>
      <p>The MV of <i>HexDigit</i> <b>:::</b> <b>d</b> or of <i>HexDigit</i> <b>:::</b> <b>D</b> is 13.</p>
      <p>The MV of <i>HexDigit</i> <b>:::</b> <b>e</b> or of <i>HexDigit</i> <b>:::</b> <b>E</b> is 14.</p>
      <p>The MV of <i>HexDigit</i> <b>:::</b> <b>f</b> or of <i>HexDigit</i> <b>:::</b> <b>F</b> is 15.</p>
      <p>The MV of <i>HexIntegerLiteral </i><b>:::</b> <b>0x</b> <i>HexDigit</i> is the MV of <i>HexDigit</i>.</p>
      <p>The MV of <i>HexIntegerLiteral </i><b>:::</b> <b>0X</b> <i>HexDigit</i> is the MV of <i>HexDigit</i>.</p>
      <p>The MV of <i>HexIntegerLiteral </i><b>:::</b> <i>HexIntegerLiteral</i> <i>HexDigit</i> is (the MV of <i>HexIntegerLiteral</i> times 16) plus the MV of <i>HexDigit</i>.</p>
      <p>Once the exact MV for a String numeric literal has been determined, it is then rounded to a value of the Number type. If the MV is 0, then the rounded value is +0 unless the first non white space character in the String numeric literal is ‘<b>-</b>’, in which case the rounded value is −0. Otherwise, the rounded value must be the Number value for the MV (in the sense defined in 8.5), unless the literal includes a StrUnsignedDecimalLiteral and the literal has more than 20 significant digits, in which case the Number value may be either the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a 0 digit or the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a 0 digit and then incrementing the literal at the 20th digit position. A digit is <i>significant</i> if it is not part of an ExponentPart and</p>
      <p>it is not <b>0</b>; or</p>
      <p>there is a nonzero digit to its left and there is a nonzero digit, not in the ExponentPart, to its right.</p>
      <h2>9.1.4<span>	ToIntege</span>r</h2>
      <p>The abstract operation ToInteger converts its argument to an integral numeric value. This abstract operation functions as follows:</p>
      <p>Let <i>number</i> be the result of calling ToNumber on the input argument.</p>
      <p>ReturnIfAbrupt(<i>number</i>).</p>
      <p>If <i>number</i> is <b>NaN</b>, return <b>+0</b>.</p>
      <p>If <i>number</i> is <b>+0</b>, <b>−</b><b>0</b>, <b>+</b><b>∞</b><b>,</b> or <b>−</b><b>∞</b>, return <i>number</i>.</p>
      <p>Return the result of computing sign(<i>number</i>) × floor(abs(<i>number</i>)).</p>
      <h2>9.1.5<span>	ToInt32: (Signed 32 Bit Integer</span>)</h2>
      <p>The abstract operation ToInt32 converts its argument to one of 2<sup>32</sup> integer values in the range −2<sup>31</sup> through 2<sup>31</sup>−1, inclusive. This abstract operation functions as follows:</p>
      <p>Let <i>number</i> be the result of calling ToNumber on the input argument.</p>
      <p>ReturnIfAbrupt(<i>number</i>).</p>
      <p>If <i>number</i> is <b>NaN</b>, <b>+0</b>, <b>−</b><b>0</b>, <b>+</b><b>∞</b>, or <b>−</b><b>∞</b>, return <b>+0</b>.</p>
      <p>Let <i>posInt</i> be sign(<i>number</i>) * floor(abs(<i>number</i>)).</p>
      <p>Let <i>int32bit</i> be <i>posInt</i> modulo 2<sup>32</sup>; that is, a finite integer value k of Number type with positive sign and less than 2<sup>32</sup> in magnitude such that the mathematical difference of <i>posInt</i> and k is mathematically an integer multiple of 2<sup>32</sup>.</p>
      <p>If <i>int32bit</i> is greater than or equal to 2<sup>31</sup>, return <i>int32bit</i> − 2<sup>32</sup>, otherwise return <i>int32bit</i>.</p>
      <p>NOTE<span>	Given the above definition of ToInt32:</span></p>
      <p>The ToInt32 abstract operation is idempotent: if applied to a result that it produced, the second application leaves that value unchanged.</p>
      <p>ToInt32(ToUint32(x)) is equal to ToInt32(<i>x</i>) for all values of x. (It is to preserve this latter property that +<b>∞</b> and −<b>∞</b> are mapped to <b>+0</b>.)</p>
      <p>ToInt32 maps <b>−</b><b>0</b> to <b>+0</b>.</p>
      <h2>9.1.6<span>	ToUint32: (Unsigned 32 Bit Integer</span>)</h2>
      <p>The abstract operation ToUint32 converts its argument to one of 2<sup>32</sup> integer values in the range 0 through 2<sup>32</sup>−1, inclusive. This abstraction operation functions as follows:</p>
      <p>Let <i>number</i> be the result of calling ToNumber on the input argument.</p>
      <p>ReturnIfAbrupt(<i>number</i>).</p>
      <p>If <i>number</i> is <b>NaN</b>, +0, −0, +<b>∞</b>, or −<b>∞</b>, return <b>+0</b>.</p>
      <p>Let <i>posInt</i> be sign(<i>number</i>) × floor(abs(<i>number</i>)).</p>
      <p>Let <i>int32bit</i> be <i>posInt</i> modulo 2<sup>32</sup>; that is, a finite integer value k of Number type with positive sign and less than 2<sup>32</sup> in magnitude such that the mathematical difference of <i>posInt</i> and k is mathematically an integer multiple of 2<sup>32</sup>.</p>
      <p>Return <i>int32bit</i>.</p>
      <p>NOTE<span>	Given the above definition of ToUInt32:</span></p>
      <p>Step 5 is the only difference between ToUint32 and ToInt32.</p>
      <p>The ToUint32 abstract operation is idempotent: if applied to a result that it produced, the second application leaves that value unchanged.</p>
      <p>ToUint32(ToInt32(<i>x</i>)) is equal to ToUint32(<i>x</i>) for all values of <i>x</i>. (It is to preserve this latter property that <b>+</b><b>∞</b> and <b>−</b><b>∞</b> are mapped to <b>+0</b>.)</p>
      <p>ToUint32 maps <b>−</b><b>0</b> to <b>+0</b>.</p>
      <h2>9.1.7<span>	ToUint16: (Unsigned 16 Bit Integer</span>)</h2>
      <p>The abstract operation ToUint16 converts its argument to one of 2<sup>16</sup> integer values in the range 0 through 2<sup>16</sup>−1, inclusive. This abstract operation functions as follows:</p>
      <p>Let <i>number</i> be the result of calling ToNumber on the input argument.</p>
      <p>ReturnIfAbrupt(<i>number</i>).</p>
      <p>If <i>number</i> is <b>NaN</b>, +0, −0, +<b>∞</b>, or −<b>∞</b>, return <b>+0</b>.</p>
      <p>Let <i>posInt</i> be sign(<i>number</i>) × floor(abs(<i>number</i>)).</p>
      <p>Let <i>int16bit</i> be <i>posInt</i> modulo 2<sup>16</sup>; that is, a finite integer value <i>k</i> of Number type with positive sign and less than 2<sup>16</sup> in magnitude such that the mathematical difference of <i>posInt</i> and <i>k</i> is mathematically an integer multiple of 2<sup>16</sup>.</p>
      <p>Return <i>int16bit</i>.</p>
      <p>NOTE<span>	Given the above definition of ToUint16:</span></p>
      <p>The substitution of 2<sup>16</sup> for 2<sup>32</sup> in step 4 is the only difference between ToUint32 and ToUint16.</p>
      <p>ToUint16 maps <b>−</b><b>0</b> to <b>+0</b>.</p>
      <h2>9.1.8<span>	ToStrin</span>g</h2>
      <p>The abstract operation ToString converts its <i>argument</i> to a value of type String according to Table 14:</p>
      <p>Table 14 — ToString Conversions</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Argument Type</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Result</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Completion Record</p>
            </td>
            <td>
              <p>If <i>argument</i> is an abrupt completion, return <i>argument</i>. Otherwise return ToString(<i>argument</i>.[[value]])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Undefined</p>
            </td>
            <td>
              <p>
                <b>"undefined"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Null</p>
            </td>
            <td>
              <p>
                <b>"null"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>If <i>argument</i> is <b>true</b>, then return <b>"true"</b>.</p>
              <p>If <i>argument</i> is <b>false</b>, then return <b>"false"</b><b>.</b></p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Number</p>
            </td>
            <td>
              <p>See 9.8.1.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>String</p>
            </td>
            <td>
              <p>Return <i>argument</i> (no conversion)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Object</p>
            </td>
            <td>
              <p>Apply the following steps:</p>
              <p>1. Let <i>primValue</i> be ToPrimitive(<i>argument</i>, hint String).</p>
              <p>2. Return ToString(<i>primValue</i>).</p>
            </td>
          </tr>
        </table>
      </figure>
      <h2>9.1.8.1<span>	ToString Applied to the Number Typ</span>e</h2>
      <p>The abstract operation ToString converts a Number <i>m</i> to String format as follows:</p>
      <p>If <i>m</i> is <b>NaN</b>, return the String <b>"NaN"</b>.</p>
      <p>If <i>m</i> is <b>+0</b> or <b>−</b><b>0</b>, return the String <b>"0"</b>.</p>
      <p>If <i>m</i> is less than zero, return the String concatenation of the String <b>"-"</b> and ToString(−<i>m</i>).</p>
      <p>If <i>m</i> is infinity, return the String <b>"Infinity"</b>.</p>
      <p>Otherwise, let <i>n</i>, <i>k</i>, and <i>s</i> be integers such that <i>k</i> ≥ 1, 10<span style="vertical-align: super; font-style: italic">k</span><sup>−</sup><sup>1</sup> ≤ <i>s</i> &lt; 10<span style="vertical-align: super; font-style: italic">k</span>, the Number value for <i>s</i> × 10<span style="vertical-align: super; font-style: italic">n</span><span style="vertical-align: super; font-style: italic">−</span><span style="vertical-align: super; font-style: italic">k</span> is <i>m</i>, and <i>k</i> is as small as possible. Note that <i>k</i> is the number of digits in the decimal representation of <i>s</i>, that <i>s</i> is not divisible by 10, and that the least significant digit of <i>s</i> is not necessarily uniquely determined by these criteria.</p>
      <p>If <i>k</i> ≤ <i>n</i> ≤ 21, return the String consisting of the <i>k</i> digits of the decimal representation of s (in order, with no leading zeroes), followed by <i>n</i><i>−</i><i>k</i> occurrences of the character ‘<b>0</b>’.</p>
      <p>If 0 &lt; n ≤ 21, return the String consisting of the most significant <i>n</i> digits of the decimal representation of <i>s</i>, followed by a decimal point ‘<b>.</b>’, followed by the remaining <i>k</i><i>−</i><i>n</i> digits of the decimal representation of <i>s</i>.</p>
      <p>If −6 &lt; n ≤ 0, return the String consisting of the character ‘<b>0</b>’, followed by a decimal point ‘<b>.</b>’, followed by −<i>n</i> occurrences of the character ‘<b>0</b>’, followed by the <i>k</i> digits of the decimal representation of <i>s</i>.</p>
      <p>Otherwise, if <i>k</i> = 1, return the String consisting of the single digit of <i>s</i>, followed by lowercase character ‘<b>e</b>’, followed by a plus sign ‘<b>+</b>’ or minus sign ‘<b>−</b>’ according to whether <i>n</i>−1 is positive or negative, followed by the decimal representation of the integer abs(<i>n</i>−1) (with no leading zeroes).</p>
      <p>Return the String consisting of the most significant digit of the decimal representation of <i>s</i>, followed by a decimal point ‘.’, followed by the remaining <i>k</i>−1 digits of the decimal representation of <i>s</i>, followed by the lowercase character ‘<b>e</b>’, followed by a plus sign ‘<b>+</b>’ or minus sign ‘<b>−</b>’ according to whether <i>n</i>−1 is positive or negative, followed by the decimal representation of the integer abs(<i>n</i>−1) (with no leading zeroes).</p>
      <p>NOTE 1<span>	The following observations may be useful as guidelines for implementations, but are not part of the normative requirements of this Standard:</span></p>
      <p>If x is any Number value other than <b>−</b><b>0</b>, then ToNumber(ToString(x)) is exactly the same Number value as x.</p>
      <p>The least significant digit of s is not always uniquely determined by the requirements listed in step 5.</p>
      <p>NOTE 2<span>	For implementations that provide more accurate conversions than required by the rules above, it is recommended that the following alternative version of step 5 be used as a guideline:</span></p>
      <p>Otherwise, let <i>n</i>, <i>k</i>, and <i>s</i> be integers such that <i>k</i> ≥ 1, 10<span style="vertical-align: super; font-style: italic">k</span><sup>−</sup><sup>1</sup> ≤ <i>s</i> &lt; 10<span style="vertical-align: super; font-style: italic">k</span>, the Number value for <i>s</i> × 10<span style="vertical-align: super; font-style: italic">n</span><sup>−</sup><span style="vertical-align: super; font-style: italic">k</span> is <i>m</i>, and <i>k</i> is as small as possible. If there are multiple possibilities for <i>s</i>, choose the value of <i>s</i> for which <i>s</i> × 10<span style="vertical-align: super; font-style: italic">n</span><sup>−</sup><span style="vertical-align: super; font-style: italic">k</span> is closest in value to <i>m</i>. If there are two such possible values of <i>s</i>, choose the one that is even. Note that <i>k</i> is the number of digits in the decimal representation of <i>s</i> and that <i>s</i> is not divisible by 10.</p>
      <p>NOTE 3<span>	Implementers of ECMAScript may find useful the paper and code written by David M. Gay for binary-to-decimal conversion of floating-point numbers:</span></p>
      <p>Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis, Manuscript 90-10. AT&amp;T Bell Laboratories (Murray Hill, New Jersey). November 30, 1990. Available as<br>http://cm.bell-labs.com/cm/cs/doc/90/4-10.ps.gz. Associated code available as<br>http://cm.bell-labs.com/netlib/fp/dtoa.c.gz and as<br>http://cm.bell-labs.com/netlib/fp/g_fmt.c.gz and may also be found at the various <b>netlib</b> mirror sites.</p>
      <h2>9.1.9<span>	ToObjec</span>t</h2>
      <p>The abstract operation ToObject converts its <i>argument</i> to a value of type Object according to Table 15:</p>
      <p>Table 15 — ToObject</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Argument Type</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Result</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Completion Record</p>
            </td>
            <td>
              <p>If <i>argument</i> is an abrupt completion, return <i>argument</i>. Otherwise return ToObject(<i>argument</i>.[[value]])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Undefined</p>
            </td>
            <td>
              <p>Throw a <b>TypeError</b> exception.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Null</p>
            </td>
            <td>
              <p>Throw a <b>TypeError</b> exception.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>Return a new Boolean object whose [[PrimitiveValue]] internal property is set to the value of <i>argument</i>. See 15.6 for a description of Boolean objects.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Number</p>
            </td>
            <td>
              <p>Return a new Number object whose [[PrimitiveValue]] internal property is set to the value of <i>argument</i>. See 15.7 for a description of Number objects.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>String</p>
            </td>
            <td>
              <p>Return a new String object whose [[PrimitiveValue]] internal property is set to the value of <i>argument</i>. See 15.5 for a description of String objects.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Object</p>
            </td>
            <td>
              <p>Return <i>argument</i> (no conversion).</p>
            </td>
          </tr>
        </table>
      </figure>
      <h2>9.2<span>	Testing and Comparision Operations</span></h2>
      <h2>9.2.1<span>	CheckObjectCoercible</span></h2>
      <p>The abstract operation CheckObjectCoercible throws an error if its argument is a value that cannot be converted to an Object using ToObject. It is defined by Table 16:</p>
      <p>Table 16 — CheckObjectCoercible Results</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Argument Type</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Result</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Completion Record</p>
            </td>
            <td>
              <p>If <i>argument</i> is an abrupt completion, return <i>argument</i>. Otherwise return CheckObjectCoercible(<i>argument</i>.[[value]])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Undefined</p>
            </td>
            <td>
              <p>Throw a <b>TypeError</b> exception.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Null</p>
            </td>
            <td>
              <p>Throw a <b>TypeError</b> exception.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>Return <i>argument</i></p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Number</p>
            </td>
            <td>
              <p>Return<i> argument</i></p>
            </td>
          </tr>
          <tr>
            <td>
              <p>String</p>
            </td>
            <td>
              <p>Return<i> argument</i></p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Object</p>
            </td>
            <td>
              <p>Return<i> argument</i></p>
            </td>
          </tr>
        </table>
      </figure>
      <h2>9.2.2<span>	IsCallable</span></h2>
      <p>The abstract operation IsCallable determines if its <i>argument</i>, which must be an ECMAScript language value, is a callable function Object according to Table 17:</p>
      <p>Table 17 — IsCallable Results</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Argument Type</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Result</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Completion Record</p>
            </td>
            <td>
              <p>If <i>argument</i> is an abrupt completion, return <i>argument</i>. Otherwise return IsCallable(<i>argument</i>.[[value]])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Undefined</p>
            </td>
            <td>
              <p>Return <b>false</b>.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Null</p>
            </td>
            <td>
              <p>Return <b>false</b>.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>Return <b>false</b>.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Number</p>
            </td>
            <td>
              <p>Return <b>false</b>.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>String</p>
            </td>
            <td>
              <p>Return <b>false</b>.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Object</p>
            </td>
            <td>
              <p>If <i>argument</i> has a [[Call]] internal method, then return <b>true</b>, otherwise return <b>false</b>.</p>
            </td>
          </tr>
        </table>
      </figure>
      <h2>9.2.3<span>	The SameValue Algorithm</span></h2>
      <p>The internal comparison abstract operation SameValue(<i>x</i>, <i>y</i>), where <i>x</i> and <i>y</i> are ECMAScript language values, produces <b>true</b> or <b>false</b>. Such a comparison is performed as follows:</p>
      <p>ReturnIfAbrupt(<i>x</i>).</p>
      <p>ReturnIfAbrupt(<i>y</i>).</p>
      <p>If <i>x</i> is an Completion Record, let <i>x</i> be <i>x</i>.[[value]]. </p>
      <p>If <i>y</i> is an Completion Record, let <i>y</i> be <i>y</i>.[[value]]. </p>
      <p>If Type(<i>x</i>) is different from Type(<i>y</i>), return <b>false</b>.</p>
      <p>If Type(<i>x</i>) is Undefined, return <b>true</b>.</p>
      <p>If Type(<i>x</i>) is Null, return <b>true</b>.</p>
      <p>If Type(<i>x</i>) is Number, then.</p>
      <p>If <i>x</i> is NaN and <i>y</i> is NaN, return <b>true</b>.</p>
      <p>If <i>x</i> is +0 and <i>y</i> is -0, return <b>false</b>.</p>
      <p>If <i>x</i> is -0 and <i>y</i> is +0, return <b>false</b>.</p>
      <p>If <i>x</i> is the same Number value as <i>y</i>, return <b>true</b>.</p>
      <p>Return <b>false</b>.</p>
      <p>If Type(<i>x</i>) is String, then return <b>true </b>if <i>x</i> and <i>y</i> are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return <b>false</b>.</p>
      <p>If Type(<i>x</i>) is Boolean, return <b>true </b>if <i>x</i> and <i>y</i> are both <b>true</b> or both <b>false</b>; otherwise, return <b>false</b>.</p>
      <p>Return true if <i>x</i> and <i>y</i> are the same Object value. Otherwise, return <b>false</b>.</p>
      <h2>9.3<span>	Property Access Operations</span></h2>
      <h2>9.3.1<span>	Invoke</span></h2>
      <p>The Invoke abstraction abstract operation is used to call a method property of an object.  The operation is called with arguments  <i>P</i>, <i>O</i>, and <i>args</i> where <i>P</i> is the property key, <i>O</i> serves as both the lookup point for the property and the this value of the call, and <i>args</i> is the list of arguments values passed to the method. This abstract operation perform, the following steps:</p>
      <p>Let <i>obj</i><i> </i>be ToObject(<i>O</i>).</p>
      <p>ReturnIfAbrupt(<i>obj</i>).</p>
      <p>Let <i>func</i> be the result of calling the [[Get]] internal method of <i>obj</i><i> </i>passing <i>P</i> as the argument.</p>
      <p>ReturnIfAbrupt(<i>func</i>).</p>
      <p>If IsCallable(<i>func</i>) is <b>false</b>, throw a <b>TypeError </b>exception.</p>
      <p>Return the result of calling the [[Call]] internal method of <i>func</i> passing <i>O </i>as the <b>this </b>value and argument list <i>args</i>.</p>
      <p>
      </p>
      <h1>10<span>	Executable Code and Execution Context</span>s</h1>
      <h2>10.1<span>	Types of Executable Code</span></h2>
      <p>There are three types of ECMAScript executable code:</p>
      <p><i>Global code</i> is source text that is treated as an ECMAScript <i>Program</i>. The global code of a particular <i>Program</i> does not include any source text that is parsed as part of a <i>FunctionBody</i>.</p>
      <p><i>Eval code</i> is the source text supplied to the built-in <b>eval</b> function. More precisely, if the parameter to the built-in <b>eval</b> function is a String, it is treated as an ECMAScript <i>Program</i>. The eval code for a particular invocation of <b>eval</b> is the global code portion of that <i>Program</i>.</p>
      <p><i>Function code</i> is source text that is parsed as part of a <i>FunctionBody</i>. The <i>function code</i> of a particular <i>FunctionBody</i> does not include any source text that is parsed as part of a nested <i>FunctionBody</i>. <i>Function code</i> also denotes the source text supplied when using the built-in <b>Function</b> object as a constructor. More precisely, the last parameter provided to the <b>Function</b> constructor is converted to a String and treated as the <i>FunctionBody</i>. If more than one parameter is provided to the <b>Function</b> constructor, all parameters except the last one are converted to Strings and concatenated together, separated by commas. The resulting String is interpreted as the <i>FormalParameterList</i> for the <i>FunctionBody</i> defined by the last parameter. The function code for a particular instantiation of a <b>Function</b> does not include any source text that is parsed as part of a nested <i>FunctionBody</i>.</p>
      <h2>10.1.1<span>	Strict Mode Code</span></h2>
      <p>An ECMAScript <i>Program</i> syntactic unit may be processed using either unrestricted or strict mode syntax and semantics. When processed using strict mode the three types of ECMAScript code are referred to as strict global code, strict eval code, and strict function code. Code is interpreted as strict mode code in the following situations:</p>
      <p>Global code is strict global code if it begins with a Directive Prologue that contains a Use Strict Directive (see 14.1).</p>
      <p>Eval code is strict eval code if it begins with a Directive Prologue that contains a Use Strict Directive or if the call to eval is a direct call (see 15.1.2.1.1) to the eval function that is contained in strict mode code. </p>
      <p>Function code that is part of a <i>FunctionDeclaration</i>, <i>FunctionExpression</i>, or accessor <i>PropertyAssignment</i> is strict function code if its <i>FunctionDeclaration</i>, <i>FunctionExpression</i>, or <i>PropertyAssignment</i> is contained in strict mode code or if the function code begins with a Directive Prologue that contains a Use Strict Directive.</p>
      <p>Function code that is supplied as the last argument to the built-in Function constructor is strict function code if the last argument is a String that when processed as a <i>FunctionBody</i> begins with a Directive Prologue that contains a Use Strict Directive.</p>
      <p>Unless specified otherwise, extended code (10.1.2) is also strict mode code.</p>
      <p>The term “base code” is used to designate code that is not strict code.</p>
      <h2>10.2<span>	Lexical Environments</span></h2>
      <p>A <i>Lexical Environment</i> is a specification type used to define the association of <i>Identifiers</i> to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an Environment Record and a possibly null reference to an <i>outer</i> Lexical Environment. Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a <i>FunctionDeclaration</i>, a <i>WithStatement</i>, or a <i>Catch </i>clause of a <i>TryStatement</i> and a new Lexical Environment is created each time such code is evaluated.</p>
      <p>An <i>Environment Record</i> records the identifier bindings that are created within the scope of its associated Lexical Environment.</p>
      <p>The outer environment reference is used to model the logical nesting of Lexical Environment values. The outer reference of a (inner) Lexical Environment is a reference to the Lexical Environment that logically surrounds the inner Lexical Environment. An outer Lexical Environment may, of course, have its own outer Lexical Environment.  A Lexical Environment may serve as the outer environment for multiple inner Lexical Environments. For example, if a <i>FunctionDeclaration</i> contains two nested <i>FunctionDeclarations</i> then the Lexical Environments of each of the nested functions will have as their outer Lexical Environment the Lexical Environment of the current execution of the surrounding function.</p>
      <p>Lexical Environments and Environment Record values are purely specification mechanisms and need not correspond to any specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to directly access or manipulate such values.</p>
      <h2>10.2.1<span>	Environment Records</span></h2>
      <p>There are two kinds of Environment Record values used in this specification: <i>declarative environment records</i> and <i>object environment records</i>.  Declarative environment records are used to define the effect of ECMAScript language syntactic elements such as <i>FunctionDeclarations</i>, <i>VariableDeclarations</i>, and <i>Catch</i> clauses that directly associate identifier bindings with ECMAScript language values. Object environment records are used to define the effect of ECMAScript elements such as <i>Program</i> and <i>WithStatement</i> that associate identifier bindings with the properties of some object.</p>
      <p>For specification purposes Environment Record values can be thought of as existing in a simple object-oriented hierarchy where Environment Record is an abstract class with two concrete subclasses, declarative environment record and object environment record. The abstract class includes the abstract specification methods defined in Table 18. These abstract methods have distinct concrete algorithms for each of the concrete subclasses. </p>
      <p>Table 18 — Abstract Methods of Environment Records</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Method</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Purpose</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>HasBinding(N)</p>
            </td>
            <td>
              <p>Determine if an environment record has a binding for an identifier. Return <b>true</b> if it does and <b>false</b> if it does not. The String value <i>N</i> is the text of the identifier.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>CreateMutableBinding(N, D)</p>
            </td>
            <td>
              <p>Create a new mutable binding in an environment record. The String value <i>N</i> is the text of the bound name. If the optional Boolean argument <i>D</i> is <b>true</b> the binding is may be subsequently deleted.  </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>SetMutableBinding(N,V, S)</p>
            </td>
            <td>
              <p>Set the value of an already existing mutable binding in an environment record. The String value <i>N</i> is the text of the bound name. <i>V</i> is the value for the binding and may be a value of any ECMAScript language type. <i>S</i> is a Boolean flag.  If <i>S</i> is <b>true</b> and the binding cannot be set throw a <b>TypeError</b> exception. <i>S</i> is used to identify strict mode references.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>GetBindingValue(N,S)</p>
            </td>
            <td>
              <p>Returns the value of an already existing binding from an environment record. The String value <i>N</i> is the text of the bound name. <i>S</i> is used to identify strict mode references. If <i>S</i> is <b>true</b> and the binding does not exist or is uninitialised throw a <b>ReferenceError</b> exception. </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>DeleteBinding(N)</p>
            </td>
            <td>
              <p>Delete a binding from an environment record. The String value <i>N</i> is the text of the bound name If a binding for <i>N</i> exists, remove the binding and return <b>true</b>. If the binding exists but cannot be removed return <b>false</b>. If the binding does not exist return <b>true</b>.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>ImplicitThisValue()</p>
            </td>
            <td>
              <p>Returns the value to use as the <b>this</b> value on calls to function objects that are obtained as binding values from this environment record. </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <h2>10.2.1.1<span>	Declarative Environment </span>Records</h2>
      <p>Each declarative environment record is associated with an ECMAScript program scope containing variable, constant, and/or function declarations. A declarative environment record binds the set of identifiers defined by the declarations contained within its scope.</p>
      <p>In addition to the mutable bindings supported by all Environment Records, declarative environment records also provide for immutable bindings.  An immutable binding is one where the association between an identifier and a value may not be modified once it has been established. Creation and initialisation of declarative binding are distinct steps so it is possible for such bindings to exist in either an initialised or uninitialised state. Declarative environment records support the methods listed in Table 19 in addition to the Environment Record abstract specification methods:</p>
      <p>Table 19 — Additional Methods of Declarative Environment Records</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Method</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Purpose</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>CreateImmutableBinding(N)</p>
            </td>
            <td>
              <p>Create a new but uninitialised immutable binding in an environment record. The String value <i>N</i> is the text of the bound name.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>InitializeBinding(N,V)</p>
            </td>
            <td>
              <p>Set the value of an already existing but uninitialised binding in an environment record. The String value <i>N</i> is the text of the bound name. <i>V</i> is the value for the binding and is a value of any ECMAScript language type. </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>The behaviour of the concrete specification methods for Declarative Environment Records is defined by the following algorithms.</p>
      <p>10.2.1.1.1<span>	HasBinding(N)</span></p>
      <p>The concrete environment record method HasBinding for declarative environment records simply determines if the argument identifier is one of the identifiers bound by the record:</p>
      <p>Let <i>envRec </i>be the declarative environment record for which the method was invoked.</p>
      <p>If <i>envRec</i> has a binding for the name that is the value of <i>N</i>, return <b>true</b>.</p>
      <p>If it does not have such a binding, return <b>false</b>.</p>
      <p>10.2.1.1.2<span>	CreateMutableBinding (N, D)</span></p>
      <p>The concrete Environment Record method CreateMutableBinding for declarative environment records creates a new mutable binding for the name <i>N</i> that is initialised to the value <b>undefined</b>.  A binding must not already exist in this Environment Record for <i>N</i>. If Boolean argument <i>D</i> is provided and has the value <b>true</b> the new binding is marked as being subject to deletion.</p>
      <p>Let <i>envRec </i>be the declarative environment record for which the method was invoked.</p>
      <p>Assert: <i>envRec</i> does not already have a binding for <i>N</i>.</p>
      <p>Create a mutable binding in <i>envRec</i> for <i>N</i> and and record that it is uninitialised. If <i>D</i> is true record that the newly created binding may be deleted by a subsequent DeleteBinding call.</p>
      <p>10.2.1.1.3<span>	SetMutableBinding (N,V,S)</span></p>
      <p>The concrete Environment Record method SetMutableBinding for declarative environment records attempts to change the bound value of the current binding of the identifier whose name is the value of the argument <i>N</i> to the value of argument <i>V</i>. A binding for <i>N</i> must already exist. If the binding is an immutable binding, a <b>TypeError</b> is thrown if S is <b>true</b>. </p>
      <p>Let <i>envRec</i> be the declarative environment record for which the method was invoked.</p>
      <p>Assert: <i>envRec</i> must have a binding for <i>N</i>.</p>
      <p>Assert: The binding for <i>N</i> in <i>envRec</i> has already been initialised.</p>
      <p>If the binding for <i>N</i> in <i>envRec</i> is a mutable binding, change its bound value to <i>V</i>.</p>
      <p>Else if  binding for <i>N</i> in <i>envRec</i> has not yet been initialized throw a ReferenceError exception.</p>
      <p>Else this must be an attempt to change the value of an immutable binding so if <i>S</i> is <b>true</b> throw a <b>TypeError</b> exception.</p>
      <p>10.2.1.1.4<span>	GetBindingValue(N,S)</span></p>
      <p>The concrete Environment Record method GetBindingValue for declarative environment records simply returns the value of its bound identifier whose name is the value of the argument <i>N</i>. The binding must already exist. If <i>S</i> is <b>true</b> and the binding is an uninitialised immutable binding throw a <b>ReferenceError</b> exception.</p>
      <p>Let <i>envRec</i> be the declarative environment record for which the method was invoked.</p>
      <p>Assert: <i>envRec</i> has a binding for <i>N</i>.</p>
      <p>If the binding for <i>N</i> in <i>envRec</i> is an uninitialised binding, then</p>
      <p>If <i>S</i> is <b>false</b>, return the value <b>undefined</b>, otherwise throw a <b>ReferenceError</b> exception.</p>
      <p>Else, return the value currently bound to <i>N</i> in <i>envRec</i>.</p>
      <p>10.2.1.1.5<span>	DeleteBinding (N)</span></p>
      <p>The concrete Environment Record method DeleteBinding for declarative environment records can only delete bindings that have been explicitly designated as being subject to deletion.</p>
      <p>Let <i>envRec</i> be the declarative environment record for which the method was invoked.</p>
      <p>If <i>envRec</i> does not have a binding for the name that is the value of <i>N</i>, return <b>true</b>.</p>
      <p>If the binding for <i>N</i> in <i>envRec</i> is cannot be deleted, return <b>false</b>.</p>
      <p>Remove the binding for <i>N</i> from <i>envRec</i>.</p>
      <p>Return <b>true</b>.</p>
      <p>10.2.1.1.6<span>	ImplicitThisValue()</span></p>
      <p>Declarative Environment Records always return <b>undefined</b> as their ImplicitThisValue.</p>
      <p>Return <b>undefined</b>.</p>
      <p>10.2.1.1.7<span>	CreateImmutableBinding </span>(N)</p>
      <p>The concrete Environment Record method CreateImmutableBinding for declarative environment records creates a new immutable binding for the name <i>N</i> that is initialised to the value <b>undefined</b>.  A binding must not already exist in this environment record for <i>N</i>.</p>
      <p>Let <i>envRec </i>be the declarative environment record for which the method was invoked.</p>
      <p>Assert: <i>envRec </i>does not already have a binding for <i>N</i>.</p>
      <p>Create an immutable binding in <i>envRec</i> for <i>N</i> and record that it is uninitialised.</p>
      <p>10.2.1.1.8<span>	InitializeBinding (N,V)</span></p>
      <p>The concrete Environment Record method InitializeBinding for declarative environment records is used to set the bound value of the current binding of the identifier whose name is the value of the argument <i>N</i> to the value of argument <i>V</i>. An uninitialised binding for <i>N</i> must already exist. </p>
      <p>Let <i>envRec </i>be the declarative environment record for which the method was invoked.</p>
      <p>Assert: <i>envRec</i> must have an uninitialised binding for N.</p>
      <p>Set the bound value for <i>N</i> in <i>envRec</i> to <i>V</i>.</p>
      <p>Record that the binding for <i>N</i> in <i>envRec</i> has been initialised.</p>
      <h2>10.2.1.2<span>	Object Environment Records</span></h2>
      <p>Each object environment record is associated with an object called its <i>binding object</i>. An object environment record binds the set of identifier names that directly correspond to the property names of its binding object. Property names that are not an <i>IdentifierName </i>are not included in the set of bound identifiers. Both own and inherited properties are included in the set regardless of the setting of their [[Enumerable]] attribute. Because properties can be dynamically added and deleted from objects, the set of identifiers bound by an object environment record may potentially change as a side-effect of any operation that adds or deletes properties. Any bindings that are created as a result of such a side-effect are considered to be a mutable binding even if the Writable attribute of the corresponding property has the value <b>false</b>. Immutable bindings do not exist for object environment records.</p>
      <p>Object environment records can be configured to provide their binding object as an implicit this value for use in function calls. This capability is used to specify the behaviour of With Statement (12.10) induced bindings. The capability is controlled by a <i>provideThis</i> Boolean value that is associated with each object environment record.  By default, the value of <i>provideThis</i> is <b>false</b> for any object environment record.</p>
      <p>The behaviour of the concrete specification methods for Object Environment Records is defined by the following algorithms.</p>
      <p>10.2.1.2.1<span>	HasBinding(N)</span></p>
      <p>The concrete Environment Record method HasBinding for object environment records determines if its associated binding object has a property whose name is the value of the argument <i>N</i>:</p>
      <p>Let <i>envRec </i>be the object environment record for which the method was invoked.</p>
      <p>Let <i>bindings </i>be the binding object for <i>envRec</i>.</p>
      <p>Return the result of calling the [[HasProperty]] internal method of <i>bindings</i>, passing <i>N</i> as the property name.</p>
      <p>10.2.1.2.2<span>	CreateMutableBinding (N, D)</span></p>
      <p>The concrete Environment Record method CreateMutableBinding for object environment records creates in an environment record’s associated binding object a property whose name is the String value and initialises it to the value <b>undefined</b>. A property named <i>N</i> must not already exist in the binding object. If Boolean argument <i>D</i> is provided and has the value <b>true</b> the new property’s [[Configurable]] attribute is set to <b>true</b>, otherwise it is set to <b>false</b>.</p>
      <p>Let <i>envRec</i> be the object environment record for which the method was invoked.</p>
      <p>Let <i>bindings</i> be the binding object for <i>envRec</i>.</p>
      <p>Assert: The result of calling the [[HasProperty]] internal method of <i>bindings</i>, passing <i>N</i> as the property name, is <b>false</b>.</p>
      <p>If  D is <b>true</b> then let <i>configValue</i> be <b>true</b> otherwise let <i>configValue</i> be <b>false</b>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>bindings</i>, passing <i>N</i>, Property Descriptor {[[Value]]:<b>undefined</b>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b> , [[Configurable]]: <i>configValue</i>}, and <b>true</b> as arguments.</p>
      <p>10.2.1.2.3<span>	SetMutableBinding (N,V,S)</span></p>
      <p>The concrete Environment Record method SetMutableBinding for object environment records attempts to set the value of the environment record’s associated binding object’s property whose name is the value of the argument <i>N</i> to the value of argument <i>V</i>. A property named <i>N</i> should already exist but if it does not or is not currently writable, error handling is determined by the value of the Boolean argument <i>S</i>.</p>
      <p>Let <i>envRec</i> be the object environment record for which the method was invoked.</p>
      <p>Let <i>bindings</i> be the binding object for <i>envRec</i>.</p>
      <p>Call the [[Put]] internal method of <i>bindings</i> with arguments <i>N</i>, <i>V</i>, and <i>S</i>.</p>
      <p>10.2.1.2.4<span>	GetBindingValue(N,S)</span></p>
      <p>The concrete Environment Record method GetBindingValue for object environment records returns the value of its associated binding object’s property whose name is the String value of the argument identifier <i>N</i>. The property should already exist but if it does not the result depends upon the value of the <i>S</i> argument:</p>
      <p>Let <i>envRec</i> be the object environment record for which the method was invoked.</p>
      <p>Let <i>bindings</i> be the binding object for <i>envRec</i>.</p>
      <p>Let <i>value</i> be the result of calling the [[HasProperty]] internal method of <i>bindings</i>, passing <i>N</i> as the property name.</p>
      <p>If <i>value</i> is <b>false</b>, then</p>
      <p>If <i>S</i> is <b>false</b>, return the value <b>undefined</b>, otherwise throw a <b>ReferenceError </b>exception.</p>
      <p>Return the result of calling the [[Get]] internal method of <i>bindings</i>, passing <i>N</i> for the argument.</p>
      <p>10.2.1.2.5<span>	DeleteBinding (N)</span></p>
      <p>The concrete Environment Record method DeleteBinding for object environment records can only delete bindings that correspond to properties of the environment object whose [[Configurable]] attribute have the value <b>true</b>.</p>
      <p>Let <i>envRec</i> be the object environment record for which the method was invoked.</p>
      <p>Let <i>bindings </i>be the binding object for <i>envRec</i>.</p>
      <p>Return the result of calling the [[Delete]] internal method of <i>bindings</i>, passing <i>N</i> and <b>false</b> as arguments.</p>
      <p>10.2.1.2.6<span>	ImplicitThisValue()</span></p>
      <p>Object Environment Records return <b>undefined</b> as their ImplicitThisValue unless their <i>provideThis</i> flag is <b>true</b>.</p>
      <p>Let <i>envRec</i> be the object environment record for which the method was invoked.</p>
      <p>If the <i>provideThis</i> flag of <i>envRec</i> is <b>true</b>, return the binding object for <i>envRec</i>.</p>
      <p>Otherwise, return <b>undefined</b>.</p>
      <h2>10.2.2<span>	Lexical Environment Operations</span></h2>
      <p>The following abstract operations are used in this specification to operate upon lexical environments:</p>
      <h2>10.2.2.1<span>	GetIdentifierReference (lex, name, strict)</span></h2>
      <p>The abstract operation GetIdentifierReference is called with a Lexical Environment <i>lex</i>, a String <i>name</i>, and a Boolean flag <i>strict. </i>The value of <i>lex </i>may be <b>null</b>. When called, the following steps are performed:</p>
      <p>If <i>lex</i> is the value <b>null</b>, then</p>
      <p>Return a value of type Reference whose base value is <b>undefined</b>, whose referenced name is <i>name</i>, and whose strict mode flag is <i>strict</i>.</p>
      <p>Let <i>envRec</i> be <i>lex</i>’s environment record.</p>
      <p>Let <i>exists </i>be the result of calling the HasBinding(<i>N</i>) concrete method of <i>envRec</i> passing <i>name</i> as the argument <i>N</i>.</p>
      <p>If <i>exists </i>is <b>true</b>, then</p>
      <p>Return a value of type Reference whose base value is <i>envRec</i>, whose referenced name is <i>name</i>, and whose strict mode flag is <i>strict.</i></p>
      <p>Else</p>
      <p>Let <i>outer </i>be the value of <i>lex’s</i> outer environment reference.</p>
      <p>Return the result of calling GetIdentifierReference passing <i>outer</i>, <i>name</i>, and <i>strict</i> as arguments.</p>
      <h2>10.2.2.2<span>	NewDeclarativeEnvironment</span> (E)</h2>
      <p>When the abstract operation NewDeclarativeEnvironment is called with either a Lexical Environment or <b>null</b> as argument <i>E </i>the following steps are performed:</p>
      <p>Let <i>env</i> be a new Lexical Environment.</p>
      <p>Let <i>envRec</i> be a new declarative environment record containing no bindings.</p>
      <p>Set <i>env’s</i> environment record to be <i>envRec</i>.</p>
      <p>Set the outer lexical environment reference of <i>env</i> to <i>E</i>.</p>
      <p>Return <i>env</i>.</p>
      <h2>10.2.2.3<span>	NewObjectEnvironment</span> (O, E)</h2>
      <p>When the abstract operation NewObjectEnvironment is called with an Object <i>O</i> and a Lexical Environment <i>E </i>(or <b>null)</b> as arguments, the following steps are performed:</p>
      <p>Let <i>env</i> be a new Lexical Environment.</p>
      <p>Let <i>envRec</i> be a new object environment record containing <i>O</i> as the binding object.</p>
      <p>Set <i>env’s</i> environment record to be <i>envRec</i>.</p>
      <p>Set the outer lexical environment reference of <i>env</i> to <i>E</i>.</p>
      <p>Return <i>env</i>.</p>
      <h2>10.2.3<span>	The Global Environment</span></h2>
      <p>The <i>global environment</i> is a unique Lexical Environment which is created before any ECMAScript code is executed. The global environment’s Environment Record is an object environment record whose binding object is the global object (15.1). The global environment’s outer environment reference is <b>null</b>.</p>
      <p>As ECMAScript code is executed, additional properties may be added to the global object and the initial properties may be modified. </p>
      <h2>10.3	Execution Contexts</h2>
      <p>When control is transferred to ECMAScript executable code, control is entering an <i>execution context</i>. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context. A new execution context is created whenever control is transferred from the executable code associated with the currently running execution context to executable code that is not associated with that execution context. The newly created execution context is pushed onto the stack and becomes the running execution context.</p>
      <p>An execution context contains whatever state is necessary to track the execution progress of its associated code. In addition, each execution context has the state components listed in Table 20.</p>
      <p>Table 20 —Execution Context State Components</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Component</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Purpose</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>LexicalEnvironment</p>
            </td>
            <td>
              <p>Identifies the Lexical Environment used to resolve identifier references made by code within this execution context.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>VariableEnvironment</p>
            </td>
            <td>
              <p>Identifies the Lexical Environment whose environment record holds bindings created by VariableStatements and FunctionDeclarations within this execution context.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>ThisBinding</p>
            </td>
            <td>
              <p>The value associated with the <b>this</b> keyword within ECMAScript code associated with this execution context.</p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>The LexicalEnvironment and VariableEnvironment components of an execution context are always Lexical Environments. When an execution context is created its LexicalEnvironment and VariableEnvironment components initially have the same value.  The value of the VariableEnvironment component never changes while the value of the LexicalEnvironment component may change during execution of code within an execution context.</p>
      <p>In most situations only the running execution context (the top of the execution context stack) is directly manipulated by algorithms within this specification.  Hence when the terms “LexicalEnvironment”, “VariableEnvironment” and “ThisBinding” are used without qualification they are in reference to those components of the running execution context.</p>
      <p>An execution context is purely a specification mechanism and need not correspond to any particular artefact of an ECMAScript implementation.  It is impossible for an ECMAScript program to access an execution context. </p>
      <h2>10.3.1<span>	Identifier Resolution</span></h2>
      <p>Identifier resolution is the process of determining the binding of an IdentifierName using the LexicalEnvironment of the running execution context. During execution of ECMAScript code, Identifier Resolution is performed using the following algorithm:</p>
      <p>Let <i>env</i> be the running execution context’s LexicalEnvironment.</p>
      <p>If the syntactic production that is being evaluated is contained in a strict mode code, then let <i>strict</i> be <b>true</b>, else let <i>strict</i> be <b>false</b>.</p>
      <p>Return the result of calling GetIdentifierReference abstract operation passing <i>env</i>, the String value containing the same sequence of characters as <i>IdentifierName</i>, and <i>strict</i> as arguments.</p>
      <p>The result of evaluating an identifier is always a value of type Reference with its referenced name component equal to the Identifier String.</p>
      <h2>10.4<span>	Establishing an Execution Context</span></h2>
      <p>Evaluation of global code or code using the eval function (15.1.2.1) establishes and enters a new execution context. Every invocation of an ECMAScript code function (13.2.1) also establishes and enters a new execution context, even if a function is calling itself recursively. Every return exits an execution context. A thrown exception may also exit one or more execution contexts.</p>
      <p>When control enters an execution context, the execution context’s ThisBinding is set, its VariableEnvironment and initial LexicalEnvironment are defined, and declaration binding instantiation (10.5) is performed. The exact manner in which these actions occur depend on the type of code being entered.</p>
      <h2>10.4.1<span>	Entering Global Code</span></h2>
      <p>The following steps are performed when control enters the execution context for global code:</p>
      <p>Initialise the execution context using the global code as described in 10.4.1.1.</p>
      <p>Perform Declaration Binding Instantiation as described in 10.5 using the global code.</p>
      <h2>10.4.1.1<span>	Initial Global Execution Context</span></h2>
      <p>The following steps are performed to initialise a global execution context for ECMAScript code <i>C</i>:</p>
      <p>Set the VariableEnvironment to the Global Environment.</p>
      <p>Set the LexicalEnvironment to the Global Environment.</p>
      <p>Set the ThisBinding to the global object.</p>
      <h2>10.4.2<span>	Entering Eval Code</span></h2>
      <p>The following steps are performed when control enters the execution context for eval code:</p>
      <p>If there is no calling context or if the eval code is not being evaluated by a direct call (15.1.2.1.1) to the eval function then,</p>
      <p>Initialise the execution context as if it was a global execution context using the eval code as <i>C</i> as described in 10.4.1.1.</p>
      <p>Else,</p>
      <p>Set the ThisBinding to the same value as the ThisBinding of the calling execution context.</p>
      <p>Set the LexicalEnvironment to the same value as the LexicalEnvironment of the calling execution context.</p>
      <p>Set the VariableEnvironment to the same value as the VariableEnvironment of the calling execution context.</p>
      <p>If the eval code is strict code, then</p>
      <p>Let <i>strictVarEnv</i> be the result of calling NewDeclarativeEnvironment  passing the LexicalEnvironment as the argument.</p>
      <p>Set the LexicalEnvironment to <i>strictVarEnv</i>.</p>
      <p>Set the VariableEnvironment to <i>strictVarEnv</i>.</p>
      <p>Perform Declaration Binding Instantiation as described in 10.5 using the eval code.</p>
      <p>NOTE	The eval code cannot instantiate variable or function bindings in the variable environment of the calling context that invoked the eval if either the code of the calling context or the eval code is strict code. Instead such bindings are instantiated in a new VariableEnvironment that is only accessible to the eval code.</p>
      <h2>10.4.3<span>	Entering Function Code</span></h2>
      <p>The following steps are performed when control enters the execution context for function code contained in function object <i>F</i>, a caller provided <i>argumentsList</i>, and a caller provided <i>thisArg</i>:</p>
      <p>Let <i>strict</i> be the value of <i>F</i>’s [[Strict]] internal property.</p>
      <p>If <i>strict</i> is <b>true</b>, set the ThisBinding to <i>thisArg</i>.</p>
      <p>Else if <i>thisArg</i> is <b>null</b> or <b>undefined</b>, set the ThisBinding to the global object.</p>
      <p>Else if Type(<i>thisArg</i>) is not Object, set the ThisBinding to ToObject(<i>thisArg</i>).</p>
      <p>Else set the ThisBinding to <i>thisArg</i>.</p>
      <p>Let <i>localEnv</i> be the result of calling NewDeclarativeEnvironment  passing the value of the [[Scope]] internal property of <i>F</i> as the argument.</p>
      <p>Set the LexicalEnvironment to <i>localEnv</i>.</p>
      <p>Set the VariableEnvironment to <i>localEnv</i>.</p>
      <p>Return the result of performing Function Declaration Binding Instantiation using the function <i>F</i>,<i> </i><i>argumentsList</i> , and <i>localEnv </i>as described in 10.5.3. </p>
      <h2>10.5<span>	Declaration Binding Instantiation</span></h2>
      <h2>10.5.1	Top-Level Declaration Instantiation</h2>
      <p>NOTE<span>	When a</span>n execution context is established for evaluating non-function code declarations are instantiated in the current VariableEnvironment.  Each top-level level variable, constant, or function declarated in the code is instantiated. </p>
      <p>Top-level Declaration Instantiation for base code is performed as follows: </p>
      <p>Let <i>env</i> be the environment record component of the running execution context’s VariableEnvironment.</p>
      <p>If <i>code</i> is eval code, then let <i>configurableBindings</i> be <b>true</b> else let <i>configurableBindings</i> be <b>false</b>.</p>
      <p>If <i>code </i>is strict code, then let <i>strict</i> be <b>true</b> else let <i>strict</i> be <b>false</b>.</p>
      <p>For each <i>FunctionDeclaration</i> <i>f</i> in <i>code</i>, in source text order do</p>
      <p>Let <i>fn</i> be the <i>Identifier</i> in <i>FunctionDeclaration</i> <i>f.</i></p>
      <p>Let <i>fo</i> be the result of instantiating <i>FunctionDeclaration f </i>as described in Clause 13.</p>
      <p>Let <i>funcAlreadyDeclared </i>be the result of calling <i>env’s</i> HasBinding concrete method passing <i>fn</i> as the argument.</p>
      <p>If <i>funcAlreadyDeclared </i>is <b>false</b>, then </p>
      <p>Call <i>env’s</i> CreateMutableBinding concrete method passing <i>fn</i> and <i>configurableBindings</i> as the arguments.</p>
      <p>Call <i>env</i>’s InitializeBinding concrete method passing <i>fn</i>, and <b>undefined</b> as the arguments.</p>
      <p>Else if <i>env</i> is the environment record component of the global environment then</p>
      <p>Let <i>go</i> be the global object.</p>
      <p>Let <i>existingProp</i> be the result of calling the [[GetOwnProperty]] internal method of <i>go</i> with argument <i>fn</i>.</p>
      <p>If <i>existingProp</i> is <b>undefined</b> or<i> </i><i>existingProp</i>.[[Configurable]] is <b>true</b>, then</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>go</i>, passing <i>fn</i>, Property Descriptor {[[Value]]:<i> </i><b>undefined</b>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b> , [[Configurable]]: <i>configurableBindings</i> }, and <b>true</b> as arguments.</p>
      <p>Else if IsAccessorDescriptor(<i>existingProp</i>) or <i>existingProp</i> does not have attribute values {[[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>}, then</p>
      <p>Throw a TypeError exception.</p>
      <p>Call <i>env’s</i> SetMutableBinding concrete method passing <i>fn</i>, <i>fo</i>, and <i>strict</i> as the arguments.</p>
      <p>For each <i>VariableDeclaration</i> and <i>VariableDeclarationNoIn</i> <i>d </i>in <i>code</i>, in source text order do</p>
      <p>Let <i>dn</i> be the <i>Identifier</i> in <i>d.</i></p>
      <p>Let <i>varAlreadyDeclared </i>be the result of calling <i>env’s</i> HasBinding concrete method passing <i>dn</i> as the argument.</p>
      <p>If <i>varAlreadyDeclared </i>is <b>false</b>, then</p>
      <p>Call <i>env</i>’s CreateMutableBinding concrete method passing <i>dn </i>and <i>configurableBindings</i> as the arguments.</p>
      <p>Call <i>env</i>’s InitializeBinding concrete method passing <i>dn</i>, and <b>undefined</b> as the arguments.</p>
      <p>Call <i>env</i>’s SetMutableBinding  concrete method passing <i>dn</i>, <b>undefined</b>, and <i>strict</i> <i> </i>as the arguments.</p>
      <p>else if <i>env</i> is the environment record component of the global environment then</p>
      <p>Let <i>go</i> be the global object.</p>
      <p>Let <i>existingProp</i> be the result of calling the [[GetOwnProperty]] internal method of <i>go</i> with argument <i>d</i><i>n</i>.</p>
      <p>If <i>existingProp</i> is <b>undefined</b>, then</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>go</i>, passing <i>dn</i>,  Property Descriptor {[[Value]]: <b>undefined</b>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b> , [[Configurable]]: <i>configurableBindings</i> }, and <b>true</b> as arguments.</p>
      <h2>10.5.2	Module Declaration Instantiation</h2>
      <h2>10.5.3<span>	Function Declaration Instantiation</span></h2>
      <p>NOTE	When an execution context is established for evaluating function code a new Declarative Environment Record is created and bindings for each formal parameter, and each function level variable, constant, or function declarated in the function are instantiated in the environment record. Formal parameters and functions are initialized as part of this process.  All other bindings are initialized during execution of the function code.</p>
      <p>Function Declaration Instantiation is performed as follows using arguments <i>func</i><i>,</i><i> </i><i>argumentsList</i>, and <i>env</i>. <i>func</i> is the function object that for which the execution context is being established.  <i>env</i> is the declarative environment record in which bindings are to be created. </p>
      <p>Let <i>code </i>be the value of the [[Code]] internal property of <i>func</i>.</p>
      <p>Let <i>strict</i> be be the value of the [[Strict]] internal property of <i>func</i>.</p>
      <p>Let <i>formals</i> be the value of the [[FormalParameterList]] internal property of <i>func</i>.</p>
      <p>Let <i>parameterNames</i> be the BoundNames of <i>FormalParameterList</i>.</p>
      <p>For each String <i>argName</i> in <i>parameterNames</i>, in list order do</p>
      <p>Let <i>alreadyDeclared </i>be the result of calling <i>env’s</i> HasBinding concrete method passing <i>argName</i> as the argument.</p>
      <p>NOTE   Duplicate parameter names can only occur in non-strict code.</p>
      <p>If <i>alreadyDeclared </i>is <b>false</b>, then </p>
      <p>Call <i>env’s</i> CreateMutableBinding concrete method passing <i>argName</i> as the argument.</p>
      <p>If <i>strict</i> is <b>false</b>, then</p>
      <p>Call <i>env</i>’s InitializeBinding concrete method passing <i>argName</i>, and <b>undefined</b> as the arguments.</p>
      <p>Let <i>declarations</i> be the LexicalDeclarations of <i>code</i>.</p>
      <p>If <i>strict</i> is <b>true</b>, then</p>
      <p>Let <i>ao</i> be the result of CreateStrictArgumentsObject. with argument <i>argumentsList.</i> </p>
      <p>Let <i>formalStatus</i> be the result of performing Binding Initialisation for <i>formals</i> with <i>ao</i> and <i>env</i> as arguments.</p>
      <p>Else,</p>
      <p>Let <i>names</i> be BoundNames of <i>formals</i>.</p>
      <p>NOTE		Because <i>F</i> is a none strict function it is not extended code.  Hence <i>formals</i> does not contain the names of any destructuring <i>BindingProperties</i>, rest parameters, or parameters with default value initialisers.</p>
      <p>Let <i>ao</i> be the result of performing the abstract operation CreateMappedArgumentsObject with arguments <i>names</i>, <i>env</i>, and <i>argumentsList</i>. </p>
      <p>Let <i>formalStatus</i> be the result of performing Binding Initialisation for <i>formals</i> with <i>ao</i> and <b>undefined</b> as arguments.</p>
      <p>NOTE	Binding Initialisation for <i>formals</i> is perform prior to to instantiating any non-parameter declarations in order to ensure that any such local declarations are not visible to any parameter Initialisation code that may be evaluated. </p>
      <p>ReturnIfAbrupt(<i>formalStatus</i>).</p>
      <p>For each element <i>d </i>in <i>declarations</i> do</p>
      <p>For each element <i>dn</i> of the BoundNames of <i>d</i> do</p>
      <p>Let <i>alreadyDeclared </i>be the result of calling <i>env’s</i> HasBinding concrete method passing <i>dn</i> as the argument.</p>
      <p>If <i>alreadyDeclared </i>is <b>false</b>, then </p>
      <p>If  IsConstantDeclaration of <i>d</i> is <b>true</b>, then</p>
      <p>Call <i>env</i>’s CreateImmutableBinding concrete method passing <i>dn </i>as the argument.</p>
      <p>Else,</p>
      <p>Call <i>env</i>’s CreateMutableBinding concrete method passing <i>dn </i>and <b>false</b> as the arguments.</p>
      <p>Let <i>argumentsAlreadyDeclared </i>be the result of calling <i>env’s</i> HasBinding concrete method passing <b>"arguments"</b><b> </b>as the argument.</p>
      <p>NOTE	If <i>argumentsAlreadyDeclared</i><i> </i>is <b>true</b> then the value of <i>ao</i> is not directly observable to ECMAScript code and need not actually exist. In that case,  its use in the above steps is strictly as a device for specifying formal parameter initialisation semantics. </p>
      <p>If <i>argumentsAlreadyDeclared </i>is <b>false</b>, then</p>
      <p>If <i>strict</i> is <b>true</b>, then </p>
      <p>Call <i>env</i>’s CreateImmutableBinding concrete method passing the String "<b>arguments</b>" as the argument.</p>
      <p>Else,</p>
      <p>Call <i>env</i>’s CreateMutableBinding concrete method passing the String "<b>arguments</b>" as the argument.</p>
      <p>Call <i>env</i>’s InitializeBinding concrete method passing "<b>arguments</b>" and <i>ao </i>as arguments.</p>
      <p>Let <i>varNames</i> be the VarDeclaredNames of <i>code</i>.</p>
      <p>For each String <i>var</i><i>Name</i> in <i>var</i><i>Names</i>, in list order do</p>
      <p>Let <i>alreadyDeclared </i>be the result of calling <i>env’s</i> HasBinding concrete method passing <i>var</i><i>Name</i> as the argument.</p>
      <p>NOTE		A VarDeclaredNames is only instantiated and initialied here if it is not also the name of a formal parameter or a <i>FunctionDeclarations</i>. Such duplicate declarations may only occur in non-extended code.</p>
      <p>If <i>alreadyDeclared </i>is <b>false</b>, then </p>
      <p>Call <i>env’s</i> CreateMutableBinding concrete method passing <i>var</i><i>Name</i> as the argument.</p>
      <p>Call <i>env</i>’s InitializeBinding concrete method passing <i>fn</i>, and <b>undefined</b> as the arguments.</p>
      <p>Let <i>initializedFunctions</i> be an emptyList.</p>
      <p>For each <i>FunctionDeclaration</i> <i>f</i> in <i>declarations</i>, in reverse list order do</p>
      <p>NOTE	<span>	If there are multiple</span> <i>FunctionDeclarations</i> for the same name, the last declaration is used. Multiple <i>FunctionDeclarations</i> for the same name is only valid in non-extended code.</p>
      <p>Let <i>fn</i> be the sole element of the BoundNames of <i>f.</i></p>
      <p>If <i>fn</i> is not an element of <i>initializedFunctions, </i>then</p>
      <p>Append <i>fn</i> to <i>initializedFunctions</i>.</p>
      <p>Let <i>fo</i> be the result of instantiating <i>FunctionDeclaration f </i>as described in Clause 13.</p>
      <p>Call <i>env</i>’s InitializeBinding concrete method passing <i>fn</i>, and <i>fo</i> as the arguments.</p>
      <p>Return NormalCompletion(empty)..</p>
      <h2>10.5.4	Block Declaration Instantiation</h2>
      <p>NOTE	 When a <i>Block</i> or <i>CaseBlock</i> production is evaluated a new Declarative Environment Record is created and bindings for each block scoped variable, constant, or function declarated in the block are instantiated in the environment record. </p>
      <p>Block Declaration Instantiation is performed as follows using arguments <i>code</i> and <i>env</i>. <i>code</i> is the grammar production corresponding to the body of the block.  <i>env</i> is the declarative environment record in which bindings are to be. </p>
      <p>Let <i>declarations</i> be the LexicalDeclarations of <i>code</i>.</p>
      <p>For each element <i>d </i>in <i>declarations</i> do</p>
      <p>For each element <i>dn</i> of the BoundNames of <i>d</i> do</p>
      <p>If IsConstantDeclaration of <i>d</i> is <b>true</b>, then</p>
      <p>Call <i>env</i>’s CreateImmutableBinding concrete method passing <i>dn </i>as the argument.</p>
      <p>Else,</p>
      <p>Call <i>env</i>’s CreateMutableBinding concrete method passing <i>dn </i>and <b>false</b> as the arguments.</p>
      <p>For each <i>FunctionDeclaration</i> <i>f</i> in <i>declarations</i>, in list order do</p>
      <p>Let <i>fn</i> be the sole element of the BoundNames of <i>f.</i></p>
      <p>Let <i>fo</i> be the result of instantiating <i>FunctionDeclaration f </i>as described in Clause 13.</p>
      <p>Call <i>env</i>’s InitializeBinding concrete method passing <i>fn</i>, and <i>fo</i> as the arguments.</p>
      <h2>10.6<span>	Arguments Object</span></h2>
      <p>When control enters an execution context for function code, an arguments object is created unless (as specified in 10.5) the identifier <b>arguments</b> occurs as an Identifier in the function’s FormalParameterList or occurs as the BindingIdentifier of a Declaration contained in the function code.</p>
      <p>The abstract operation <i>CreateStrictArgumentsObject</i> called with argument list <i>args</i> performs the following steps:</p>
      <p>Let <i>len</i> be the number of elements in <i>args</i>.</p>
      <p>Let <i>obj</i> be the result of the abstraction operation <i>InstantiateArgumentsObject </i>with argument <i>len</i>.</p>
      <p>Let <i>indx</i> = <i>len</i>  - 1.</p>
      <p>Repeat while <i>indx</i> &gt;= 0, </p>
      <p>Let <i>val</i> be the element of <i>args</i> at 0-origined list position <i>indx</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method on <i>obj</i> passing ToString(<i>indx</i>), the property descriptor {[[Value]]: <i>val</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b> as arguments.</p>
      <p>Let <i>indx</i> = <i>indx</i> - 1</p>
      <p>Let <i>thrower</i> be the [[ThrowTypeError]] function Object (13.2.3).</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>obj</i> with arguments <b>"caller"</b>, PropertyDescriptor {[[Get]]: <i>thrower</i>, [[Set]]: <i>thrower</i>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b>}, and <b>false</b>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>obj</i> with arguments <b>"callee"</b>, PropertyDescriptor {[[Get]]: <i>thrower</i>, [[Set]]: <i>thrower</i>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b>}, and <b>false</b>.</p>
      <p>Return <i>obj</i></p>
      <p>The abstract operation <i>CreateMappedArgumentsObject</i> called with List <i>names</i>, environment record <i>env</i>, and argument list <i>args</i> performs the following steps:</p>
      <p>Let <i>len</i> be the number of elements in <i>args</i>.</p>
      <p>Let <i>obj</i> be the result of the abstraction operation <i>InstantiateArgumentsObject </i>with argument <i>len</i>.</p>
      <p>Let <i>map</i> be the result of creating a new ECMAScript object.</p>
      <p>Set all the internal methods of <i>map</i> as specified in 8.12.</p>
      <p>Let <i>mappedNames</i> be an empty List.</p>
      <p>Let <i>indx</i> = <i>len</i>  - 1.</p>
      <p>Repeat while <i>indx</i> &gt;= 0, </p>
      <p>Let <i>val</i> be the element of <i>args</i> at 0-origined list position <i>indx</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method on <i>obj</i> passing ToString(<i>indx</i>), the property descriptor {[[Value]]: <i>val</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b> as arguments.</p>
      <p>If <i>indx</i> is less than the number of elements in <i>names</i>, then</p>
      <p>Let <i>name</i> be the element of <i>names</i> at 0-origined list position <i>indx</i>.</p>
      <p>If <i>name</i> is not an element of  <i>mappedNames</i>, then</p>
      <p>Add <i>name</i> as an element of the list <i>mappedNames</i>.</p>
      <p>Let <i>g</i> be the result of calling the <i>MakeArgGetter</i> abstract operation with arguments <i>name</i> and <i>env</i>.</p>
      <p>Let <i>p</i> be the result of calling the <i>MakeArgSetter</i> abstract operation with arguments <i>name</i> and <i>env</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>map</i> passing ToString(<i>indx</i>), the Property Descriptor {[[Set]]: <i>p</i>, [[Get]]: <i>g,</i> [[Configurable]]: <b>true</b>}, and <b>false</b> as arguments.</p>
      <p>Let <i>indx</i> = <i>indx</i> - 1</p>
      <p>If <i>mappedNames</i> is not empty, then</p>
      <p>Set the [[ParameterMap]] internal property of <i>obj</i> to <i>map</i>.</p>
      <p>Set the [[Get]], [[GetOwnProperty]], [[DefineOwnProperty]], and [[Delete]] internal methods of <i>obj</i> to the definitions provided below.</p>
      <p>Call the [[DefineOwnProperty]] internal method on <i>obj</i> passing "<b>callee</b>", the property descriptor {[[Value]]: <i>func</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>true</b>}, and <b>false</b> as arguments.</p>
      <p>Return <i>obj</i></p>
      <p>The abstract operation <i>InstantiateArgumentsObject</i> called with an argument <i>len</i> performs the following steps:</p>
      <p>Let <i>obj </i>be the result of creating a new ECMAScript object.</p>
      <p>Set all the internal methods of <i>obj</i> as specified in 8.12.</p>
      <p>Add the [[NativeBrand]] internal propert to <i>obj</i><i> </i>with value NativeArguments.</p>
      <p>Set the [[Prototype]] internal property of <i>obj</i> to the standard built-in Object prototype object (15.2.4).</p>
      <p>Call the [[DefineOwnProperty]] internal method on <i>obj</i> passing <b>"</b><b>length</b><b>"</b>, the Property Descriptor {[[Value]]: <i>len</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>true</b>}, and <b>false</b> as arguments.</p>
      <p>Return <i>obj</i></p>
      <p>The abstract operation <i>MakeArgGetter</i> called with String <i>name</i> and environment record <i>env</i> creates a function object that when executed returns the value bound for <i>name</i> in <i>env</i>.  It performs the following steps:</p>
      <p>Let <i>body</i><i>Text</i> be the result of concatenating the Strings "<b>return</b><b> </b>", <i>name</i>, and "<b>;</b>".</p>
      <p>Let <i>body</i> be the result of parsing <i>bodyText</i> using <i>FunctionBody</i> as the goal symbol.</p>
      <p>Let <i>parameters</i> be a FormalParameterList <b>:</b> [empty] production.</p>
      <p>Return the result of creating a function object as described in 13.2 using<i> parameters</i> as <i>FormalParameterList</i>, <i>body</i> for <i>FunctionBody</i>, <i>env</i> as <i>Scope</i>, and <b>true</b> for <i>Strict</i>.</p>
      <p>The abstract operation <i>MakeArgSetter</i> called with String <i>name</i> and environment record <i>env</i> creates a function object that when executed sets the value bound for <i>name</i> in <i>env</i>.  It performs the following steps:</p>
      <p>Let <i>param</i><i>Text</i> be the String <i>name </i>concatenated with the String  "_arg".</p>
      <p>Let <i>parameters</i> be the result of parsing <i>paramText</i> using <i>FormalParameterList</i> as the goal symbol.</p>
      <p>Let <i>body</i><i>Text</i> be the String <b>"&lt;name&gt; </b><b>=</b><b> &lt;param&gt;</b><b>;</b><b>"</b> with <b>&lt;name&gt;</b> replaced by the value of <i>name </i>and <b>&lt;param&gt; </b>replaced by the value of <i>param</i><i>Text</i>.</p>
      <p>Let <i>body</i> be the result of parsing <i>bodyText</i> using <i>FunctionBody</i> as the goal symbol.</p>
      <p>Return the result of creating a function object as described in 13.2 using <i>parameters</i> as <i>FormalParameterList</i>, <i>body</i> for <i>FunctionBody</i>, <i>env</i> as <i>Scope</i>, and <b>true</b> for <i>Strict</i>.</p>
      <p>The [[Get]] internal method of an arguments object for a non-strict mode function with formal parameters when called with a property name <i>P</i> performs the following steps:</p>
      <p>Let <i>map</i> be the value of the  [[ParameterMap]] internal property of the arguments object.</p>
      <p>Let <i>isMapped</i> be the result of calling the [[GetOwnProperty]] internal method of <i>map</i> passing <i>P</i> as the argument.</p>
      <p>If the value of <i>isMapped</i> is <b>undefined</b>, then</p>
      <p>Let <i>v</i> be the result of calling the default [[Get]] internal method (8.12.3) on the arguments object  passing <i>P</i> as the argument.</p>
      <p> If <i>P</i> is <b>"caller" </b>and <i>v</i> is a strict mode Function object, throw a <b>TypeError</b> exception.</p>
      <p>Return <i>v</i>.</p>
      <p>Else, <i>map</i> contains a formal parameter mapping for <i>P</i> so, </p>
      <p>Return the result of calling the [[Get]] internal method of <i>map</i> passing <i>P</i> as the argument.</p>
      <p>The [[GetOwnProperty]] internal method of an arguments object for a non-strict mode function with formal parameters when called with a property name <i>P</i> performs the following steps:</p>
      <p>Let <i>desc</i> be the result of calling the default [[GetOwnProperty]] internal method (8.12.1) on the arguments object passing <i>P</i> as the argument.</p>
      <p>If <i>desc</i> is <b>undefined</b> then return <i>desc</i>.</p>
      <p>Let <i>map</i> be the value of the  [[ParameterMap]] internal property of the arguments object.</p>
      <p>Let <i>isMapped</i> be the result of calling the [[GetOwnProperty]] internal method of <i>map</i> passing <i>P</i> as the argument.</p>
      <p>If the value of <i>isMapped</i> is not <b>undefined</b>, then</p>
      <p>Set <i>desc</i>.[[Value]] to the result of calling the [[Get]] internal method of <i>map</i> passing <i>P</i> as the argument.</p>
      <p>Return <i>desc</i>. </p>
      <p>The [[DefineOwnProperty]] internal method of an arguments object  for a non-strict mode function with formal parameters when called with a property name <i>P</i>, Property Descriptor <i>Desc</i>, and Boolean flag <i>Throw</i> performs the following steps:</p>
      <p>Let <i>map </i>be the value of the  [[ParameterMap]] internal property of the arguments object.</p>
      <p>Let <i>isMapped </i>be the result of calling the [[GetOwnProperty]] internal method of <i>map</i> passing <i>P </i>as the argument.</p>
      <p>Let <i>allowed </i>be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on the arguments object passing <i>P</i>, <i>Desc</i>, and <b>false </b>as the arguments.</p>
      <p>If <i>allowed</i> is <b>false</b>, then</p>
      <p>If <i>Throw </i>is <b>true </b>then throw a <b>TypeError </b>exception, otherwise return <b>false</b>.</p>
      <p>If the value of <i>isMapped </i>is not <b>undefined</b>, then</p>
      <p>If IsAccessorDescriptor(<i>Desc</i>) is <b>true</b>, then</p>
      <p>Call the [[Delete]] internal method of <i>map </i>passing <i>P</i>, and <b>false </b>as the arguments.</p>
      <p>Else</p>
      <p>If <i>Desc</i>.[[Value]] is present, then</p>
      <p>Call the [[Put]] internal method of <i>map </i>passing <i>P</i>, <i>Desc</i>.[[Value]], and <i>Throw </i>as the arguments.</p>
      <p>If <i>Desc</i>.[[Writable]] is present and its value is <b>false</b>, then</p>
      <p>Call the [[Delete]] internal method of <i>map </i>passing <i>P </i>and <b>false </b>as arguments.</p>
      <p>Return <b>true</b>.</p>
      <p>The [[Delete]] internal method of an arguments object for a non-strict mode function with formal parameters when called with a property name <i>P</i> and Boolean flag <i>Throw</i> performs the following steps:</p>
      <p>Let <i>map</i> be the value of the  [[ParameterMap]] internal property of the arguments object.</p>
      <p>Let <i>isMapped</i> be the result of calling the [[GetOwnProperty]] internal method of <i>map</i> passing <i>P</i> as the argument.</p>
      <p>Let <i>result</i> be the result of calling the default [[Delete]] internal method (8.12.7) on the arguments object passing <i>P </i>and <i>Throw</i> as the arguments.</p>
      <p>If <i>result</i> is  <b>true</b> and the value of <i>isMapped</i> is not <b>undefined</b>, then</p>
      <p>Call the [[Delete]] internal method of <i>map</i> passing <i>P</i>, and <b>false</b> as the arguments.</p>
      <p>Return <i>result</i>.</p>
      <p>NOTE 1<span>	For non-strict mode functions the array index (defined in 15.4) named data properties of an arguments object whose numeric name values are less than the number of formal parameters of the corresponding function object initially share their values with the corresponding argument bindings in the function’s execution context. This means that changing the property changes the corresponding value of the argument binding and vice-versa. This correspondence is broken if such a property is deleted and then redefined or if the property is changed into an accessor property. For strict mode functions, the values of the arguments object’s properties are simply a copy of the arguments passed to the function and there is no dynamic linkage between the property values and the formal parameter values.</span></p>
      <p>NOTE 2<span>	The ParameterMap object and its property values are used as a device for specifying the arguments object correspondence to argument bindings. The ParameterMap object and the objects that are the values of its properties are not directly accessible from ECMAScript code. An ECMAScript implementation does not need to actually create or use such objects to implement the specified semantics.</span></p>
      <p>NOTE 3<span>	Arguments objects for strict mode functions define non-configurable accessor properties named "</span><b>caller</b>" and "<b>callee</b>" which throw a <b>TypeError</b> exception on access. The "<b>callee</b>" property has a more specific meaning for non-strict mode functions and a "<b>caller</b>" property has historically been provided as an implementation-defined extension by some ECMAScript implementations. The strict mode definition of these properties exists to ensure that neither of them is defined in any other manner by conforming ECMAScript implementations.</p>
      <h1>11<span>	Expression</span>s</h1>
      <h2>11.1<span>	Primary Expression</span>s</h2>
      <p>Syntax </p>
      <p>PrimaryExpression <b>:</b></p>
      <p><b>this</b><span><br>Identifier</span><span><br>Literal</span><br>SealedArrayLiteral<br>SealedObjectLiteral<br>FunctionExpression<span><br>GeneratorExpression</span><span><br>GeneratorComprehension</span><br><b>(</b> Expression <b>)</b></p>
      <h2>11.1.1<span>	The </span>this Keyword</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>PrimaryExpression <b>:</b><b>  </b><b>this</b> </p>
      <p>Return the value of the ThisBinding of the current execution context.</p>
      <h2>11.1.2<span>	Identifier Referenc</span>e</h2>
      <p>Let <i>ref</i> be the result of performing Identifier Resolution as specified in 10.3.1 using the <i>IdentifierName</i> corresponding to <i>Identifier</i>.</p>
      <p>Return <i>ref</i>.</p>
      <p>NOTE:	The result of evaluating an Identifier is always a value of type Reference.</p>
      <h2>11.1.3<span>	Literal Referenc</span>e</h2>
      <p>A Literal is evaluated as described in 7.8.</p>
      <h2>11.1.4<span>	Array </span>Initialiser</h2>
      <p>Syntax</p>
      <p>SealedArrayInitialiser <b>:</b></p>
      <p>ArrayInitialiser<b><br>#</b><b> </b>ArrayInitialiser</p>
      <p>ArrayInitialiser <b>:</b></p>
      <p>ArrayLiteral<b><br></b>ArrayComprehension</p>
      <h2>11.1.4.1<span>	Array </span>Literal</h2>
      <p>NOTE	 An <i>ArrayLiteral</i> is an expression describing the initialisation of an Array object, using a list, of zero or more expressions each of which represents an array element, enclosed in square brackets. The elements need not be literals; they are evaluated each time the array initialiser is evaluated.</p>
      <p>Array elements may be elided at the beginning, middle or end of the element list. Whenever a comma in the element list is not preceded by an AssignmentExpression (i.e., a comma at the beginning or after another comma), the missing array element contributes to the length of the Array and increases the index of subsequent elements. Elided array elements are not defined. If an element is elided at the end of an array, that element does not contribute to the length of the Array.</p>
      <p>Syntax</p>
      <p>ArrayLiteral <b>:</b></p>
      <p><b>[ </b>Elision<sub>opt</sub> <b>]</b><b><br>[ </b>ElementList <b>]</b><b><br>[ </b>ElementList <b>,</b> Elision<sub>opt</sub> <b>]</b></p>
      <p>ElementList <b>:</b></p>
      <p>Elision<sub>opt</sub><sub> </sub>AssignmentExpression<span><br>Elision</span><sub>opt</sub><sub> </sub><b>… </b>AssignmentExpression<span><br>ElementList </span><b>,</b> Elision<sub>opt</sub><sub> </sub>AssignmentExpression<span><br>ElementList </span><b>,</b> Elision<sub>opt</sub><sub> </sub>SpreadElement</p>
      <p>Elision<b> :</b></p>
      <p>
        <b>,</b>
        <span><br>Elision </span>
        <b>,</b>
      </p>
      <p>SpreadElement <b>:</b></p>
      <p><b>… </b>AssignmentExpression</p>
      <p>ArrayComprehension <b>:</b></p>
      <p>Expression ComprehensionForList<b><br></b>Expression ComprehensionForList  <b>if (</b> Expression <b>)</b></p>
      <p>ComprehensionForList <b>:</b></p>
      <p>ComprehensionFor<b><br></b>ComprehensionForList  ComprehensionFor</p>
      <p>ComprehensionFor <b>:</b></p>
      <p><b>for</b><b> (</b> LeftHandSideExpression <b>of</b><b> </b>Expression <b>)</b></p>
      <p>
        <b>Static Semantics</b>
      </p>
      <p>
        <b>Static Semantics:  </b>
        <b>Elis</b>
        <b>i</b>
        <b>on</b>
        <b> </b>
        <b>Width</b>
      </p>
      <p>Elision <b>:</b>  [empty]  </p>
      <p>Return the numeric value 0.</p>
      <p>Elision <b>:</b>  <b>,</b>  </p>
      <p>Return the numeric value 1.</p>
      <p>Elision <b>:</b>  Elision <b>,</b>  </p>
      <p>Let <i>preceding</i> be the Elision Width of <i>Elision</i>.</p>
      <p>Return <i>preceding</i>+1.</p>
      <p>
        <b>Runtime Semantics</b>
      </p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Array Accumulation</b>
      </p>
      <p>With parameters <i>array</i> and <i>nextIndex</i>.</p>
      <p>ElementList <b>:</b>  Elision<sub>opt</sub> AssignmentExpression  </p>
      <p>Let <i>padding</i><i> </i>be the Elision Width of <i>Elision</i><sub>opt</sub>.</p>
      <p>Let <i>initResult </i>be the result of evaluating <i>AssignmentExpression</i>.</p>
      <p>Let <i>initValue </i>be GetValue(<i>initResult</i>).</p>
      <p>If <i>initValue </i>is an abrupt completion, return <i>initValue</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>array </i>with arguments ToString(ToUint32(<i>next</i><i>Index</i><i>+padding</i>)), the Property Descriptor { [[Value]]: <i>initValue</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Return <i>next</i><i>Index</i><i>+padding+</i>1.</p>
      <p>ElementList <b>:</b>  Elision<sub>opt</sub>  SpreadElement</p>
      <p>Let <i>padding</i><i> </i>be the Elision Width of <i>Elision</i><sub>opt</sub>.</p>
      <p>Return the result of performing Array Accumulation for <i>SpreadElement</i> with arguments <i>array</i> and <i>nextIndex</i>+<i>padding</i>.</p>
      <p>ElementList <b>:</b>  ElementList <b>,</b> Elision<sub>opt</sub> AssignmentExpression  </p>
      <p>Let <i>postIndex </i><i> </i>be the result of performing Array Accumulation for <i>ElementList</i> with arguments <i>array</i> and <i>nextIndex</i>.</p>
      <p>If <i>postIndex </i><i> </i>is an abrupt completion, return <i>postIndex</i>.</p>
      <p>Let <i>padding</i><i> </i>be the Elision Width of <i>Elision</i><sub>opt</sub>.</p>
      <p>Let <i>initResult </i>be the result of evaluating <i>AssignmentExpression</i>.</p>
      <p>Let <i>initValue </i>be GetValue(<i>initResult</i>).</p>
      <p>If <i>initValue </i>is an abrupt completion, return <i>initValue</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>array </i>with arguments ToString(ToUint32((<i>postIndex</i>+<i>padding</i>)) and the Property Descriptor { [[Value]]: <i>initValue</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Return <i>postIndex</i>+<i>padding+</i>1.</p>
      <p>ElementList <b>:</b>  ElementList <b>,</b> Elision<sub>opt</sub> SpreadElement  </p>
      <p>Let <i>postIndex </i><i> </i>be the result of performing Array Accumulation for <i>ElementList</i> with arguments <i>array</i> and <i>nextIndex</i>.</p>
      <p>If <i>postIndex </i><i> </i>is an abrupt completion, return <i>postIndex </i><i> </i>.</p>
      <p>Let <i>pad </i>be the result of evaluating <i>Elision</i><sub>opt</sub>; if not present, use the numeric value zero.</p>
      <p>Return the result of performing Array Accumulation for <i>SpreadElement</i> with arguments <i>array</i> and <i>post</i><i>Index</i>+<i>padding</i>.</p>
      <p>SpreadElement <b>:</b>  <b>…</b><span style="font-weight: bold; font-style: italic"> </span>AssignmentExpression</p>
      <p>Let <i>spreadRef </i>be the result of evaluating <i>AssignmentExpression</i>.</p>
      <p>Let <i>spreadValue </i>be GetValue(<i>spreadRef</i>).</p>
      <p>Let <i>spreadObj</i> be ToObject(<i>spreadValue</i>).</p>
      <p>If <i>spreadObj</i> is an abrupt completion, return <i>spreadObj</i>.</p>
      <p>Let <i>lenVal</i> be the result of calling the [[Get]] internal method of <i>spreadObj</i> with argument “<b>length</b>”.</p>
      <p>Let <i>spreadLen</i> be ToUint32(<i>lenVal</i>).</p>
      <p>Let <i>n</i>=0;</p>
      <p>Repeat, while <i>n</i> &lt; <i>spreadLen</i></p>
      <p>Let <i>exists</i> be the result of calling the [[HasProperty]] internal method of <i>spreadObj</i> with ToString(<i>n</i>).</p>
      <p>If <i>exists</i> is <b>true</b> then,</p>
      <p>Let <i>v</i> be the result of calling the [[Get]] internal method of <i>spreadObj</i> passing ToString(<i>n</i>) as the argument.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>array</i> with arguments ToString(ToUint32(<i>nextI</i><i>ndex)</i>), Property Descriptor {[[Value]]: <i>v</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Let <i>n</i> = <i>n</i>+1.</p>
      <p>Let <i>nextI</i><i>ndex</i> = <i>nextI</i><i>ndex</i> +1.</p>
      <p>Return <i>nextIndex</i>.</p>
      <p>NOTE<span>	 [[DefineOwnProperty]] is used to ensure that own properties are defined for the array even if the standard built-in Array prototype object has been modified in a manner that would preclude the creation of ne</span>w own properties using [[Put]].</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>ArrayLiteral <b>:</b>  <b>[ </b>Elision<sub>opt</sub> <b>]</b>  </p>
      <p>Let <i>array </i>be the result of creating a new object as if by the expression <b>new Array() </b>where<b> Array </b>is the standard built-in constructor with that name.</p>
      <p>Let <i>pad </i>be the Elision Width of <i>Elision</i><sub>opt</sub>.</p>
      <p>Call the [[Put]] internal method of <i>array </i>with arguments "<b>length</b>", <i>pad</i>, and <b>false</b>.</p>
      <p>Return <i>array</i>.</p>
      <p>ArrayLiteral <b>:</b> <b>[ </b>ElementList <b>]</b>  </p>
      <p>Let <i>array </i>be the result of creating a new object as if by the expression <b>new Array() </b>where<b> Array </b>is the standard built-in constructor with that name.</p>
      <p>Let <i>len</i> be result of performing Array Accumulation for <i>ElementList</i> with arguments <i>array</i> and 0.</p>
      <p>If <i>len</i> is an abrupt completion, return <i>len</i>.</p>
      <p>Call the [[Put]] internal method of <i>array </i>with arguments "<b>length</b>", <i>len</i>, and <b>false</b>.</p>
      <p>Return <i>array</i>.</p>
      <p>ArrayLiteral <b>: </b><b>[ </b>ElementList <b>,</b><i> </i>Elision<sub>opt</sub> <b>]</b>  </p>
      <p>Let <i>array </i>be the result of creating a new object as if by the expression <b>new Array() </b>where<b> Array </b>is the standard built-in constructor with that name.</p>
      <p>Let <i>len</i> be result of performing Array Accumulation for <i>ElementList</i> with arguments <i>array</i> and 0.</p>
      <p>If <i>len</i> is an abrupt completion, return <i>len</i>.</p>
      <p>Let <i>pad </i>be the Elision Width of <i>Elision</i><sub>opt</sub>.</p>
      <p>Call the [[Put]] internal method of <i>array </i>with arguments "<b>length</b>", ToUint32(<i>pad</i>+<i>len</i>), and <b>false</b>.</p>
      <p>Return <i>array</i>.</p>
      <h2>11.1.4.2<span>	Array </span>Comprehension</h2>
      <p>Syntax</p>
      <p>ArrayComprehension <b>:</b></p>
      <p><b>[ </b>Expression ComprehensionForList <b>]</b><b><br></b><b>[ </b>Expression ComprehensionForList  <b>if (</b> Expression <b>)</b> <b>]</b></p>
      <p>ComprehensionForList <b>:</b></p>
      <p>ComprehensionFor<b><br></b>ComprehensionForList  ComprehensionFor</p>
      <p>ComprehensionFor <b>:</b></p>
      <p><b>for</b><b> (</b> LeftHandSideExpression <b>of</b><b> </b>Expression <b>)</b></p>
      <h2>11.1.5<span>	Object Initialiser</span></h2>
      <p>NOTE	An object initialiser is an expression describing the initialisation of an Object, written in a form resembling a literal. It is a list of zero or more pairs of property names and associated values, enclosed in curly braces. The values need not be literals; they are evaluated each time the object initialiser is evaluated.</p>
      <p>Syntax</p>
      <p>SealedObjectLiteral <b>:</b></p>
      <p>ObjectLiteral<b><br># </b>ObjectLiteral</p>
      <p>ObjectLiteral <b>:</b></p>
      <p><b>{ }</b><br><b>{ </b>PropertyNameAndValueList <b>}</b><b><br>{ </b>PropertyNameAndValueList , <b>}</b></p>
      <p>PropertyNameAndValueList <b>:</b></p>
      <p>PropertyAssignment<span><br>PropertyNameAndValueList</span> <b>,</b> PropertyAssignment</p>
      <p>PropertyAssignment<b> </b><b>:</b></p>
      <p>IdentifierName<br>PropertyName <b>:</b> AssignmentExpression<span><br>PropertyName</span> <b>(</b> FormalParameterList <b>)</b> <b>{</b> FunctionBody <b>}</b> <br><b>*</b> PropertyName <b>(</b> FormalParameterList <b>)</b> <b>{</b> FunctionBody <b>}</b><br><b>get </b>PropertyName <b>( )</b> <b>{</b> FunctionBody <b>}</b><b><br></b><b>set </b>PropertyName <b>( </b>PropertySetParameterList<b> ) { </b>FunctionBody <b>}</b></p>
      <p>PropertyName <b>:</b></p>
      <p>IdentifierName<span><br>StringLiteral</span><span><br>NumericLiteral</span></p>
      <p>PropertySetParameterList<b> </b><b>:</b></p>
      <p>BindingIdentifier <span><br>BindingPattern </span></p>
      <h2>11.1.5.1 Static Semantics</h2>
      <p>
        <b>Early Errors</b>
      </p>
      <p>PropertyNameAndValueList <b>:</b>  PropertyNameAndValueList <b>,</b> PropertyAssignment<b> </b></p>
      <p>It is a Syntax Error if this production is contained in strict code,  PropertyAssignment<b> </b>is the production PropertyAssignment <b>:</b> PropertyName <b>:</b> AssignmentExpression, and PropertyDefinitionList(PropName of PropertyAssignment) of PropertyNameAndValueList is not the empty List.</p>
      <p>It is a Syntax Error if PropertyAssignment<b> </b>is the production PropertyAssignment <b>:</b> IdentifierName and PropertyDefinitionList(PropName of PropertyAssignment) of PropertyNameAndValueList is not the empty List.</p>
      <p>It is a Syntax Error if PropertyAssignment<b> </b>is the production PropertyAssignment <b>:</b> PropertyName <b>(</b><b> </b><i>FormalParameterList</i><b> ) {</b> FunctionBody <b>}</b> and PropertyDefinitionList(PropName of PropertyAssignment) of PropertyNameAndValueList is not the empty List.</p>
      <p>It is a Syntax Error if PropertyAssignment<b> </b>is the production PropertyAssignment <b>:</b> <b>* </b>PropertyName <b>(</b><b> </b><i>FormalParameterList</i><b> ) {</b> FunctionBody <b>}</b> and PropertyDefinitionList(PropName of PropertyAssignment) of PropertyNameAndValueList is not the empty List.</p>
      <p>It is a Syntax Error if PropertyAssignment<b> </b>is the production<span><br>   </span>PropertyAssignment <b>:</b> <b>get</b> PropertyName <b>( ) {</b> FunctionBody <b>}</b><br>and PropertyDefinitionList (PropName of PropertyAssignment) of PropertyNameAndValueList includes a production of the form PropertyAssignment <b>:</b> PropertyName <b>:</b> AssignmentExpression.</p>
      <p>It is a Syntax Error if PropertyAssignment<b> </b>is the production<span><br>   </span>PropertyAssignment <b>:</b> <b>set</b> PropertyName <b>( </b>PropertySetParameterList<b> )</b> <b>{</b> FunctionBody <b>}</b><br>and PropertyDefinitionList (PropName of PropertyAssignment) of PropertyNameAndValueList includes a production of the form PropertyAssignment <b>:</b> PropertyName <b>:</b> AssignmentExpression.</p>
      <p>It is a Syntax Error if PropertyAssignment<b> </b>is the production<span><br>   </span>PropertyAssignment <b>:</b> <b>get</b> PropertyName <b>( ) {</b> FunctionBody <b>}</b><span><br>and </span>PropertyDefinitionList (PropName of PropertyAssignment) of PropertyNameAndValueList includes a production of the form PropertyAssignment <b>:</b> <b>get</b> PropertyName <b>( ) {</b> FunctionBody <b>}</b>.</p>
      <p>It is a Syntax Error if PropertyAssignment<b> </b>is the production<span><br>   </span>PropertyAssignment <b>:</b> <b>set</b> PropertyName <b>( </b>PropertySetParameterList<b> )</b> <b>{</b> FunctionBody <b>}</b><br>and PropertyDefinitionList (PropName of PropertyAssignment) of PropertyNameAndValueList includes a production of the form<span><br>   </span>PropertyAssignment <b>:</b> <b>set</b> PropertyName <b>( </b>PropertySetParameterList<b> )</b> <b>{</b> FunctionBody <b>}</b>.</p>
      <p>PropertyAssignment <b>:</b> PropertyName <b>( </b>FormalParameterList<b> )</b> <b>{</b> FunctionBody <b>} </b></p>
      <p>and</p>
      <p><b>*</b> PropertyAssignment <b>:</b> PropertyName <b>( </b>FormalParameterList<b> )</b> <b>{</b> FunctionBody <b>} </b></p>
      <p>It is a Syntax Error if the PropName of PropertyName also occurs in the VarDeclaredNames of <i>FunctionBody</i>.</p>
      <p>It is a Syntax Error if the PropName of PropertyName also occurs in the LexicallyDeclaredNames of <i>FunctionBody</i>.</p>
      <p>It is a Syntax Error if any element of the LexicallyDeclaredNames of <i>FormalParameterList</i> also occurs in the VarDeclaredNames of <i>FunctionBody</i>.</p>
      <p>It is a Syntax Error if any element of the BoundNames of <i>FormalParameterList</i> also occurs in the LexicallyDeclaredNames of <i>FunctionBody</i>.</p>
      <p>PropertyAssignment <b>:</b> <b>set</b> PropertyName <b>( </b>PropertySetParameterList<b> )</b> <b>{</b> FunctionBody <b>} </b></p>
      <p>It is a Syntax Error if any element of the BoundNames of PropertySetParameterList<b> </b>also occurs in the LexicallyDeclaredNames of <i>FunctionBody</i>.</p>
      <p>PropertySetParameterList <b>:</b> BindingPattern  </p>
      <p>It is a Syntax Error if BoundNames of BindingPattern  contains any duplicate elements.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>BoundNames</b>
      </p>
      <p>PropertySetParameterList <b>:</b> <i>Binding</i>Identifier </p>
      <p>Return BoundNames of <i>Binding</i>Identifier.</p>
      <p>PropertySetParameterList<b>:</b> BindingPattern </p>
      <p>Return BoundNames of BindingPattern.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>ExpectedArgumentCount</b>
      </p>
      <p>PropertySetParameterList <b>:</b> <i>BindingIdentifier </i></p>
      <p>Return 1.</p>
      <p>PropertySetParameterList <b>:</b> BindingPattern </p>
      <p>Return 1.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>HasInitialiser</b>
      </p>
      <p>PropertySetParameterList <b>:</b> <i>BindingIdentifier </i></p>
      <p>Return <b>false</b>.</p>
      <p>PropertySetParameterList <b>:</b> BindingPattern </p>
      <p>Return <b>false</b>.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>PropertyDefinitionList(name)</b>
      </p>
      <p>PropertyNameAndValueList <b>:</b>  PropertyAssignment </p>
      <p>If PropName of PropertyAssignment is not <i>name</i> return the empty List.</p>
      <p>Return a List containing PropertyAssignment.</p>
      <p>PropertyNameAndValueList <b>:</b>  PropertyNameAndValueList <b>,</b> PropertyAssignment</p>
      <p>Let <i>previous</i> be PropertyDefinitionList(<i>name</i>) of PropertyNameAndValueList.</p>
      <p>If PropName of PropertyAssignment is <i>name</i> then,</p>
      <p>Append  PropertyAssignment to the end of <i>previous</i>.</p>
      <p>Return <i>previous</i>.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>PropName</b>
      </p>
      <p>PropertyAssignment <b>:</b> IdentifierName </p>
      <p>Return String Value of IdentifierName.</p>
      <p>PropertyAssignment <b>:</b> PropertyName <b>:</b> AssignmentExpression </p>
      <p>Return PropName of <i>PropertyName</i>.</p>
      <p>PropertyAssignment <b>:</b> PropertyName <b>(</b><b> </b><i>FormalParameterList</i><b> ) {</b> FunctionBody <b>}</b> </p>
      <p>Return PropName of <i>PropertyName</i>.</p>
      <p>PropertyAssignment <b>:</b> <b>* </b>PropertyName <b>(</b><b> </b><i>FormalParameterList</i><b> ) {</b> FunctionBody <b>}</b> </p>
      <p>Return PropName of <i>PropertyName</i>.</p>
      <p>PropertyAssignment <b>:</b> <b>get</b> PropertyName <b>( ) {</b> FunctionBody <b>}</b></p>
      <p>Return PropName of <i>PropertyName</i>.</p>
      <p>PropertyAssignment <b>:</b> <b>set</b> PropertyName <b>( </b>PropertySetParameterList<b> )</b><b> {</b> FunctionBody <b>}</b> </p>
      <p>Return PropName of <i>PropertyName</i>.</p>
      <p>PropertyName <b>: </b> IdentifierName  </p>
      <p>Return PropName of <i>IdentifierName</i>.</p>
      <p>PropertyName <b>: </b> StringLiteral  </p>
      <p>Return the SV of the <i>StringLiteral</i>.</p>
      <p>PropertyName <b>:</b> NumericLiteral  </p>
      <p>Let <i>nbr </i>be the result of forming the value of the <i>NumericLiteral</i>.</p>
      <p>Return ToString(<i>nbr</i>).</p>
      <h2>11.1.5.2 Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>ObjectLiteral <b>:</b>  <b>{</b> <b>}</b>  </p>
      <p>Return a new object created as if by the expression <b>new Object() </b>where <b>Object</b> is the standard built-in constructor with that name.</p>
      <p>ObjectLiteral <b>:</b></p>
      <p><b>{</b> PropertyNameAndValueList <b>}</b><br><b>{</b> PropertyNameAndValueList <b>, }</b></p>
      <p>Let <i>obj </i>be the result of creating a new object as if by the expression <b>new Object() </b>where <b>Object</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>success</i> be the result of performing Property Definition Evaluation of  <i>PropertyNameAndValueList</i><i> </i>with argument <i>obj</i>.</p>
      <p>If <i>success</i> is an abrupt completion, return <i>success</i>.</p>
      <p>Return <i>obj</i>.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Property Definition </b>
        <b>Evaluation</b>
      </p>
      <p>With parameter <i>object</i>.</p>
      <p>PropertyNameAndValueList <b>:</b>  PropertyAssignment </p>
      <p>Return the result of Perform Property Definition Evaluation of <i>Property</i><i>Assignment </i>with argument <i>ob</i><i>ject</i>.</p>
      <p>PropertyNameAndValueList <b>:</b>  PropertyNameAndValueList <b>,</b> PropertyAssignment</p>
      <p>Let <i>success</i> be the result of performing Property Definition Evaluation of  <i>PropertyNameAndValueList</i> with argument <i>ob</i><i>ject</i>.</p>
      <p>If <i>success</i> is an abrupt completion, return <i>success</i>.</p>
      <p>Return the result of performing Property Definition Evaluation of <i>Property</i><i>Assignment </i>with argument <i>ob</i><i>ject</i>.</p>
      <p>PropertyAssignment <b>:</b> IdentifierName </p>
      <p>Let <i>propName </i>be PropName(IdentifierName).</p>
      <p>Let <i>exprValue </i>be the result of performing Identifier Resolution as specified in 10.3.1 using <i>Identifier</i><i>Name</i>.</p>
      <p>Let <i>propValue </i>be GetValue(<i>exprValue</i>).</p>
      <p>If <i>propValue </i>is an abrupt completion, return <i>propValue</i>.</p>
      <p>Let <i>desc </i>be the Property Descriptor{[[Value]]: <i>propValue</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}</p>
      <p>Return the result of calling the [[DefineOwnProperty]] internal method of <i>obj</i><i>ect</i> with arguments <i>propName</i>, <i>desc</i>, and <b>false</b>.</p>
      <p>PropertyAssignment <b>:</b> PropertyName <b>:</b> AssignmentExpression </p>
      <p>Let <i>propName </i>be PropName(<i>PropertyName</i>).</p>
      <p>Let <i>exprValue </i>be the result of evaluating <i>AssignmentExpression</i>.</p>
      <p>Let <i>propValue </i>be GetValue(<i>exprValue</i>).</p>
      <p>If <i>propValue </i>is an abrupt completion, return <i>propValue</i>.</p>
      <p>Let <i>desc </i>be the Property Descriptor{[[Value]]: <i>propValue</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}</p>
      <p>Return the result of calling the [[DefineOwnProperty]] internal method of <i>obj</i><i>ect</i> with arguments <i>propName</i>, <i>desc</i>, and <b>false</b>.</p>
      <p>PropertyAssignment <b>:</b> PropertyName <b>(</b><b> </b><i>FormalParameterList</i><b> ) {</b> FunctionBody <b>}</b> </p>
      <p>Let <i>propName </i>be PropName of <i>PropertyName</i>.</p>
      <p>Let <i>closure </i>be the result of creating a new Function object as specified in 13.1.1 using a FormalParameterList <b>:</b> [empty] production as the parameter list and body specified by <i>FunctionBody</i>. Pass in the LexicalEnvironment of the running execution context as the <i>Scope</i>. Pass in <b>true</b> as the <i>Strict</i> flag. Pass object as the optional <i>homeObject</i> argument and propName as the optional <i>methodName</i> argument.</p>
      <p>Let <i>desc</i> be the Property Descriptor{[[Get]]: <i>closure</i>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}</p>
      <p>Return the result of calling the [[DefineOwnProperty]] internal method of <i>obj</i><i>ect</i> with arguments <i>propName</i>, <i>desc</i>, and <b>false</b>.</p>
      <p>PropertyAssignment <b>:</b> <b>* </b>PropertyName <b>(</b><b> </b><i>FormalParameterList</i><b> ) {</b> FunctionBody <b>}</b> </p>
      <p>Let <i>propName </i>be PropName of <i>PropertyName</i>.</p>
      <p>Let <i>closure </i>be the result of creating a new Generator object as specified in 13.2.xxx  using a FormalParameterList <b>:</b> [empty] production as the parameter list and body specified by <i>FunctionBody</i>. Pass in the LexicalEnvironment of the running execution context as the <i>Scope</i>. Pass in <b>true</b> as the <i>Strict</i> flag. Pass object as the optional <i>homeObject</i> argument and propName as the optional <i>methodName</i> argument.</p>
      <p>Let <i>desc</i> be the Property Descriptor{[[Get]]: <i>closure</i>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}</p>
      <p>Return the result of calling the [[DefineOwnProperty]] internal method of <i>obj</i><i>ect</i> with arguments <i>propName</i>, <i>desc</i>, and <b>false</b>.</p>
      <p>PropertyAssignment <b>:</b> <b>get</b> PropertyName <b>( ) {</b> FunctionBody <b>}</b> </p>
      <p>Let <i>propName </i>be PropName(<i>PropertyName</i>).</p>
      <p>Let <i>closure </i>be the result of creating a new Function object as specified in 13.2 using a FormalParameterList <b>:</b> [empty] production as the formal parameter list and body specified by <i>FunctionBody</i>. Pass in the LexicalEnvironment of the running execution context as the <i>Scope</i>. Pass in <b>true</b> as the <i>Strict</i> flag if the PropertyAssignment is contained in strict code or if its <i>FunctionBody</i> is strict code. Pass object as the optional <i>homeObject</i> argument and propName as the optional <i>methodName</i> argument. </p>
      <p>Let <i>desc</i> be the Property Descriptor{[[Get]]: <i>closure</i>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}</p>
      <p>Return the result of calling the [[DefineOwnProperty]] internal method of <i>obj</i><i>ect</i> with arguments <i>propName</i>, <i>desc</i>, and <b>false</b>.</p>
      <p>PropertyAssignment <b>:</b> <b>set</b> PropertyName <b>( </b>PropertySetParameterList<b> )</b> <b>{</b> FunctionBody <b>}</b> </p>
      <p>Let <i>propName </i>be PropName(<i>PropertyName</i>).</p>
      <p>Let <i>closure</i> be the result of creating a new Function object as specified in 13.2 with parameters specified by <i>PropertySetParameterList </i>and body specified by <i>FunctionBody</i>. Pass in the LexicalEnvironment of the running execution context as the <i>Scope</i>. Pass in <b>true</b> as the <i>Strict</i> flag if the PropertyAssignment is contained in strict code or if its <i>FunctionBody</i> is strict code. Pass object as the optional <i>homeObject</i> argument and propName as the optional <i>methodName</i> argument.</p>
      <p>Let <i>desc</i> be the Property Descriptor{[[Set]]: <i>closure</i>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}</p>
      <p>Return the result of calling the [[DefineOwnProperty]] internal method of <i>obj</i><i>ect</i> with arguments <i>propName</i>, <i>desc</i>, and <b>false</b>.</p>
      <h2>11.1.6<span>	Function Expressions</span></h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>PrimaryExpression <b>:</b> FunctionExpression </p>
      <p>Return the result of evaluating <i>FunctionExpression</i>.</p>
      <h2>11.1.7	Generator Comprehensions</h2>
      <p>Syntax</p>
      <p>GeneratorComprehension <b>:</b></p>
      <p><b>(</b><b> </b>Expression ComprehensionForList <b>)</b><b><br></b><b>(</b><b> </b>Expression ComprehensionForList  <b>if (</b> Expression <b>)</b> <b>)</b></p>
      <p>ComprehensionForList <b>:</b></p>
      <p>ComprehensionFor<b><br></b>ComprehensionForList  ComprehensionFor</p>
      <p>ComprehensionFor <b>:</b></p>
      <p><b>for</b><b> (</b> LeftHandSideExpression <b>of</b><b> </b>Expression <b>)</b></p>
      <h2>11.1.8<span>	The Grouping Operato</span>r</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>PrimaryExpression <b>:</b><i> </i><b>(</b> Expression <b>)</b> </p>
      <p>Return the result of evaluating <i>Expression</i>. This may be of type Reference.</p>
      <p>NOTE<span>	This algorithm does not apply GetValue to the result of evaluating Expression. The principal motivation for this is so that operators such as </span><b>delete</b> and <b>typeof</b> may be applied to parenthesised expressions.</p>
      <h2>11.2<span>	Left-Hand-Side Expression</span>s</h2>
      <p>Syntax</p>
      <p>MemberExpression <b>:</b></p>
      <p>PrimaryExpression<span><br>MemberExpression </span><b>[</b> Expression <b>]</b><b><br></b>MemberExpression <b>.</b> IdentifierName<br>MemberExpression <b>&lt;|</b> TriangleLiteral<br><b>super</b><b> </b><b>[</b> Expression <b>]</b><br><b>super</b><b> </b><b>.</b> IdentifierName<br><b>new</b> MemberExpression<b> </b>Arguments</p>
      <p>NewExpression <b>:</b></p>
      <p>MemberExpression<b><br>new</b> NewExpression</p>
      <p>CallExpression <b>:</b></p>
      <p>MemberExpression<b> </b>Arguments<b><br></b><b>super </b>Arguments<b><br></b>CallExpression<b> </b>Arguments<b><br></b>CallExpression <b>[</b> Expression <b>]</b><b><br></b>CallExpression <b>.</b> IdentifierName<b> </b><b><br></b>CallExpression <b>&lt;|</b> TriangleLiteral</p>
      <p>Arguments <b>:</b></p>
      <p><b>(</b> <b>)</b><b><br>(</b> ArgumentList  <b>)</b></p>
      <p>ArgumentList <b>:</b></p>
      <p>AssignmentExpression<br><b>... </b>AssignmentExpression<span><br>ArgumentList </span><b>,</b> AssignmentExpression<span><br>ArgumentList </span><b>,</b> <b>... </b>AssignmentExpression</p>
      <p>TriangleLiteral <b>:</b></p>
      <p>SealedArrayLiteral<span><br>SealedObjectLiteral</span><span><br>FunctionExpression</span><span><br>ValueLiteral</span></p>
      <p>LeftHandSideExpression <b>:</b></p>
      <p>NewExpression<span><br>CallExpression</span></p>
      <h2>11.2.1<span>	Property Accessor</span>s</h2>
      <p>Properties are accessed by name, using either the dot notation:</p>
      <p>MemberExpression <b>.</b> IdentifierName<span><br>CallExpression </span><b>.</b> IdentifierName</p>
      <p>or the bracket notation:</p>
      <p>MemberExpression <b>[</b> Expression <b>]</b><span><br>CallExpression </span><b>[</b> Expression <b>]</b></p>
      <p>The dot notation is explained by the following syntactic conversion:</p>
      <p>MemberExpression <b>.</b> IdentifierName</p>
      <p>is identical in its behaviour to</p>
      <p>MemberExpression <b>[</b> &lt;identifier-name-string&gt; <b>]</b></p>
      <p>and similarly</p>
      <p>CallExpression <b>.</b> IdentifierName</p>
      <p>is identical in its behaviour to</p>
      <p>CallExpression <b>[</b> &lt;identifier-name-string&gt; <b>]</b></p>
      <p>where &lt;identifier-name-string&gt; is a string literal containing the same sequence of characters after processing of Unicode escape sequences as the IdentifierName.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>MemberExpression <b>:</b> MemberExpression <b>[</b> Expression <b>]</b> </p>
      <p>Let <i>baseReference</i> be the result of evaluating <i>MemberExpression</i>.</p>
      <p>Let <i>baseValue</i> be GetValue(<i>baseReference</i>).</p>
      <p>If <i>baseValue</i> is an abrupt completion, return <i>baseValue</i>.</p>
      <p>Let <i>propertyNameReference</i> be the result of evaluating <i>Expression</i>.</p>
      <p>Let <i>propertyNameValue</i> be GetValue(<i>propertyNameReference</i>).</p>
      <p>If <i>propertyNameValue</i> is an abrupt completion, return <i>propertyNameValue</i>.</p>
      <p>If the result of CheckObjectCoercible(<i>baseValue</i>) is an abrupt completion, return that result.</p>
      <p>Let <i>propertyNameString</i> be ToString(<i>propertyNameValue</i>).</p>
      <p>If the code matched by the syntactic production that is being evaluated is strict mode code, let <i>strict</i> be <b>true</b>, else let <i>strict</i> be <b>false</b>.</p>
      <p>Return a value of type Reference whose base value is <i>baseValue</i> and whose referenced name is <i>propertyNameString</i>, and whose strict mode flag is <i>strict</i>.</p>
      <p>CallExpression <b>:</b><i> </i>CallExpression<i> </i><b>[</b><i> </i>Expression<i> </i><b>]</b> </p>
      <p>Is evaluated in exactly the same manner as MemberExpression <b>:</b> MemberExpression <b>[</b> Expression <b>]</b> except that the contained CallExpression is evaluated in step 1.</p>
      <h2>11.2.2<span>	The </span>new Operator</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>NewExpression<i> </i><b>:</b><i> </i><b>new</b><i> </i>NewExpression<i> </i></p>
      <p>Let <i>ref</i> be the result of evaluating <i>NewExpression</i>.</p>
      <p>Let <i>constructor</i> be GetValue(<i>ref</i>).</p>
      <p>If <i>constructor</i> is an abrupt completion, return <i>constructor</i>.</p>
      <p>If Type(<i>constructor</i>) is not Object, throw a <b>TypeError</b> exception.</p>
      <p>If <i>constructor</i> does not implement the [[Construct]] internal method, throw a <b>TypeError</b> exception.</p>
      <p>Return the result of calling the [[Construct]] internal method on <i>constructor</i>, providing no arguments (that is, an empty list of arguments).</p>
      <p>MemberExpression <b>:</b> <b>new</b> MemberExpression Arguments </p>
      <p>Let <i>ref</i> be the result of evaluating <i>MemberExpression</i>.</p>
      <p>Let <i>constructor</i> be GetValue(<i>ref</i>).</p>
      <p>If <i>constructor</i> is an abrupt completion, return <i>constructor</i>.</p>
      <p>Let <i>argList</i> be the result of evaluating <i>Arguments</i>, producing an internal list of argument values (11.2.4).</p>
      <p>If <i>argList</i> is an abrupt completion, return <i>argList</i>.</p>
      <p>If Type(<i>constructor</i>) is not Object, throw a <b>TypeError</b> exception.</p>
      <p>If <i>constructor</i> does not implement the [[Construct]] internal method, throw a <b>TypeError</b> exception.</p>
      <p>Return the result of calling the [[Construct]] internal method on <i>constructor</i>, providing the list <i>argList</i> as the argument values.</p>
      <h2>11.2.3<span>	Function Call</span>s</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>CallExpression <b>:</b> MemberExpression Arguments </p>
      <p>Let <i>ref</i> be the result of evaluating <i>MemberExpression</i>.</p>
      <p>Let <i>func</i> be GetValue(<i>ref</i>).</p>
      <p>If <i>func</i> is an abrupt completion, return <i>func</i>.</p>
      <p>Let <i>argList</i> be the result of evaluating <i>Arguments</i>, producing an internal list of argument values (see 11.2.4).</p>
      <p>If <i>argList</i> is an abrupt completion, return <i>argList</i>.</p>
      <p>If Type(<i>func</i>) is not Object, throw a <b>TypeError</b> exception.</p>
      <p>If IsCallable(<i>func</i>) is <b>false</b>, throw a <b>TypeError</b> exception.</p>
      <p>If Type(<i>ref</i>) is Reference, then</p>
      <p>If IsPropertyReference(<i>ref</i>) is <b>true</b>, then</p>
      <p>Let <i>thisValue</i> be GetBase(<i>ref</i>).</p>
      <p>Else, the base of <i>ref</i> is an Environment Record</p>
      <p>Let <i>thisValue</i> be the result of calling the ImplicitThisValue concrete method of GetBase(<i>ref</i>).</p>
      <p>Else, Type(<i>ref</i>) is not Reference.</p>
      <p>Let <i>thisValue</i> be <b>undefined</b>.</p>
      <p>Return the result of calling the [[Call]] internal method on <i>func</i>, providing <i>thisValue</i> as the <b>this</b> value and providing the list <i>argList</i> as the argument values.</p>
      <p>CallExpression <b>:</b> CallExpression Arguments </p>
      <p>This is evaluated in exactly the same manner as CallExpression <b>:</b> MemberExpression Arguments except that the contained CallExpression is evaluated in step 1.</p>
      <p>NOTE<span>	The returned result will never be of type Reference if </span><i>func</i> is a native ECMAScript object. Whether calling a host object can return a value of type Reference is implementation-dependent. If a value of type Reference is returned, it must be a non-strict Property Reference.</p>
      <h2>11.2.4	The super Keyword</h2>
      <p>
        <b>Static </b>
        <b>Semantics</b>
      </p>
      <p>
        <b>Static Semantics:  Early Errors</b>
      </p>
      <p>MemberExpression <b>:</b></p>
      <p><b>super [</b> Expression <b>]</b><br><b>super .</b> IdentifierName</p>
      <p>It is a Syntax Error if the source code parsed with this production is global code that is not eval code.</p>
      <p>It is a Syntax Error if the source code parsed with this production is eval code and the source code is not being processed by a direct call to eval that is contained in function code.</p>
      <p>CallExpression <b>:</b> <b>super</b><span style="font-weight: bold; font-style: italic"> </span><i>Arguments</i></p>
      <p>It is a Syntax Error if the source code parsed with this production is global code that is not eval code.</p>
      <p>It is a Syntax Error if the source code parsed with this production is eval code and the source code is not being processed by a direct call to eval that is contained in function code.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>MemberExpression <b>:</b> <b>super</b><span style="font-weight: bold; font-style: italic"> </span><b>[</b> <i>Expression</i> <b>]</b> </p>
      <p>Let <i>baseReference</i> be the result of evaluating <i>MemberExpression</i>.</p>
      <p>Let <i>baseValue</i> be GetValue(<i>baseReference</i>).</p>
      <p>Let <i>propertyNameReference</i> be the result of evaluating <i>Expression</i>.</p>
      <p>Let <i>propertyNameValue</i> be GetValue(<i>propertyNameReference</i>).</p>
      <p>Call CheckObjectCoercible(<i>baseValue</i>).</p>
      <p>Let <i>propertyNameString</i> be ToString(<i>propertyNameValue</i>).</p>
      <p>If the code matched by the syntactic production that is being evaluated is strict mode code, let <i>strict</i> be <b>true</b>, else let <i>strict</i> be <b>false</b>.</p>
      <p>Return a value of type Reference whose base value is <i>baseValue</i> and whose referenced name is <i>propertyNameString</i>, and whose strict mode flag is <i>strict</i>.</p>
      <h2>11.2.5<span>	Argument List</span>s</h2>
      <p>The evaluation of an argument list produces a List of values (see 8.7).</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p><i>Arguments </i><b>:</b> <b>( )</b> </p>
      <p>Return an empty List.</p>
      <p>Arguments<i> </i><b>:</b><i> </i><b>( </b>ArgumentList<b> )</b> </p>
      <p>Return the result of evaluating <i>ArgumentList</i>.</p>
      <p>ArgumentList<i> </i><b>:</b><b> </b>AssignmentExpression<b> </b></p>
      <p>Let <i>ref</i> be the result of evaluating <i>AssignmentExpression</i>.</p>
      <p>Let <i>arg</i> be GetValue(<i>ref</i>).</p>
      <p>If <i>arg</i> is an abrupt completion, return <i>arg</i>.</p>
      <p>Return a List whose sole item is <i>arg</i>.</p>
      <p>ArgumentList <b>:</b> <span style="font-weight: bold; font-style: italic">… </span>AssignmentExpression  </p>
      <p>Let <i>list </i>be an empty List.</p>
      <p>Let <i>spreadRef </i>be the result of evaluating <i>AssignmentExpression</i>.</p>
      <p>Let <i>spreadValue </i>be GetValue(<i>spreadRef</i>).</p>
      <p>Let <i>spreadObj</i> be ToObject(<i>spreadValue</i>).</p>
      <p>If <i>spreadObj</i> is an abrupt completion, return <i>spreadObj</i>.</p>
      <p>Let <i>lenVal</i> be the result of calling the [[Get]] internal method of <i>spreadObj</i> with argument “<b>length</b>”.</p>
      <p>Let <i>spreadLen</i> be ToUint32(<i>lenVal</i>).</p>
      <p>Let <i>n </i>= 0.</p>
      <p>Repeat, while <i>n</i> &lt; <i>spreadLen</i></p>
      <p>Let <i>nextArg</i> be the result of calling the [[Get]] internal method of <i>spreadObj</i> passing ToString(<i>n</i>) as the argument.</p>
      <p>Append <i>nextArg</i> as the last element of <i>list</i>.</p>
      <p>Let <i>n</i> = <i>n</i>+1.</p>
      <p>Return <i>list</i>.</p>
      <p>ArgumentList<i> </i><b>:</b><b> </b>ArgumentList<b> , </b>AssignmentExpression<b> </b></p>
      <p>Let <i>precedingArgs</i> be the result of evaluating <i>ArgumentList</i>.</p>
      <p>If <i>precedingArgs</i> is an abrupt completion, return <i>precedingArgs</i>.</p>
      <p>Let <i>ref</i> be the result of evaluating <i>AssignmentExpression</i>.</p>
      <p>Let <i>arg</i> be GetValue(<i>ref</i>).</p>
      <p>If <i>arg</i> is an abrupt completion, return <i>arg</i>.</p>
      <p>Return a List whose length is one greater than the length of <i>precedingArgs</i> and whose items are the items of <i>precedingArgs</i>, in order, followed at the end by <i>arg</i> which is the last item of the new list.</p>
      <p>ArgumentList <b>:</b> ArgumentList<b> , </b><span style="font-weight: bold; font-style: italic">… </span>AssignmentExpression  </p>
      <p>Let <i>precedingArgs</i> be an empty List.</p>
      <p>Let <i>spreadRef </i>be the result of evaluating <i>AssignmentExpression</i>.</p>
      <p>Let <i>spreadValue </i>be GetValue(<i>spreadRef</i>).</p>
      <p>Let <i>spreadObj</i> be ToObject(<i>spreadValue</i>).</p>
      <p>If <i>spreadObj</i> is an abrupt completion, return <i>spreadObj</i>.</p>
      <p>Let <i>lenVal</i> be the result of calling the [[Get]] internal method of <i>spreadObj</i> with argument “<b>length</b>”.</p>
      <p>Let <i>spreadLen</i> be ToUint32(<i>lenVal</i>).</p>
      <p>Let <i>n </i>= 0.</p>
      <p>Repeat, while <i>n</i> &lt; <i>spreadLen</i></p>
      <p>Let <i>nextArg</i> be the result of calling the [[Get]] internal method of <i>spreadObj</i> passing ToString(<i>n</i>) as the argument.</p>
      <p>Append <i>nextArg</i> as the last element of <i>precedingArgs</i>.</p>
      <p>Let <i>n</i> = <i>n</i>+1.</p>
      <p>Return <i>precedingArgs</i>.</p>
      <h2>11.3<span>	Postfix Expression</span>s</h2>
      <p>Syntax</p>
      <p>PostfixExpression <b>:</b></p>
      <p>LeftHandSideExpression<span><br>LeftHandSideExpression</span><b> </b>[no LineTerminator here]<b> ++</b><span><br>LeftHandSideExpression</span><b> </b>[no LineTerminator here]<b> --</b></p>
      <p>
        <b>Static Semantics</b>
      </p>
      <p>
        <b>Static Semantics:  </b>
        <b>Early Errors</b>
      </p>
      <p>PostfixExpression <b>:</b></p>
      <p>LeftHandSideExpression<b> </b>[no LineTerminator here]<b> ++</b><span><br>LeftHandSideExpression</span><b> </b>[no LineTerminator here]<b> --</b></p>
      <p>It is a Syntax Error if the PostfixExpression is contained in strict code and LeftHandSideExpression is the Identifier <b>eval</b> or the Identifier <b>arguments</b>.</p>
      <p>It is a Syntax Error if the LeftHandSideExpression is PrimaryExpression : <b>(</b> Expression<b> ) </b>and Expression derived a production that if used in place of LeftHandSideExpression would produce a Syntax Error according to these rules. This rule is recursively applied.</p>
      <h2>11.3.1<span>	Postfix Increment Operato</span>r</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>PostfixExpression <b>:</b> LeftHandSideExpression [no <i>LineTerminator</i> here] <b>++ </b></p>
      <p>Let <i>lhs</i> be the result of evaluating <i>LeftHandSideExpression</i>.</p>
      <p>Let <i>oldValue</i> be ToNumber(GetValue(<i>lhs</i>)).</p>
      <p>If <i>oldValue</i> is an abrupt completion, return <i>oldValue</i>.</p>
      <p>Let <i>newValue</i> be the result of adding the value <b>1</b> to <i>oldValue</i>, using the same rules as for the <b>+</b> operator (see 11.6.3).</p>
      <p>If  PutValue(<i>lhs</i>, <i>newValue</i>) is an abrupt completion, return that Completion Record.</p>
      <p>Return <i>oldValue</i>.</p>
      <h2>11.3.2<span>	Postfix Decrement Operato</span>r</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>PostfixExpression <b>:</b> LeftHandSideExpression [no<i> </i><i>LineTerminator</i><i> </i>here] <b>-- </b></p>
      <p>Let <i>lhs</i> be the result of evaluating <i>LeftHandSideExpression</i>.</p>
      <p>Let <i>oldValue</i> be ToNumber(GetValue(<i>lhs</i>)).</p>
      <p>Let <i>newValue</i> be the result of subtracting the value <b>1</b> from <i>oldValue</i>, using the same rules as for the <b>-</b> operator (11.6.3).</p>
      <p>If  Call PutValue(<i>lhs</i>, <i>newValue</i>) ) is an abrupt completion, return that Completion Record.</p>
      <p>Return <i>oldValue</i>.</p>
      <h2>11.4<span>	Unary Operator</span>s</h2>
      <p>Syntax</p>
      <p>UnaryExpression <b>:</b></p>
      <p>PostfixExpression<b><br>delete </b>UnaryExpression<br><b>void </b>UnaryExpression<br><b>typeof </b>UnaryExpression<b><br>++</b> UnaryExpression<br><b>--</b> UnaryExpression<br><b>+</b> UnaryExpression<br><b>-</b> UnaryExpression<br><b>~</b> UnaryExpression<br><b>!</b> UnaryExpression</p>
      <p>
        <b>Static Semantics</b>
      </p>
      <p>
        <b>Static Semantics:  </b>
        <b>Early Errors</b>
      </p>
      <p>UnaryExpression <b>:</b></p>
      <p><b>delete </b>UnaryExpression<br><b>++</b> UnaryExpression<br><b>--</b> UnaryExpression</p>
      <p>It is a Syntax Error if the UnaryExpression is contained in strict code and the derived UnaryExpression is the Identifier <b>eval</b> or the Identifier <b>arguments</b>.</p>
      <p>It is a Syntax Error if the derived UnaryExpression is PrimaryExpression : <b>(</b> Expression<b> ) </b>and Expression derived a production that if used in place of LeftHandSideExpression would produce a Syntax Error according to these rules. This rule is recursively applied.</p>
      <h2>11.4.1<span>	The </span>delete Operator</h2>
      <p>
        <b>Static Semantics:  Early Errors</b>
      </p>
      <p>UnaryExpression <b>:</b> <b>delete</b><i> UnaryExpression</i> </p>
      <p>It is a Syntax Error if the UnaryExpression is contained in strict code and the UnaryExpression derives an Identifier that statically resolves to a environment record.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>UnaryExpression <b>:</b> <b>delete</b><i> UnaryExpression</i> </p>
      <p>Let <i>ref </i>be the result of evaluating <i>UnaryExpression</i>.</p>
      <p>If <i>ref </i>is an abrupt completion, return <i>ref</i>.</p>
      <p>If Type(<i>ref</i>) is not Reference, return <b>true</b>.</p>
      <p>If IsUnresolvableReference(<i>ref</i>) is <b>true</b>, then,</p>
      <p>If IsStrictReference(<i>ref</i>) is <b>true</b>, throw a <b>SyntaxError</b> exception.</p>
      <p>Else, return <b>true</b>.</p>
      <p>If IsPropertyReference(<i>ref</i>) is <b>true</b>, then</p>
      <p>Return the result of calling the [[Delete]] internal method on ToObject(GetBase(<i>ref)</i>) providing GetReferencedName(<i>ref</i>) and IsStrictReference(<i>ref</i>) as the arguments.</p>
      <p>Else, <i>ref</i> is a Reference to an Environment Record binding, so</p>
      <p>Let <i>bindings</i> be GetBase(<i>ref</i>).</p>
      <p>Return the result of calling the DeleteBinding concrete method of <i>bindings</i>, providing GetReferencedName(<i>ref</i>) as the argument.</p>
      <p>NOTE<span>	When a </span><b>delete</b> operator occurs within strict mode code, a <b>SyntaxError</b> exception is thrown if its UnaryExpression is a direct reference to a variable, function argument, or function name. In addition, if a <b>delete</b> operator occurs within strict mode code and the property to be deleted has the attribute { [[Configurable]]: <b>false</b> }, a <b>TypeError </b>exception is thrown.</p>
      <h2>11.4.2<span>	The </span>void Operator</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>UnaryExpression <b>:</b> <b>void</b> UnaryExpression </p>
      <p>Let <i>expr</i> be the result of evaluating <i>UnaryExpression</i>.</p>
      <p>Call GetValue(<i>expr</i>).</p>
      <p>If <i>ref </i>is an abrupt completion, return <i>ref</i>.</p>
      <p>Return <b>undefined</b>.</p>
      <p>NOTE<span>	GetValue must be called even though its value is not used because it may have observable side-effects.</span></p>
      <h2>11.4.3<span>	The </span>typeof Operator</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>UnaryExpression <b>:</b> <b>typeof</b><i> </i>UnaryExpression </p>
      <p>Let <i>val </i>be the result of evaluating <i>UnaryExpression</i>.</p>
      <p>If Type(<i>val</i>) is Reference, then</p>
      <p>If IsUnresolvableReference(<i>val</i>) is <b>true</b>, return <b>"undefined"</b>.</p>
      <p>Let <i>val </i>be GetValue(<i>val</i>).</p>
      <p>If <i>val </i>is an abrupt completion, return <i>val</i>.</p>
      <p>Return a String determined by Type(<i>val</i>) according to Table 21.</p>
      <p>Table 21 — typeof Operator Results</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Type</span>
                <span style="font-weight: bold; font-style: italic"> of </span>
                <i>val</i>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Result</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Undefined</p>
            </td>
            <td>
              <p>
                <b>"undefine</b>
                <b>d"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Null</p>
            </td>
            <td>
              <p>
                <b>"objec</b>
                <b>t"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Boolean</p>
            </td>
            <td>
              <p>
                <b>"boolea</b>
                <b>n"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Number</p>
            </td>
            <td>
              <p>
                <b>"numbe</b>
                <b>r"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>String</p>
            </td>
            <td>
              <p>
                <b>"strin</b>
                <b>g"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Object (native and does not implement [[Call]])</p>
            </td>
            <td>
              <p>
                <b>"objec</b>
                <b>t"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Object (native or host and does implement [[Call]])</p>
            </td>
            <td>
              <p>
                <b>"functio</b>
                <b>n"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>Object (host and does not implement [[Call]])</p>
            </td>
            <td>
              <p>Implementation-defined except may not be <b>"undefined"</b>, <b>"boolean"</b>, <b>"number</b>", or<b> "string".</b></p>
            </td>
          </tr>
        </table>
      </figure>
      <h2>11.4.4<span>	Prefix Increment Operato</span>r</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>UnaryExpression<i> </i><b>:</b><i> </i><b>++ </b>UnaryExpression </p>
      <p>Let <i>expr</i> be the result of evaluating UnaryExpression.</p>
      <p>Let <i>oldValue</i> be ToNumber(GetValue(<i>expr</i>)).</p>
      <p>If <i>oldValue</i> is an abrupt completion, return <i>oldValue</i>.</p>
      <p>Let <i>newValue</i> be the result of adding the value <b>1</b> to <i>oldValue</i>, using the same rules as for the <b>+</b> operator (see 11.6.3).</p>
      <p>If PutValue(<i>expr</i>, <i>newValue</i>) is an abrupt completion, return that Completion Record.</p>
      <p>Return <i>newValue</i>.</p>
      <h2>11.4.5<span>	Prefix Decrement Operato</span>r</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>UnaryExpression<i> </i><b>:</b><i> </i><b>-- </b>UnaryExpression </p>
      <p>Let <i>expr</i> be the result of evaluating UnaryExpression.</p>
      <p>Let <i>oldValue</i> be ToNumber(GetValue(<i>expr</i>)).</p>
      <p>If <i>oldValue</i> is an abrupt completion, return <i>oldValue</i>.</p>
      <p>Let <i>newValue</i> be the result of  subtracting the value <b>1</b> from <i>oldValue</i>, using the same rules as for the <b>-</b> operator (see 11.6.3).</p>
      <p>If PutValue(<i>expr</i>, <i>newValue</i>) is an abrupt completion, return that Completion Record.</p>
      <p>Return <i>newValue</i>.</p>
      <h2>11.4.6<span>	Unary </span>+ Operator</h2>
      <p>NOTE	The unary + operator converts its operand to Number type.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>UnaryExpression<i> </i><b>:</b><i> </i><b>+</b> UnaryExpression </p>
      <p>Let <i>expr</i> be the result of evaluating UnaryExpression.</p>
      <p>Return ToNumber(GetValue(<i>expr</i>)).</p>
      <h2>11.4.7<span>	Unary </span>- Operator</h2>
      <p>NOTE	The unary <b>-</b> operator converts its operand to Number type and then negates it. Negating <b>+0</b> produces <b>−</b><b>0</b>, and negating <b>−</b><b>0</b> produces <b>+0</b>.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>UnaryExpression<i> </i><b>:</b><i> </i><b>-</b> UnaryExpression </p>
      <p>Let <i>expr</i> be the result of evaluating UnaryExpression.</p>
      <p>Let <i>oldValue</i> be ToNumber(GetValue(<i>expr</i>)).</p>
      <p>If <i>oldValue</i> is an abrupt completion, return <i>oldValue</i>.</p>
      <p>If <i>oldValue</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return the result of negating <i>oldValue</i>; that is, compute a Number with the same magnitude but opposite sign.</p>
      <h2>11.4.8<span>	Bitwise NOT Operator ( </span>~ )</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>UnaryExpression<i> </i><b>:</b><i> </i><b>~</b> UnaryExpression </p>
      <p>Let <i>expr</i> be the result of evaluating <i>UnaryExpression</i>.</p>
      <p>Let <i>oldValue</i> be ToInt32(GetValue(<i>expr</i>)).</p>
      <p>If <i>oldValue</i> is an abrupt completion, return <i>oldValue</i>.</p>
      <p>Return the result of applying bitwise complement to <i>oldValue</i>. The result is a signed 32-bit integer.</p>
      <h2>11.4.9<span>	Logical NOT Operator ( </span>! )</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>UnaryExpression<i> </i><b>:</b><i> </i><b>!</b> UnaryExpression </p>
      <p>Let <i>expr</i> be the result of evaluating <i>UnaryExpression</i>.</p>
      <p>Let <i>oldValue</i> be ToBoolean(GetValue(<i>expr</i>)).</p>
      <p>If <i>oldValue</i> is an abrupt completion, return <i>oldValue</i>.</p>
      <p>If <i>oldValue</i> is <b>true</b>, return <b>false</b>.</p>
      <p>Return <b>true</b>.</p>
      <h2>11.5<span>	Multiplicative Operator</span>s</h2>
      <p>Syntax</p>
      <p>MultiplicativeExpression <b>:</b></p>
      <p>UnaryExpression<span><br>MultiplicativeExpression </span><b>*</b> UnaryExpression<span><br>MultiplicativeExpression </span><b>/</b> UnaryExpression<span><br>MultiplicativeExpression </span><b>%</b> UnaryExpression</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>The production <i>MultiplicativeExpression </i><b>:</b><i> </i>MultiplicativeExpression<i> @ </i>UnaryExpression, where @ stands for one of the operators in the above definitions, is evaluated as follows:</p>
      <p>Let <i>left</i> be the result of evaluating MultiplicativeExpression.</p>
      <p>Let <i>leftValue</i> be GetValue(<i>left</i>).</p>
      <p>If <i>leftValue</i> is an abrupt completion, return <i>leftValue</i>.</p>
      <p>Let <i>right</i> be the result of evaluating UnaryExpression.</p>
      <p>Let <i>rightValue</i> be GetValue(<i>right</i>).</p>
      <p>Let <i>leftNum</i> be ToNumber(<i>leftValue</i>).</p>
      <p>If <i>leftNum</i> is an abrupt completion, return <i>leftNum</i>.</p>
      <p>Let <i>rightNum</i> be ToNumber(<i>rightValue</i>).</p>
      <p>If <i>rightNum</i> is an abrupt completion, return <i>rightNum</i>.</p>
      <p>Return the result of applying the specified operation (*, /, or %) to <i>leftNum</i> and <i>rightNum</i>. See the Notes below 11.5.1, 11.5.2, 11.5.3.</p>
      <h2>11.5.1<span>	Applying the </span>* Operator</h2>
      <p>The <b>*</b><b> </b>operator performs multiplication, producing the product of its operands. Multiplication is commutative. Multiplication is not always associative in ECMAScript, because of finite precision.</p>
      <p>The result of a floating-point multiplication is governed by the rules of IEEE 754 binary double-precision arithmetic:</p>
      <p>If either operand is <b>NaN</b>, the result is <b>NaN</b>.</p>
      <p>The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.</p>
      <p>Multiplication of an infinity by a zero results in <b>NaN</b>.</p>
      <p>Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.</p>
      <p>Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above.</p>
      <p>In the remaining cases, where neither an infinity or NaN is involved, the product is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the result is then a zero of appropriate sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754.</p>
      <h2>11.5.2<span>	Applying the </span>/ Operator</h2>
      <p>The <b>/</b> operator performs division, producing the quotient of its operands. The left operand is the dividend and the right operand is the divisor. ECMAScript does not perform integer division. The operands and result of all division operations are double-precision floating-point numbers. The result of division is determined by the specification of IEEE 754 arithmetic:</p>
      <p>If either operand is <b>NaN</b>, the result is <b>NaN</b>.</p>
      <p>The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.</p>
      <p>Division of an infinity by an infinity results in <b>NaN</b>.</p>
      <p>Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.</p>
      <p>Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above.</p>
      <p>Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.</p>
      <p>Division of a zero by a zero results in <b>NaN</b>; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.</p>
      <p>Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.</p>
      <p>In the remaining cases, where neither an infinity, nor a zero, nor <b>NaN</b> is involved, the quotient is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the operation underflows and the result is a zero of the appropriate sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754.</p>
      <h2>11.5.3<span>	Applying the </span>% Operator</h2>
      <p>The <b>%</b> operator yields the remainder of its operands from an implied division; the left operand is the dividend and the right operand is the divisor.</p>
      <p>NOTE<span>	In C and C++, the remainder operator accepts only integral operands; in ECMAScript, it also accepts floating-point operands.</span></p>
      <p>The result of a floating-point remainder operation as computed by the <b>%</b> operator is not the same as the “remainder” operation defined by IEEE 754. The IEEE 754 “remainder” operation computes the remainder from a rounding division, not a truncating division, and so its behaviour is not analogous to that of the usual integer remainder operator. Instead the ECMAScript language defines <b>%</b> on floating-point operations to behave in a manner analogous to that of the Java integer remainder operator; this may be compared with the C library function fmod.</p>
      <p>The result of an ECMAScript floating-point remainder operation is determined by the rules of IEEE arithmetic:</p>
      <p>If either operand is <b>NaN</b>, the result is <b>NaN</b>.</p>
      <p>The sign of the result equals the sign of the dividend.</p>
      <p>If the dividend is an infinity, or the divisor is a zero, or both, the result is <b>NaN</b>.</p>
      <p>If the dividend is finite and the divisor is an infinity, the result equals the dividend.</p>
      <p>If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.</p>
      <p>In the remaining cases, where neither an infinity, nor a zero, nor <b>NaN</b> is involved, the floating-point remainder r from a dividend n and a divisor d is defined by the mathematical relation r = n − (d × q) where q is an integer that is negative only if n/d is negative and positive only if n/d is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of n and d. r is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode.</p>
      <h2>11.6<span>	Additive Operators</span></h2>
      <p>Syntax</p>
      <p>AdditiveExpression <b>:</b></p>
      <p>MultiplicativeExpression<br>AdditiveExpression <b>+</b> MultiplicativeExpression<br>AdditiveExpression <b>-</b> MultiplicativeExpression</p>
      <h2>11.6.1<span>	The Addition operator ( </span>+ )</h2>
      <p>NOTE	The addition operator either performs string concatenation or numeric addition.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>AdditiveExpression <b>:</b> AdditiveExpression <b>+</b> MultiplicativeExpression </p>
      <p>Let <i>lref</i> be the result of evaluating AdditiveExpression.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating MultiplicativeExpression.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>If <i>rval</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>Let <i>lprim</i> be ToPrimitive(<i>lval</i>).</p>
      <p>If <i>lprim</i> is an abrupt completion, return <i>lprim</i>.</p>
      <p>Let <i>rprim</i> be ToPrimitive(<i>rval</i>).</p>
      <p>If <i>rprim</i> is an abrupt completion, return <i>rprim</i>.</p>
      <p>If Type(<i>lprim</i>) is String or Type(<i>rprim</i>) is String, then </p>
      <p>Return the String that is the result of concatenating ToString(<i>lprim</i>) followed by ToString(<i>rprim</i>)</p>
      <p>Return the result of applying the addition operation to ToNumber(<i>lprim</i>) and ToNumber(<i>rprim</i>). See the Note below 11.6.3.</p>
      <p>NOTE 1<span>	No hint is provided in the calls to ToPrimitive in steps 5 and 6. All native ECMAScript objects except Date objects handle the absence of a hint as if the hint Number were given; Date objects handle the absence of a hint as if the hint String were given. Host objects may handle the absence of a hint in some other manner.</span></p>
      <p>NOTE 2<span>	Step 7 differs from step 3 of the comparison algorithm for the relational operators (11.8.</span>1), by using the logical-or operation instead of the logical-and operation.</p>
      <h2>11.6.2<span>	The Subtraction Operator ( </span>- )</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>AdditiveExpression <b>:</b> AdditiveExpression <b>-</b> MultiplicativeExpression </p>
      <p>Let <i>lref</i> be the result of evaluating AdditiveExpression.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating MultiplicativeExpression.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>If <i>rval</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>Let <i>lnum</i> be ToNumber(<i>lval</i>).</p>
      <p>If <i>lnum</i> is an abrupt completion, return <i>lnum</i>.</p>
      <p>Let <i>rnum</i> be ToNumber(<i>rval</i>).</p>
      <p>If <i>rnum</i> is an abrupt completion, return <i>rnum</i>.</p>
      <p>Return the result of applying the subtraction operation to <i>lnum</i> and <i>rnum</i>. See the note below 11.6.3.</p>
      <h2>11.6.3<span>	Applying the Additive Operators to Number</span>s</h2>
      <p>The <b>+</b> operator performs addition when applied to two operands of numeric type, producing the sum of the operands. The <b>-</b> operator performs subtraction, producing the difference of two numeric operands.</p>
      <p>Addition is a commutative operation, but not always associative.</p>
      <p>The result of an addition is determined using the rules of IEEE 754 binary double-precision arithmetic:</p>
      <p>If either operand is <b>NaN</b>, the result is <b>NaN</b>.</p>
      <p>The sum of two infinities of opposite sign is <b>NaN</b>.</p>
      <p>The sum of two infinities of the same sign is the infinity of that sign.</p>
      <p>The sum of an infinity and a finite value is equal to the infinite operand.</p>
      <p>The sum of two negative zeroes is <b>−</b><b>0</b>. The sum of two positive zeroes, or of two zeroes of opposite sign, is <b>+0</b>.</p>
      <p>The sum of a zero and a nonzero finite value is equal to the nonzero operand.</p>
      <p>The sum of two nonzero finite values of the same magnitude and opposite sign is <b>+0</b>.</p>
      <p>In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, and the operands have the same sign or have different magnitudes, the sum is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the operation overflows and the result is then an infinity of appropriate sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754.</p>
      <p>The <b>-</b> operator performs subtraction when applied to two operands of numeric type, producing the difference of its operands; the left operand is the minuend and the right operand is the subtrahend. Given numeric operands <i>a</i> and <i>b</i>, it is always the case that <i>a</i><i>–</i><i>b</i> produces the same result as <i>a </i><i>+(–</i><i>b</i><i>)</i>.</p>
      <h2>11.7<span>	Bitwise Shift Operator</span>s</h2>
      <p>Syntax</p>
      <p>ShiftExpression <b>:</b></p>
      <p>AdditiveExpression<br>ShiftExpression <b>&lt;&lt;</b> AdditiveExpression<br>ShiftExpression <b>&gt;&gt;</b> AdditiveExpression<br>ShiftExpression <b>&gt;&gt;&gt;</b> AdditiveExpression</p>
      <h2>11.7.1<span>	The Left Shift Operator ( </span>&lt;&lt; )</h2>
      <p>NOTE	Performs a bitwise left shift operation on the left operand by the amount specified by the right operand.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>ShiftExpression <b>:</b> ShiftExpression <b>&lt;&lt;</b> AdditiveExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>ShiftExpression</i>.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>AdditiveExpression</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>If <i>rval</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>Let <i>lnum</i> be ToInt32(<i>lval</i>).</p>
      <p>If <i>lnum</i> is an abrupt completion, return <i>lnum</i>.</p>
      <p>Let <i>rnum</i> be ToUint32(<i>rval</i>).</p>
      <p>If <i>rnum</i> is an abrupt completion, return <i>rnum</i>.</p>
      <p>Let <i>shiftCount</i> be the result of masking out all but the least significant 5 bits of <i>rnum</i>, that is, compute <i>rnum</i> &amp; 0x1F.</p>
      <p>Return the result of left shifting <i>lnum</i> by <i>shiftCount</i> bits. The result is a signed 32-bit integer.</p>
      <h2>11.7.2<span>	The Signed Right Shift Operator ( </span>&gt;&gt; )</h2>
      <p>NOTE	Performs a sign-filling bitwise right shift operation on the left operand by the amount specified by the right operand.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>ShiftExpression <b>:</b> ShiftExpression <b>&gt;&gt;</b> AdditiveExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>ShiftExpression</i>.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>AdditiveExpression</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>If <i>rval</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>Let <i>lnum</i> be ToInt32(<i>lval</i>).</p>
      <p>If <i>lnum</i> is an abrupt completion, return <i>lnum</i>.</p>
      <p>Let <i>rnum</i> be ToUint32(<i>rval</i>).</p>
      <p>If <i>rnum</i> is an abrupt completion, return <i>rnum</i>.</p>
      <p>Let <i>shiftCount</i> be the result of masking out all but the least significant 5 bits of <i>rnum</i>, that is, compute <i>rnum</i> &amp; 0x1F.</p>
      <p>Return the result of performing a sign-extending right shift of <i>lnum</i> by <i>shiftCount</i> bits. The most significant bit is propagated. The result is a signed 32-bit integer.</p>
      <h2>11.7.3<span>	The Unsigned Right Shift Operator ( </span>&gt;&gt;&gt; )</h2>
      <p>NOTE	Performs a zero-filling bitwise right shift operation on the left operand by the amount specified by the right operand.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>ShiftExpression <b>:</b> ShiftExpression <b>&gt;&gt;&gt;</b> AdditiveExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>ShiftExpression</i>.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>AdditiveExpression</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>If <i>rval</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>Let <i>lnum</i> be ToUint32(<i>lval</i>).</p>
      <p>If <i>lnum</i> is an abrupt completion, return <i>lnum</i>.</p>
      <p>Let <i>rnum</i> be ToUint32(<i>rval</i>).</p>
      <p>If <i>rnum</i> is an abrupt completion, return <i>rnum</i>.</p>
      <p>Let <i>shiftCount</i> be the result of masking out all but the least significant 5 bits of <i>rnum</i>, that is, compute <i>rnum</i> &amp; 0x1F.</p>
      <p>Return the result of performing a zero-filling right shift of <i>lnum</i> by <i>shiftCount</i> bits. Vacated bits are filled with zero. The result is an unsigned 32-bit integer.</p>
      <h2>11.8<span>	Relational Operator</span>s</h2>
      <p>NOTE<span>	The result of evaluating a relational operator is always of type Boolean, reflecting whether the relationship named by the operator holds between its two operands.</span></p>
      <p>Syntax</p>
      <p>RelationalExpression <b>:</b></p>
      <p>ShiftExpression<br>RelationalExpression <b>&lt;</b> ShiftExpression<br>RelationalExpression <b>&gt;</b> ShiftExpression<br>RelationalExpression <b>&lt;=</b> ShiftExpression<br>RelationalExpression <b>&gt;=</b> ShiftExpression<br>RelationalExpression <b>instanceof</b> ShiftExpression<br>RelationalExpression <b>in</b> ShiftExpression</p>
      <p>RelationalExpressionNoIn <b>:</b></p>
      <p>ShiftExpression<span><br>RelationalExpressionNoIn </span><b>&lt;</b> ShiftExpression<span><br>RelationalExpressionNoIn </span><b>&gt;</b> ShiftExpression<span><br>RelationalExpressionNoIn </span><b>&lt;=</b> ShiftExpression<span><br>RelationalExpressionNoIn </span><b>&gt;=</b> ShiftExpression<span><br>RelationalExpressionNoIn </span><b>instanceof</b> ShiftExpression</p>
      <p>The semantics of the RelationalExpressionNoIn productions are the same as the RelationalExpression productions except that the contained RelationalExpressionNoIn is used in place of the contained RelationalExpression.</p>
      <p>NOTE<span>	The “NoIn” variants are needed to avoid confusing the </span>in operator in a relational expression with the in operator in a for statement.</p>
      <h2>11.8.1 Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>The Abstract Relational Comparison Algorithm</b>
      </p>
      <p>The comparison <i>x</i> &lt; <i>y</i>, where <i>x</i> and <i>y</i> are values, produces <b>true</b>, <b>false</b>, or <b>undefined</b> (which indicates that at least one operand is <b>NaN</b>). In addition to <i>x</i> and <i>y</i> the algorithm takes a Boolean flag named <i>LeftFirst</i> as a parameter. The flag is used to control the order in which operations with potentially visible side-effects are performed upon <i>x </i>and <i>y</i>. It is necessary because ECMAScript specifies left to right evaluation of expressions. The default value of <i>LeftFirst</i> is <b>true</b> and indicates that the <i>x</i> parameter corresponds to an expression that occurs to the left of the <i>y</i> parameter’s corresponding expression. If <i>LeftFirst </i>is <b>false</b>, the reverse is the case and operations must be performed upon <i>y </i>before <i>x</i>. Such a comparison is performed as follows:</p>
      <p>If <i>x</i> is an abrupt completion, return <i>x</i>.</p>
      <p>If <i>y</i> is an abrupt completion, return <i>y</i>.</p>
      <p>If the <i>LeftFirst </i>flag is <b>true</b>, then</p>
      <p>Let <i>px </i>be the result of calling ToPrimitive(<i>x</i>, hint Number).</p>
      <p>If p<i>x</i> is an abrupt completion, return p<i>x</i>.</p>
      <p>Let <i>py </i>be the result of calling ToPrimitive(<i>y</i>, hint Number).</p>
      <p>If <i>py</i> is an abrupt completion, return <i>py</i>.</p>
      <p>Else the order of evaluation needs to be reversed to preserve left to right evaluation</p>
      <p>Let <i>py </i>be the result of calling ToPrimitive(<i>y</i>, hint Number).</p>
      <p>If <i>py</i> is an abrupt completion, return <i>py</i>.</p>
      <p>Let <i>px </i>be the result of calling ToPrimitive(<i>x</i>, hint Number).</p>
      <p>If p<i>x</i> is an abrupt completion, return p<i>x</i>.</p>
      <p>If it is not the case that both Type(<i>px</i>) is String and Type(<i>py</i>) is String, then </p>
      <p>Let <i>nx </i>be the result of calling ToNumber(<i>px</i>). Because <i>px </i>and <i>py </i>are primitive values evaluation order is not important.</p>
      <p>Let <i>ny</i> be the result of calling ToNumber(<i>py</i>).</p>
      <p>If <i>nx </i>is <b>NaN</b>, return <b>undefined</b>.</p>
      <p>If <i>ny </i>is <b>NaN</b>, return <b>undefined</b>.</p>
      <p>If <i>nx</i> and <i>ny</i> are the same Number value, return <b>false</b>.</p>
      <p>If <i>nx</i> is <b>+0</b> and <i>ny</i> is <b>−</b><b>0</b>, return <b>false</b>.</p>
      <p>If <i>nx</i> is <b>−</b><b>0</b> and <i>ny</i> is <b>+0</b>, return <b>false</b>.</p>
      <p>If <i>nx</i> is <b>+</b><b>∞</b>, return <b>false</b>.</p>
      <p>If <i>ny</i> is <b>+</b><b>∞</b>, return <b>true</b>.</p>
      <p>If <i>ny</i> is <b>−</b><b>∞</b>, return <b>false</b>.</p>
      <p>If <i>nx</i> is <b>−</b><b>∞</b>, return <b>true</b>.</p>
      <p>If the mathematical value of <i>nx</i> is less than the mathematical value of <i>ny</i> —note that these mathematical values are both finite and not both zero—return <b>true</b>. Otherwise, return <b>false</b>.</p>
      <p>Else, both <i>px </i>and <i>py </i>are Strings</p>
      <p>If <i>py</i> is a prefix of <i>px</i>, return <b>false</b>. (A String value <i>p</i> is a prefix of String value <i>q</i> if <i>q</i> can be the result of concatenating <i>p</i> and some other String <i>r</i>. Note that any String is a prefix of itself, because <i>r</i> may be the empty String.)</p>
      <p>If <i>px</i> is a prefix of <i>py</i>, return <b>true</b>.</p>
      <p>Let <i>k</i> be the smallest nonnegative integer such that the character at position <i>k</i> within <i>px</i> is different from the character at position <i>k</i> within <i>py</i>. (There must be such a <i>k</i>, for neither String is a prefix of the other.)</p>
      <p>Let <i>m</i> be the integer that is the code unit value for the character at position <i>k</i> within <i>px</i>.</p>
      <p>Let <i>n</i> be the integer that is the code unit value for the character at position <i>k</i> within <i>py</i>.</p>
      <p>If <i>m</i> &lt; <i>n</i>, return <b>true</b>. Otherwise, return <b>false</b>.</p>
      <p>NOTE 1<span>	Step 3 differs from step 7 in the algorithm for the addition operator </span><b>+</b> (11.6.1) in using and instead of or.</p>
      <p>NOTE 2<span>	The comparison of Strings uses a simple lexicographic ordering on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore String values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form.</span> Also, note that for strings containing supplementary characters, lexicographic ordering on sequences of UTF-16 code unit values differs from that on sequences of code point values.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>RelationalExpression <b>:</b> RelationalExpression <b>&lt;</b> ShiftExpression </p>
      <p>Let <i>lref</i> be the result of evaluating RelationalExpression.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating ShiftExpression.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>Let <i>r</i> be the result of performing abstract relational comparison <i>lval</i> &lt; <i>rval</i>. (see 11.8.5)</p>
      <p>If <i>r</i> is <b>undefined</b>, return <b>false</b>. Otherwise, return <i>r</i>.</p>
      <p>RelationalExpression <b>:</b> RelationalExpression <b>&gt;</b> ShiftExpression </p>
      <p>Let <i>lref</i> be the result of evaluating RelationalExpression.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating ShiftExpression.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>Let <i>r</i> be the result of performing abstract relational comparison <i>rval</i> &lt; <i>lval</i> with <i>LeftFirst</i> equal to <b>false</b>..</p>
      <p>If <i>r</i> is <b>undefined</b>, return <b>false</b>. Otherwise, return <i>r</i>.</p>
      <p>RelationalExpression <b>:</b> RelationalExpression <b>&lt;=</b> ShiftExpression </p>
      <p>Let <i>lref</i> be the result of evaluating RelationalExpression.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating ShiftExpression.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>Let <i>r</i> be the result of performing abstract relational comparison <i>rval</i> &lt; <i>lval</i>  with <i>LeftFirst</i> equal to <b>false</b>..</p>
      <p>If <i>r</i> is <b>true </b>or<b> undefined</b>, return <b>false</b>. Otherwise, return <b>true</b>.</p>
      <p>RelationalExpression <b>:</b> RelationalExpression <b>&gt;=</b> ShiftExpression </p>
      <p>Let <i>lref</i> be the result of evaluating RelationalExpression.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating ShiftExpression.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>Let <i>r</i> be the result of performing abstract relational comparison <i>lval</i> &lt; <i>rval</i>. </p>
      <p>If <i>r</i> is <b>true </b>or<b> undefined</b>, return <b>false</b>. Otherwise, return <b>true</b>.</p>
      <p>RelationalExpression<b>:</b> RelationalExpression <b>instanceof</b> ShiftExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>RelationalExpression</i>.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>ShiftExpression</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>If <i>rval</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>If Type(<i>rval</i>) is not Object, throw a <b>TypeError</b> exception.</p>
      <p>If <i>rval</i> does not have a [[HasInstance]] internal method, throw a <b>TypeError</b> exception.</p>
      <p>Return the result of calling the [[HasInstance]] internal method of <i>rval</i> with argument <i>lval</i>.</p>
      <p>RelationalExpression <b>:</b> RelationalExpression <b>in</b> ShiftExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>RelationalExpression</i>.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>ShiftExpression</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>If <i>rval</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>If Type(<i>rval</i>) is not Object, throw a <b>TypeError</b> exception.</p>
      <p>Return the result of calling the [[HasProperty]] internal method of <i>rval</i> with argument ToString(<i>lval</i>).</p>
      <h2>11.9<span>	Equality Operator</span>s</h2>
      <p>NOTE<span>	The result of evaluating an equality operator is always of type Boolean, reflecting whether the relationship named by the operator holds between its two operands.</span></p>
      <p>Syntax</p>
      <p>EqualityExpression <b>:</b></p>
      <p>RelationalExpression<span><br>EqualityExpression</span> <b>==</b> RelationalExpression<span><br>EqualityExpression</span> <b>!=</b> RelationalExpression<span><br>EqualityExpression</span> <b>===</b> RelationalExpression<span><br>EqualityExpression</span> <b>!==</b> RelationalExpression<br>EqualityExpression [no LineTerminator here] <b>is</b> RelationalExpression<span><br>EqualityExpression</span> [no LineTerminator here] <b>isnt</b> RelationalExpression</p>
      <p>EqualityExpressionNoIn <b>:</b></p>
      <p>RelationalExpressionNoIn<span><br>EqualityExpressionNoIn</span> <b>==</b> RelationalExpressionNoIn<span><br>EqualityExpressionNoIn</span> <b>!=</b> RelationalExpressionNoIn<span><br>EqualityExpressionNoIn</span> <b>===</b> RelationalExpressionNoIn<span><br>EqualityExpressionNoIn</span> <b>!==</b> RelationalExpressionNoIn <br>EqualityExpression [no LineTerminator here] <b>is</b> RelationalExpression<span><br>EqualityExpression</span> [no LineTerminator here] <b>isnt</b> RelationalExpression</p>
      <p>The semantics of the EqualityExpressionNoIn productions are the same as the EqualityExpression productions except that the contained EqualityExpressionNoIn and RelationalExpressionNoIn are used in place of the contained EqualityExpression and RelationalExpression, respectively.</p>
      <h2>11.9.1 Runtime Semantics</h2>
      <p><b>Runtime Semantics: </b><b>The Abstract Equality</b> <b>Comparison Algorithm</b></p>
      <p>The comparison <i>x</i> == <i>y</i>, where <i>x</i> and <i>y</i> are values, produces <b>true</b> or <b>false</b>. Such a comparison is performed as follows:</p>
      <p>If <i>x</i> is an abrupt completion, return <i>x</i>.</p>
      <p>If <i>y</i> is an abrupt completion, return <i>y</i>.</p>
      <p>If Type(<i>x</i>) is the same as Type(<i>y</i>), then</p>
      <p><span>	If Type(</span><i>x</i>) is Undefined, return <b>true</b>.</p>
      <p>If Type(<i>x</i>) is Null, return <b>true</b>.</p>
      <p><span>	If Type(</span><i>x</i>) is Number, then</p>
      <p>If <i>x</i> is <b>NaN</b>, return <b>false</b>.</p>
      <p>If <i>y</i> is <b>NaN</b>, return <b>false</b>.</p>
      <p>If <i>x</i> is the same Number value as <i>y</i>, return <b>true</b>.</p>
      <p>If <i>x</i> is <b>+0</b> and <i>y </i>is <b>−</b><b>0</b>, return <b>true</b>.</p>
      <p>If <i>x</i> is <b>−</b><b>0</b> and <i>y </i>is <b>+0</b>, return <b>true</b>.</p>
      <p>Return <b>false</b>.</p>
      <p>If Type(<i>x</i>) is String, then return <b>true</b> if <i>x</i> and <i>y</i> are exactly the same sequence of characters (same length and same characters in corresponding positions). Otherwise, return <b>false</b>.</p>
      <p>If Type(<i>x</i>) is Boolean, return <b>true</b> if <i>x</i> and <i>y </i>are both <b>true</b> or both <b>false</b>. Otherwise, return <b>false</b>.</p>
      <p>Return <b>true</b> if <i>x</i> and <i>y </i>are the same Object value. Otherwise, return <b>false</b>.</p>
      <p>If <i>x</i> is <b>null</b> and <i>y </i>is <b>undefined</b>, return <b>true</b>.</p>
      <p>If <i>x</i> is <b>undefined</b> and <i>y </i>is <b>null</b>, return <b>true</b>.</p>
      <p>If Type(<i>x</i>) is Number and Type(<i>y</i>) is String,<span><br>return the result of the comparison</span><i> x</i> == ToNumber(<i>y</i>).</p>
      <p>If Type(<i>x</i>) is String and Type(<i>y</i>) is Number,<span><br>return the result of the comparison ToNumber(</span><i>x</i>) == <i>y</i>.</p>
      <p>If Type(<i>x</i>) is Boolean, return the result of the comparison ToNumber(<i>x</i>) == <i>y</i>.</p>
      <p>If Type(<i>y</i>) is Boolean, return the result of the comparison<i> x</i> == ToNumber(<i>y</i>).</p>
      <p>If Type(<i>x</i>) is either String or Number and Type(<i>y</i>) is Object,<span><br>return the result of the comparison </span><i>x</i> == ToPrimitive(<i>y</i>).</p>
      <p>If Type(<i>x</i>) is Object and Type(<i>y</i>) is either String or Number,<span><br>return the result of the comparison ToPrimitive(</span><i>x</i>) == <i>y</i>.</p>
      <p>Return <b>false</b>.</p>
      <p>NOTE 1<span>	Given the above definition of equality:</span></p>
      <p>String comparison can be forced by: <b>"" + a == "" + b</b>.</p>
      <p>Numeric comparison can be forced by: <b>+a == +b</b>.</p>
      <p>Boolean comparison can be forced by: <b>!a == !b</b>.</p>
      <p>NOTE 2<span>	The equality operators maintain the following invariants:</span></p>
      <p><b>A</b> <b>!=</b> <b>B</b> is equivalent to <b>!(A</b> <b>==</b> <b>B)</b>.</p>
      <p><b>A</b><b> </b><b>==</b><b> </b><b>B</b> is equivalent to <b>B</b><b> </b><b>==</b><b> </b><b>A</b>, except in the order of evaluation of <b>A</b> and <b>B</b>.</p>
      <p>NOTE 3<span>	The equality operator is not always transitive. For example, there might be two distinct String objects, each representing the same String value; each String object would be considered equal to the String value by the </span><b>==</b> operator, but the two String objects would not be equal to each other. For Example:</p>
      <p><b>new String("a")</b> <b>==</b> <b>"a"</b> and <b>"a"</b> <b>==</b>  <b>new String("a")</b>are both <b>true</b>. </p>
      <p><b>new String("a")</b> <b>==</b> <b>new String("a")</b> is <b>false</b>.</p>
      <p>NOTE 4<span>	Comparison of Strings uses a simple equality test on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form.</span></p>
      <p><b>Runtime Semantics: </b><b>The Strict Equality</b> <b>Comparison Algorithm</b></p>
      <p>The comparison <i>x</i> === <i>y</i>, where <i>x</i> and <i>y</i> are values, produces <b>true</b> or <b>false</b>. Such a comparison is performed as follows:</p>
      <p>If <i>x</i> is an abrupt completion, return <i>x</i>.</p>
      <p>If <i>y</i> is an abrupt completion, return <i>y</i>.</p>
      <p>If Type(<i>x</i>) is different from Type(<i>y</i>), return <b>false</b>.</p>
      <p>If Type(<i>x</i>) is Undefined, return <b>true</b>.</p>
      <p>If Type(<i>x</i>) is Null, return <b>true</b>.</p>
      <p>If Type(<i>x</i>) is Number, then</p>
      <p>If <i>x</i> is <b>NaN</b>, return <b>false</b>.</p>
      <p>If <i>y</i> is <b>NaN</b>, return <b>false</b>.</p>
      <p>If <i>x</i> is the same Number value as <i>y</i>, return <b>true</b>.</p>
      <p>If <i>x</i> is <b>+0</b> and <i>y</i> is <b>−</b><b>0</b>, return <b>true</b>.</p>
      <p>If <i>x</i> is <b>−</b><b>0</b> and <i>y</i> is <b>+0</b>, return <b>true</b>.</p>
      <p>Return <b>false</b>.</p>
      <p>If Type(<i>x</i>) is String, then return <b>true</b> if <i>x</i> and <i>y</i> are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return <b>false</b>.</p>
      <p>If Type(<i>x</i>) is Boolean, return <b>true</b> if <i>x</i> and <i>y</i> are both <b>true</b> or both <b>false</b>; otherwise, return <b>false</b>.</p>
      <p>Return <b>true</b> if <i>x</i> and <i>y</i> are the same Object value. Otherwise, return <b>false</b>.</p>
      <p>NOTE<span>	This algorithm differs from the SameValue Algorithm (9.12) in its treatment of signed zeroes and NaNs.</span></p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>EqualityExpression : EqualityExpression <b>==</b> RelationalExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>EqualityExpression</i>.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>RelationalExpression</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>Return the result of performing abstract equality comparison algorithm <i>rval</i> == <i>lval</i>. </p>
      <p>EqualityExpression <b>:</b> EqualityExpression <b>!=</b> RelationalExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>EqualityExpression</i>.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>RelationalExpression</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>If <i>rval</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>Let <i>r</i> be the result of performing abstract equality comparison algorithm <i>rval</i> == <i>lval</i>. </p>
      <p>If <i>r</i> is <b>true</b>, return <b>false</b>. Otherwise, return <b>true</b>.</p>
      <p>EqualityExpression<b> :</b> EqualityExpression <b>===</b> RelationalExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>EqualityExpression</i>.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>RelationalExpression</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>Return the result of performing the strict equality comparison algorithm <i>rval</i> === <i>lval</i>. </p>
      <p>EqualityExpression <b>:</b> EqualityExpression <b>!==</b> RelationalExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>EqualityExpression</i>.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>RelationalExpression</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>Let <i>r</i> be the result of performing strict equality comparison algorithm <i>rval</i> === <i>lval</i>. </p>
      <p>If <i>r</i> is <b>true</b>, return <b>false</b>. Otherwise, return <b>true</b>.</p>
      <p>EqualityExpression<b> :</b> EqualityExpression [no <i>LineTerminator</i> here] <b>is</b> RelationalExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>EqualityExpression</i>.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>RelationalExpression</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>If <i>rval</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>Return the result of performing SameValue(<i>rval</i>, <i>lval</i>). </p>
      <p>EqualityExpression <b>:</b> EqualityExpression [no <i>LineTerminator</i> here] <b>isnt</b> RelationalExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>EqualityExpression</i>.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>RelationalExpression</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>Let <i>r</i> be the result of performing SameValue(<i>rval</i>, <i>lval</i>). </p>
      <p>If <i>r</i> is <b>true</b>, return <b>false</b>. Otherwise, return <b>true</b>.</p>
      <h2>11.10<span>	Binary Bitwise Operator</span>s</h2>
      <p>Syntax</p>
      <p>BitwiseANDExpression <b>:</b></p>
      <p>EqualityExpression<span><br>BitwiseANDExpression </span><b>&amp;</b> EqualityExpression</p>
      <p>BitwiseANDExpressionNoIn <b>:</b></p>
      <p>EqualityExpressionNoIn<span><br>BitwiseANDExpressionNoIn </span><b>&amp;</b> EqualityExpressionNoIn</p>
      <p>BitwiseXORExpression <b>:</b></p>
      <p>BitwiseANDExpression<span><br>BitwiseXORExpression </span><b>^</b> BitwiseANDExpression</p>
      <p>BitwiseXORExpressionNoIn <b>:</b></p>
      <p>BitwiseANDExpressionNoIn<span><br>BitwiseXORExpressionNoIn </span><b>^</b> BitwiseANDExpressionNoIn</p>
      <p>BitwiseORExpression <b>:</b></p>
      <p>BitwiseXORExpression<span><br>BitwiseORExpression </span><b>|</b> BitwiseXORExpression</p>
      <p>BitwiseORExpressionNoIn <b>:</b></p>
      <p>BitwiseXORExpressionNoIn<span><br>BitwiseORExpressionNoIn </span><b>|</b> BitwiseXORExpressionNoIn</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>The production <i>A </i><b>:</b><i> </i>A<i> @ </i>B, where @ is one of the bitwise operators in the productions above, is evaluated as follows:</p>
      <p>Let <i>lref</i> be the result of evaluating <i>A</i>.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>B</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>If <i>rval</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>Let <i>lnum</i> be ToInt32(<i>lval</i>).</p>
      <p>If <i>lnum</i> is an abrupt completion, return <i>lnum</i>.</p>
      <p>Let <i>rnum</i> be ToInt32(<i>rval</i>).</p>
      <p>If <i>rnum</i> is an abrupt completion, return <i>rnum</i>.</p>
      <p>Return the result of applying the bitwise operator @ to <i>lnum</i> and <i>rnum</i>. The result is a signed 32 bit integer.</p>
      <h2>11.11<span>	Binary Logical Operator</span>s</h2>
      <p>Syntax</p>
      <p>LogicalANDExpression <b>:</b></p>
      <p>BitwiseORExpression<br>LogicalANDExpression <b>&amp;&amp;</b> BitwiseORExpression</p>
      <p>LogicalANDExpressionNoIn <b>:</b></p>
      <p>BitwiseORExpressionNoIn<br>LogicalANDExpressionNoIn <b>&amp;&amp;</b> BitwiseORExpressionNoIn</p>
      <p>LogicalORExpression <b>:</b></p>
      <p>LogicalANDExpression<br>LogicalORExpression <b>||</b> LogicalANDExpression</p>
      <p>LogicalORExpressionNoIn <b>:</b></p>
      <p>LogicalANDExpressionNoIn<br>LogicalORExpressionNoIn <b>||</b> LogicalANDExpressionNoIn</p>
      <p>The semantics of the LogicalANDExpressionNoIn and LogicalORExpressionNoIn productions are the same manner as the LogicalANDExpression and LogicalORExpression productions except that the contained LogicalANDExpressionNoIn, BitwiseORExpressionNoIn and LogicalORExpressionNoIn are used in place of the contained LogicalANDExpression, BitwiseORExpression and LogicalORExpression, respectively.</p>
      <p>NOTE<span>	The value produced by a </span><b>&amp;&amp;</b> or <b>||</b> operator is not necessarily of type Boolean. The value produced will always be the value of one of the two operand expressions.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>LogicalANDExpression <b>:</b> LogicalANDExpression <b>&amp;&amp;</b> BitwiseORExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>LogicalANDExpression</i>.</p>
      <p>Let <i>lval</i> be ToBoolean(GetValue(<i>lref</i>)).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>If <i>lval</i> is <b>false</b>, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>BitwiseORExpression</i>.</p>
      <p>Return GetValue(<i>rref</i>).</p>
      <p>LogicalORExpression <b>:</b> LogicalORExpression <b>||</b> LogicalANDExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>LogicalORExpression</i>.</p>
      <p>Let <i>lval</i> be ToBoolean(GetValue(<i>lref</i>)).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>If <i>lval</i> is <b>true</b>, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>LogicalANDExpression</i>.</p>
      <p>Return GetValue(<i>rref</i>).</p>
      <h2>11.12<span>	Conditional Operator (</span> ? : )</h2>
      <p>Syntax</p>
      <p>ConditionalExpression <b>:</b></p>
      <p>LogicalORExpression<span><br>LogicalORExpression</span><b> ?</b> AssignmentExpression <b>:</b> AssignmentExpression</p>
      <p>ConditionalExpressionNoIn <b>:</b></p>
      <p>LogicalORExpressionNoIn<span><br>LogicalORExpressionNoIn</span><b> ?</b> AssignmentExpression <b>:</b> AssignmentExpressionNoIn</p>
      <p>The semantics of the ConditionalExpressionNoIn production is the same as the ConditionalExpression production except that the contained LogicalORExpressionNoIn, AssignmentExpression and AssignmentExpressionNoIn are used in place of the contained LogicalORExpression, first AssignmentExpression and second AssignmentExpression, respectively.</p>
      <p>NOTE<span>	The grammar for a ConditionalExpression in ECMAScript is a little bit different from that in C and Java, which each allow the second subexpression to be an Expression but restrict the third expression to be a ConditionalExpression. The motivation for this difference in ECMAScript is to allow an assignment expression to be governed by either arm of a conditional and to eliminate the confusing and fairly useless case of a comma expression as the centre expression.</span></p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>ConditionalExpression <b>:</b> LogicalORExpression <b>?</b> AssignmentExpression <b>:</b> AssignmentExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>LogicalORExpression</i>.</p>
      <p>Let <i>lval</i> be ToBoolean(GetValue(<i>lref</i>)).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>If <i>lval</i> is <b>true</b>, then</p>
      <p>Let <i>trueRef</i> be the result of evaluating the first <i>AssignmentExpression</i>.</p>
      <p>Return GetValue(<i>trueRef</i>).</p>
      <p>Else</p>
      <p>Let <i>falseRef</i> be the result of evaluating the second <i>AssignmentExpression</i>.</p>
      <p>Return GetValue(<i>falseRef</i>).</p>
      <h2>11.13<span>	Assignment Operator</span>s</h2>
      <p>Syntax</p>
      <p>AssignmentExpression <b>:</b></p>
      <p>ConditionalExpression<span><br>YieldExpression</span><span><br>LeftHandSideExpression </span><b>=</b> AssignmentExpression <span><br>LeftHandSideExpression AssignmentOperator AssignmentExpression</span></p>
      <p>AssignmentExpressionNoIn <b>:</b></p>
      <p>ConditionalExpressionNoIn<span><br>LeftHandSideExpression </span><b>=</b> AssignmentExpressionNoIn<span><br>LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn</span></p>
      <p>AssignmentOperator <b>:</b><b> </b><b>one of</b></p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>*=</p>
            </td>
            <td>
              <p>/=</p>
            </td>
            <td>
              <p>%=</p>
            </td>
            <td>
              <p>+=</p>
            </td>
            <td>
              <p>-=</p>
            </td>
            <td>
              <p>&lt;&lt;=</p>
            </td>
            <td>
              <p>&gt;&gt;=</p>
            </td>
            <td>
              <p>&gt;&gt;&gt;=</p>
            </td>
            <td>
              <p>&amp;=</p>
            </td>
            <td>
              <p>^=</p>
            </td>
            <td>
              <p>|=</p>
            </td>
          </tr>
        </table>
      </figure>
      <p>The semantics of the <i>AssignmentExpressionNoIn</i> productions are the same manner as the <i>AssignmentExpression</i> productions except that the contained ConditionalExpressionNoIn<i> </i>and<i> AssignmentExpressionNoIn</i> are used in place of the contained <i>ConditionalExpression</i> and <i>AssignmentExpression</i>, respectively.</p>
      <h2>Static Semantics</h2>
      <p>
        <b>Static Semantics:  </b>
        <b>Early Errors</b>
      </p>
      <p>AssignmentExpression <b>:</b></p>
      <p>LeftHandSideExpression  <b>=</b> AssignmentExpression <span><br>LeftHandSideExpression</span>  AssignmentOperator AssignmentExpression</p>
      <p>It is a Syntax Error if the AssignmentExpression is contained in strict code and LeftHandSideExpression is the Identifier <b>eval</b> or the Identifier <b>arguments</b>.</p>
      <p>It is a Syntax Error if the LeftHandSideExpression is an Identifier that statically resolves to a declarative environment record binding and the resolved binding is an immutable binding.</p>
      <p>It is a Syntax Error if the LeftHandSideExpression is PrimaryExpression : <b>(</b> Expression<b> ) </b>and Expression derived a production that would produce a Syntax Error according to these rules. This rule is recursively applied.</p>
      <p>AssignmentExpression <b>: </b>LeftHandSideExpression  <b>=</b> AssignmentExpression </p>
      <p>It is a Syntax Error if the LeftHandSideExpression is an ObjectLiteral or an<i> </i>ArrayLiteral<i> </i>and the source code corresponding to LeftHandSideExpression cannot be parsed using AssignmentPattern as the goal symbol.</p>
      <h2>Runtime Semantics</h2>
      <p><b>Runtime Semantics: </b><b>Evaluation</b> </p>
      <p>AssignmentExpression <b>:</b> LeftHandSideExpression <b>=</b> AssignmentExpression </p>
      <p>
        <b>If </b>
        <span style="font-weight: bold; font-style: italic">LeftHandSideExpression</span>
        <b> is neither an </b>
        <span style="font-weight: bold; font-style: italic">ObjectLiteral</span>
        <b> nor an</b>
        <span style="font-weight: bold; font-style: italic"> ArrayLiteral  </span>
        <b>then</b>
      </p>
      <p>Let <i>lref</i> be the result of evaluating <i>LeftHandSideExpression</i>.</p>
      <p>If <i>lref</i> is an abrupt completion, return <i>lref</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>AssignmentExpression</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>If the result of PutValue(<i>lref</i>, <i>rval</i>) is an abrupt completion, return that result.</p>
      <p>Return <i>rval</i>.</p>
      <p>Let <i>AssignmentPattern</i> be the parse of the source code corresponding to <i>LeftHandSideExp</i><i>r</i><i>ess</i><i>i</i><i>on</i> using <i>AssignmentPattern</i> as the goal symbol.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>AssignmentExpression</i>.</p>
      <p>Let <i>rval</i> be ToObject(GetValue(<i>rref</i>)).</p>
      <p>If <i>rval</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>Let <i>status</i> be the result of performing Destructuring Assignment Evaluation of <i>AssignmentPattern</i> using <i>rval</i> as the argument.</p>
      <p>If <i>status</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>Return <i>rval</i>.</p>
      <p>AssignmentExpression<i> </i><b>:</b><i> </i>LeftHandSideExpression<i> </i>AssignmentOperator<i> </i>AssignmentExpression</p>
      <p>Let <i>lref</i> be the result of evaluating <i>LeftHandSideExpression</i>.</p>
      <p>Let <i>lval</i> be GetValue(<i>lref</i>).</p>
      <p>If <i>lval</i> is an abrupt completion, return <i>lval</i>.</p>
      <p>Let <i>rref</i> be the result of evaluating <i>AssignmentExpression</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rref</i>).</p>
      <p>If <i>r</i><i>val</i> is an abrupt completion, return <i>r</i><i>val</i>.</p>
      <p>Let <i>operator</i> be the <b>@</b> where <i>AssignmentOperator</i> is <b>@=</b></p>
      <p>Let <i>r</i> be the result of applying operator @ to <i>lval</i> and <i>rval</i>.</p>
      <p>If the result of PutValue(<i>lref</i>, <i>r</i>) is an abrupt completion, return that result.</p>
      <p>Return <i>r</i>.</p>
      <p>NOTE<span>	When an assignment occurs within strict mode code,</span> it is an runtime error if <i>lref</i> in step 1.e of the first algorithm or step 9 of the second algorithm it is an unresolvable reference. If it is, a <b>ReferenceError</b> exception is thrown. The LeftHandSide also may not be a reference to a data property with the attribute value {[[Writable]]:<b>false</b>}, to an accessor property with the attribute value {[[Set]]:<b>undefined</b>},<b> </b>nor to a non-existent property of an object whose [[Extensible]] internal property has the value <b>false</b>. In these cases a <b>TypeError</b> exception is thrown.</p>
      <h2>11.13.1 Destructuring Assignment</h2>
      <p>Supplemental Syntax</p>
      <p>In certain circumstances when processing the production AssignmentExpression <b>:</b> LeftHandSideExpression <b>=</b> AssignmentExpression the following grammar is used to refine the interpretation of  LeftHandSideExpression.</p>
      <p>AssignmentPattern <b>:</b></p>
      <p>ObjectAssignmentPattern<span><br>ArrayAssignmentPattern</span><b> </b></p>
      <p>ObjectAssignmentPattern <b>:</b></p>
      <p><b>{ }</b><b><br>{ </b>AssignmentPropertyList<b> }</b><b><br>{ </b>AssignmentPropertyList<b> , }</b></p>
      <p>ArrayAssignmentPattern <b>:</b></p>
      <p><b>[ </b>Elision<sub>opt</sub><b> </b>AssignmentRestElement<sub>opt </sub><b>]</b><b><br></b><b>[</b><b> </b>AssignmentElementList <sub> </sub><b>]</b><b><br></b><b>[ </b>AssignmentElementList<b> , </b>Elision<sub>opt</sub><b> </b>AssignmentRestElement<sub>opt </sub><b>]</b></p>
      <p>AssignmentPropertyList <b>:</b></p>
      <p>AssignmentProperty<span><br>AssignmentPropertyList </span><b>,</b> AssignmentProperty</p>
      <p>AssignmentElementList <b>:</b></p>
      <p>Elision<sub>opt</sub>  AssignmentElement <span><br>AssignmentElementList </span><b>,</b> Elision<sub>opt </sub> AssignmentElement</p>
      <p>AssignmentProperty <b>:</b></p>
      <p>Identifier<span><br>PropertyName</span><b> : </b>LeftHandSideExpression</p>
      <p>AssignmentElement <b>:</b></p>
      <p> LeftHandSideExpression</p>
      <p>AssignmentRestElement <b>:</b></p>
      <p> <b>…</b> LeftHandSideExpression</p>
      <h2>Static Semantics</h2>
      <p>
        <b>Static Semantics:  </b>
        <b>Early Errors</b>
      </p>
      <p>AssignmentProperty <b>: </b>PropertyName <b>:</b> LeftHandSideExpression</p>
      <p>AssignmentElement <b>: </b>LeftHandSideExpression </p>
      <p>It is a Syntax Error if LeftHandSideExpression is the Identifier <b>eval</b> or the Identifier <b>arguments</b>.</p>
      <p>It is a Syntax Error if LeftHandSideExpression is the Identifier <b>this</b> or the Identifier <b>super</b>.</p>
      <p>It is a Syntax Error if the LeftHandSideExpression is a Literal, a FunctionExpression or a ClassExpression.</p>
      <p>It is a Syntax Error if the LeftHandSideExpression is an Identifier that does not statically resolve to a declarative environment record binding or if the resolved binding is an immutable binding.</p>
      <p>It is a Syntax Error if the LeftHandSideExpression is an ObjectLiteral or an<i> </i>ArrayLiteral<i> </i>and the source code corresponding to LeftHandSideExpression cannot be parsed using AssignmentPattern as the goal symbol.</p>
      <p>It is a Syntax Error if the LeftHandSideExpression is PrimaryExpression : <b>(</b> Expression<b> ) </b>and Expression derived a production that would produce a Syntax Error according to these rules. This rule is recursively applied.</p>
      <p>AssignmentRestElement <b>:</b> <b>…</b> <b> </b>LeftHandSideExpression </p>
      <p>It is a Syntax Error if LeftHandSideExpression is the Identifier <b>eval</b> or the Identifier <b>arguments</b>.</p>
      <p>It is a Syntax Error if LeftHandSideExpression is the Identifier <b>this</b> or the Identifier <b>super</b>.</p>
      <p>It is a Syntax Error if the LeftHandSideExpression is a Literal, an ObjectLiteral, an ArrayLiteral, a FunctionExpression, or a ClassExpression.</p>
      <p>It is a Syntax Error if the LeftHandSideExpression is an Identifier that does not statically resolve to a declarative environment record binding or if the resolved binding an immutable binding.</p>
      <p>It is a Syntax Error if the LeftHandSideExpression is PrimaryExpression : <b>(</b> Expression<b> ) </b>and Expression derived a production that would produce a Syntax Error according to these rules. This rule is recursively applied.</p>
      <h2>Runtime Semantics</h2>
      <p><b>Runtime Semantics: </b><b>Destructuring Assignment </b><b>Evaluation</b> </p>
      <p>with parameter obj</p>
      <p>AssignmentPattern <b>: </b>ObjectAssignmentPattern </p>
      <p>Return the result of performing Destructuring Assignment Evaluation of ObjectAssignmentPattern with <i>obj</i> as the argument.</p>
      <p>AssignmentPattern <b>: </b>ArrayAssignmentPattern</p>
      <p>Return the result of performing Destructuring Assignment Evaluation of ArrayAssignmentPattern with <i>obj</i> as the argument.</p>
      <p>ObjectAssignmentPattern <b>: </b><b>{ }</b></p>
      <p>and</p>
      <p>ArrayAssignmentPattern <b>:</b></p>
      <p><b>[]</b><b><br>[</b>Elision<b>]</b></p>
      <p>Return.</p>
      <p>ObjectAssignmentPattern <b>:</b></p>
      <p><b>{ </b>AssignmentPropertyList<b> }</b><b><br>{ </b>AssignmentPropertyList<b> , }</b></p>
      <p>Return the result of performing Destructuring Assignment Evaluation of AssignmentPropertyList<b> </b>with <i>obj</i> as the argument.</p>
      <p>AssignmentPropertyList <b>: </b>AssignmentProperty</p>
      <p>Return the result of performing Destructuring Assignment Evaluation of AssignmentProperty with <i>obj</i> as the argument.</p>
      <p>AssignmentPropertyList <b>: </b>AssignmentPropertyList <b>,</b> AssignmentProperty</p>
      <p>Let <i>status</i> be the result of performing Destructuring Assignment Evaluation of AssignmentPropertyList with <i>obj</i> as the argument.</p>
      <p>If <i>status</i> is an abrupt completion, return <i>status</i>.</p>
      <p>Return the result of performing Destructuring Assignment Evaluation of AssignmentProperty with <i>obj</i> as the argument.</p>
      <p>
      </p>
      <p>AssignmentProperty <b>: </b>Identifier</p>
      <p>Let <i>v</i> be the result of calling the [[Get]] internal method of <i>obj</i> with the <i>Identifier</i> string as the argument.</p>
      <p>Let <i>lref</i> be the result of performing Identifier Resolution(10.3.1) with the IdentifierName corresponding to <i>Identifier</i>.</p>
      <p>Return PutValue(<i>lref</i>,<i>v</i>).</p>
      <p>AssignmentProperty <b>: </b>PropertyName <b>:</b> LeftHandSideExpression</p>
      <p>Let <i>name</i> be the result of evaluating PropertyName.</p>
      <p>Let <i>v</i> be the result of calling the [[Get]] internal method of <i>obj</i>  with <i>name</i> as the argument.</p>
      <p>If <i>v</i> is an abrupt completion, return <i>v</i>.</p>
      <p>If LeftHandSideExpression is an ObjectLiteral or an ArrayLiteral<i> </i>then</p>
      <p>Let <i>AssignmentPattern</i> be the parse of the source code corresponding to <i>LeftHandSideExp</i><i>r</i><i>ess</i><i>i</i><i>on</i> using <i>AssignmentPattern</i> as the goal symbol</p>
      <p>Let <i>vObj</i> be ToObject(<i>v</i>).</p>
      <p>If <i>vObj</i> is an abrupt completion, return <i>vObj</i>.</p>
      <p>Return the result of evaluating <i>AssignmentPattern</i> using <i>vObj</i> as the obj<i> </i>parameter..</p>
      <p>Let <i>lref</i> be the result of evaluating <i>LeftHandSideExpression</i>.</p>
      <p>Call PutValue(<i>lref</i>,<i>v</i>).</p>
      <p>ArrayAssignmentPattern <b>:</b> <b>[</b><b> </b>Elision<sub>opt</sub> AssignmentRestElement<span style="vertical-align: sub; font-style: italic"> </span><b>]</b></p>
      <p>If <i>Elision</i> is present, then let <i>skip</i> be the result of evaluating <i>Elision</i>, otherwise let <i>skip</i> be 0.</p>
      <p>Return the result of performing Indexed Destructuring Assignment Evaluation of AssignmentRestElement<b> </b>with and <i>skip</i> as the arguments.</p>
      <p>ArrayAssignmentPattern <b>: </b><b>[</b> AssignmentElementList<b> </b><b>]</b></p>
      <p>Return the result of performing Indexed Destructuring Assignment Evaluation of AssignmentElementList<b> </b>using <i>obj</i> and 0 as the arguments.</p>
      <p>ArrayAssignmentPattern <b>: </b><b>[</b> AssignmentElementList<span style="font-weight: bold; font-style: italic"> </span><b>,</b><span style="font-weight: bold; font-style: italic"> </span>Elision<sub>opt</sub><span style="font-weight: bold; font-style: italic"> </span>AssignmentRestElement<sub>opt</sub><span style="vertical-align: sub; font-style: italic"> </span><b>]</b></p>
      <p>Let <i>lastIndex</i> be the result of performing Indexed Destructuring Assignment Evaluation of AssignmentElementList<b> </b>using <i>obj</i> and 0 as the arguments.</p>
      <p>If <i>lastIndex</i> is an abrupt completion, return <i>lastIndex</i>.</p>
      <p>If <i>Elision</i> is present, then let <i>skip</i> be the result of evaluating <i>Elision</i>, otherwise let <i>skip</i> be 0.</p>
      <p>If AssignmentRestElement is present, then return the result of performing Indexed Destructuring Assignment Evaluation of AssignmentRestElement<b> </b>with <i>obj</i> and <i>lastI</i><i>ndex</i>+<i>skip</i> as the arguments.</p>
      <p>Return<b> </b><i>lastIndex</i>.</p>
      <p><b>Runtime Semantics: </b><b>Indexed Destructuring Assignment </b><b>Evaluation</b> </p>
      <p>with parameters obj and index </p>
      <p>AssignmentElementList <b>: </b>Elision<sub>opt</sub><span style="font-weight: bold; font-style: italic"> </span>AssignmentElement<span style="vertical-align: sub; font-style: italic"> </span></p>
      <p>If <i>Elision</i> is present, then let <i>skip</i> be the result of evaluating <i>Elision</i>, otherwise let <i>skip</i> be 0.</p>
      <p>Let <i>status</i> be the result of performing Indexed Destructuring Assignment Evaluation of AssignmentElement<b> </b>with <i>obj</i> and <i>index</i>+<i>skip</i> as the arguments.</p>
      <p>If <i>status</i> is an abrupt completion, return <i>status</i>.</p>
      <p>Return <i>index</i>+<i>skip</i>+1.</p>
      <p>AssignmentElementList <b>: </b>AssignmentElementList <b>,</b> Elision<sub>opt</sub><span style="font-weight: bold; font-style: italic"> </span>AssignmentElement<span style="vertical-align: sub; font-style: italic"> </span></p>
      <p>Let <i>list</i><i>Next</i> be the result of performing Indexed Destructuring Assignment Evaluation of AssignmentElementList<b> </b>using <i>obj</i> as the <i>obj</i> parameter and <i>index</i> as the <i>index</i> parameter</p>
      <p>If <i>Elision</i> is present, then let <i>skip</i> be the result of evaluating <i>Elision</i>, otherwise let <i>skip</i> be 0.</p>
      <p>If <i>listNext</i> is an abrupt completion, return <i>listNext</i>.</p>
      <p>Let <i>status</i> be the result of performing Indexed Destructuring Assignment Evaluation of AssignmentElement<b> </b>with <i>obj</i> and <i>list</i><i>Next</i>+<i>skip</i> as the arguments.</p>
      <p>If <i>status</i> is an abrupt completion, return <i>status</i>.</p>
      <p>Return <i>l</i><i>i</i><i>st</i><i>Next</i>+<i>skip+</i>1.</p>
      <p>AssignmentElement <b>:</b><b> </b>LeftHandSideExpression</p>
      <p>Let <i>name</i> be ToString(<i>index</i>).</p>
      <p>Let <i>v</i> be the result of calling the [[Get]] internal method of <i>obj</i> with <i>name</i> as the argument.</p>
      <p>If <i>v</i> is an abrupt completion, return <i>v</i>.</p>
      <p>If LeftHandSideExpression is an ObjectLiteral or an ArrayLiteral<i> </i>then</p>
      <p>Let <i>AssignmentPattern</i> be the parse of the source code corresponding to <i>LeftHandSideExp</i><i>r</i><i>ess</i><i>i</i><i>on</i> using <i>AssignmentPattern</i> as the goal symbol</p>
      <p>Let <i>vObj</i> be ToObject(<i>v</i>).</p>
      <p>If <i>vObj</i> is an abrupt completion, return <i>vObj</i>.</p>
      <p>Return the result of evaluating Destructuring Assignment Evaluation of <i>AssignmentPattern</i> with <i>vObj</i> as the argument..</p>
      <p>Let <i>lref</i> be the result of evaluating <i>LeftHandSideExpression</i>.</p>
      <p>Return PutValue(<i>lref</i>,<i>v</i>).</p>
      <p>AssignmentRestElement <b>:</b> <b>… </b>LeftHandSideExpression</p>
      <p>Let <i>lref</i> be the result of evaluating <i>LeftHandSideExpression</i>.</p>
      <p>If <i>lref</i> is an abrupt completion, return <i>lref</i>.</p>
      <p>Let <i>lenVal</i> be the result of calling the [[Get]] internal method of <i>obj</i> with argument “<b>length</b>”.</p>
      <p>Let <i>len</i> be ToUint32(<i>lenVal</i>).</p>
      <p>If <i>len</i> is an abrupt completion, return <i>len</i>.</p>
      <p>Let <i>A</i> be a new array object created as if by the expression <b>new Array()</b> where <b>Array</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>n</i>=0;</p>
      <p>Repeat, while <i>index</i> &lt; <i>len</i></p>
      <p>Let <i>P</i> be ToString(<i>index</i>).</p>
      <p>Let <i>exists</i> be the result of calling the [[HasProperty]] internal method of <i>obj</i> with argument <i>P</i>.</p>
      <p>If <i>exists</i> is <b>true</b>, then</p>
      <p>Let <i>v</i> be the result of calling the [[Get]] internal method of <i>obj</i> passing ToString(<i>index</i>) as the argument.</p>
      <p>If <i>v</i> is an abrupt completion, return <i>v</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments ToString(<i>n</i>), Property Descriptor {[[Value]]: <i>v</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Let <i>n</i> = <i>n</i>+1.</p>
      <p>Let <i>index</i> = <i>index</i>+1.</p>
      <p>Return PutValue(<i>lref</i>,<i>A</i>).</p>
      <h2>11.14<span>	Comma Operator (</span> , )</h2>
      <p>Syntax</p>
      <p><i>Expression</i> <b>:</b></p>
      <p><i>AssignmentExpression</i><span><br>Expression </span><b>,</b> AssignmentExpression</p>
      <p>ExpressionNoIn <b>:</b></p>
      <p>AssignmentExpressionNoIn<span><br>ExpressionNoIn </span><b>,</b> AssignmentExpressionNoIn</p>
      <p>The semantics of the ExpressionNoIn production is the same manner as the Expression production except that the contained ExpressionNoIn and AssignmentExpressionNoIn are used in place of the contained Expression and AssignmentExpression, respectively.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>Expression <b>:</b> Expression <b>,</b> AssignmentExpression </p>
      <p>Let <i>lref</i> be the result of evaluating <i>Expression</i>.</p>
      <p>If the result of GetValue(<i>lref</i>) is an abrupt completion, return that result</p>
      <p>Let <i>rref</i> be the result of evaluating <i>AssignmentExpression</i>.</p>
      <p>Return GetValue(<i>rref</i>).</p>
      <p>NOTE<span>	GetValue must be called even though its value is not used because it may have observable side-effects.</span></p>
      <h1>12<span>	Statement</span>s and Declarations</h1>
      <p>Syntax</p>
      <p>Statement <b>:</b></p>
      <p>BlockStatement<span><br>VariableStatement</span><span><br>EmptyStatement</span><span><br>ExpressionStatement</span><span><br>IfStatement</span><br>BreakableStatement<span><br>ContinueStatement</span><span><br>BreakStatement</span><span><br>ReturnStatement</span><span><br>WithStatement</span><span><br>LabelledStatement</span><span><br>ThrowStatement</span><span><br>TryStatement</span><span><br>DebuggerStatement</span></p>
      <p>Declaration <b>:</b></p>
      <p>FunctionDeclaration<br>LexicalDeclaration</p>
      <p>BreakableStatement <b>:</b></p>
      <p>IterationStatement<span><br>SwitchStatement</span></p>
      <h2>Static Semantics</h2>
      <p>
        <b>Static Semantics:  </b>
        <b>BoundNames</b>
      </p>
      <p>The BoundNames of the Declaration productions are determined as follows:</p>
      <p>Return the BoundNames of the single non-terminal symbol that is the right hand side of the production.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>VarDeclaredNames</b>
      </p>
      <p>Statement <b>:</b></p>
      <p>EmptyStatement<span><br>ExpressionStatement</span><span><br>ContinueStatement</span><span><br>BreakStatement</span><span><br>ReturnStatement</span><span><br>ThrowStatement</span><span><br>DebuggerStatement</span></p>
      <p>Return a new empty List.</p>
      <p>Statement <b>:</b></p>
      <p>BlockStatement<span><br>VariableStatement</span><span><br>IterationStatement</span><span><br>WithStatement</span><span><br>LabelledStatement</span><span><br>SwitchStatement</span><span><br>TryStatement </span></p>
      <p>Return the VarDeclaredNames of the  single non-terminal symbol that is the right hand side of the production.</p>
      <p><i>Statement </i><b>:</b><i> VariableStatement</i> </p>
      <p>Return the BoundNames of <i>VariableStatement</i>.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Labelled Evaluation</b>
      </p>
      <p>With argument <i>l</i><i>abelSet</i>.</p>
      <p><i>BreakableStatement</i><i> </i><i> </i><b>:</b><i> </i><i> </i><i>IterationStatement</i> </p>
      <p>Let <i>stmtResult</i> be the result performing Labelled Evaluation of <i>IterationStatement</i> wth argument <i>l</i><i>abelSet</i>.</p>
      <p>If <i>stmtResult</i>.[[type]] is break and <i>stmtResult</i>.[[target]] is empty, then</p>
      <p>Let <i>stmtResult</i> be NormalCompletion(<i>stmtResult</i>.[[value]])</p>
      <p>Return <i>stmtResult</i>.</p>
      <p>
        <i>BreakableStatement</i>
        <i> </i>
        <i> </i>
        <b>:</b>
        <i> </i>
        <i> </i>
        <i>SwitchStatement</i>
      </p>
      <p>Let <i>stmtResult</i> be the result of evaluating <i>SwitchStatement</i>.</p>
      <p>If <i>stmtResult</i>.[[type]] is break and <i>stmtResult</i>.[[target]] is empty, then</p>
      <p>Let <i>stmtResult</i> be NormalCompletion(<i>stmtResult</i>.[[value]])</p>
      <p>Return <i>stmtResult</i>.</p>
      <p>NOTE	A  BreakableStatement is one that can be existed via an unlabelled  BreakStatement. </p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>The Statement productions are all evaluated as follows</p>
      <p>Return the result of evaluating the  single non-terminal symbol that is the right hand side of the production.</p>
      <p>The Declaration  productions are all evaluated as follows</p>
      <p>Return the result of evaluating the  single non-terminal symbol that is the right hand side of the production.</p>
      <p>NOTE	The result of evaluating a <i>Statement</i> or <i>Declaration</i> is always a Completion value.</p>
      <p>BreakableStatement <b>:</b></p>
      <p>IterationStatement<span><br>SwitchStatement</span></p>
      <p>Let <i>newLabelSet </i> be a new empty List.</p>
      <p>Return the result of performing Labelled Evaluation of this <i>BreakableStatement</i><i> </i>wth argument <i>newLabelSet</i>.</p>
      <h2>12.1<span>	Bloc</span>k</h2>
      <p>Syntax</p>
      <p>BlockStatement <b>:</b></p>
      <p>Block </p>
      <p>Block <b>:</b></p>
      <p><b>{</b> StatementList<sub>opt</sub> <b>}</b></p>
      <p>StatementList <b>:</b></p>
      <p>StatementListItem<span><br>StatementList Statement</span>ListItem</p>
      <p>StatementListItem <b>:</b></p>
      <p>Statement<span><br>Declaration</span></p>
      <h2>Static Semantics</h2>
      <p>
        <b>Static Semantics:  </b>
        <b>Early Errors</b>
      </p>
      <p><i>Block </i><b>:</b><i> </i><b>{</b> <i>StatementList</i> <b>}</b>  </p>
      <p>It is a Syntax Error if the LexicallyDeclaredNames of <i>StatementList</i> contains any duplicate entiries.</p>
      <p>It is a Syntax Error if any element of the LexicallyDeclaredNames of <i>StatementList</i> also occurs in the VarDeclaredNames of <i>StatementList</i>.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>LexicalDeclarations</b>
      </p>
      <p><i>StatementList </i><b>:</b><i> StatementListItem</i> </p>
      <p>Return the LexicalDeclarations of <i>StatementListItem</i>.</p>
      <p><i>StatementList </i><b>:</b><i> StatementList StatementListItem</i> </p>
      <p>Let <i>declarations </i>be LexicalDeclarations of <i>StatementList</i>.</p>
      <p>Append to <i>names</i> the elements of the LexicalDeclarations of <i>StatementListItem</i>.</p>
      <p>Return <i>declarations</i>.</p>
      <p><i>StatementListItem </i><b>:</b><i> Statement</i> </p>
      <p>Return a new empty List.</p>
      <p><i>StatementListItem </i><b>:</b><i> Declaration</i> </p>
      <p>Return return a new List containing <i>Declaration</i>.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>LexicallyDeclaredNames</b>
      </p>
      <p><i>Block </i><b>:</b><i> </i><b>{</b> <b>}</b> </p>
      <p>Return a new empty List.</p>
      <p><i>Block </i><b>:</b><i> </i><b>{</b> <i>StatementList</i> <b>}</b></p>
      <p>Return the LexicallyDeclaredNames of <i>StatementList</i>.</p>
      <p><i>StatementList </i><b>:</b><i> StatementListItem</i> </p>
      <p>Return the LexicallyDeclaredNames of <i>StatementListItem</i>.</p>
      <p><i>StatementList </i><b>:</b><i> StatementList StatementListItem</i> </p>
      <p>Let <i>names </i>be LexicallyDeclaredNames of <i>StatementList</i>.</p>
      <p>Append to <i>names</i> the elements of the LexicallyDeclaredNames of <i>StatementListItem</i>.</p>
      <p>Return names.</p>
      <p><i>StatementListItem </i><b>:</b><i> Statement</i> </p>
      <p>Return a new empty List.</p>
      <p><i>StatementListItem </i><b>:</b><i> Declaration</i> </p>
      <p>Return the BoundNames of <i>Declaration</i>.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>VarDeclaredNames</b>
      </p>
      <p><i>BlockStatement </i><b>:</b><i> Block</i> </p>
      <p>Return the VarDeclaredNames of <i>Block</i>.</p>
      <p><i>Block </i><b>:</b><i> </i><b>{</b> <b>}</b> </p>
      <p>Return a new empty List.</p>
      <p><i>Block </i><b>:</b><i> </i><b>{</b> <i>StatementList</i> <b>}</b> </p>
      <p>Return the VarDeclaredNames of <i>StatementList</i>.</p>
      <p><i>StatementList </i><b>:</b><i> StatementListItem</i> </p>
      <p>Return the VarDeclaredNames of <i>StatementListItem</i>.</p>
      <p><i>StatementList </i><b>:</b><i> StatementList StatementListItem</i> </p>
      <p>Let <i>names </i>be VarDeclaredNames of <i>StatementList</i>.</p>
      <p>Append to <i>names</i> the elements of the VarDeclaredNames of <i>StatementListItem</i>.</p>
      <p>Return names.</p>
      <p><i>StatementListItem </i><b>:</b><i> Statement</i> </p>
      <p>Return the VarDeclaredNames of <i>Statement</i>.</p>
      <p><i>StatementListItem </i><b>:</b><i> Declaration</i> </p>
      <p>Return a new empty List.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p><i>BlockStatement </i><b>:</b><i> Block</i> </p>
      <p>Return the result of evaluating <i>Block</i>.</p>
      <p><i>Block </i><b>:</b><i> </i><b>{</b> <b>}</b><b> </b></p>
      <p>Return NormalCompletion (<b>empty</b>).</p>
      <p><i>Block </i><b>:</b><i> </i><b>{</b> <i>StatementList</i> <b>}</b></p>
      <p>Let <i>oldEnv</i> be the running execution context’s LexicalEnvironment.</p>
      <p>Let <i>blockEnv</i> be the result of calling NewDeclarativeEnvironment passing <i>oldEnv</i> as the argument.</p>
      <p>Perform Block Declaration Instantiation using <i>StatementList</i> and <i>blockEnv</i>.</p>
      <p>Set the running execution context’s LexicalEnvironment to <i>blockEnv</i>.</p>
      <p>Let <i>blockValue</i> be the result of evaluating <i>StatementList</i>.</p>
      <p>Set the running execution context’s LexicalEnvironment to <i>oldEnv</i>.</p>
      <p>Return <i>blockValue</i>.</p>
      <p>NOTE<span>	No matter how control leaves the </span>Block the LexicalEnvironment is always restored to its former state.</p>
      <p><i>StatementList </i><b>:</b><i> Statement</i><i>ListItem</i> </p>
      <p>Let <i>s</i> be the result of evaluating <i>Statement</i><i>ListItem</i>.</p>
      <p>Return <i>s</i>.</p>
      <p><i>StatementList </i><b>:</b><i> StatementList Statement</i><i>ListItem</i> </p>
      <p>Let <i>sl</i> be the result of evaluating <i>StatementList</i>.</p>
      <p>If <i>sl</i> is an abrupt completion, return <i>sl</i>.</p>
      <p>Let <i>s</i> be the result of evaluating <i>Statement</i>.</p>
      <p>If s.[[type]] is throw,  return <i>s</i>. </p>
      <p>If <i>s</i>.[[value]] is empty, let <i>V</i> = <i>sl</i>.[[value]], otherwise let <i>V</i> = <i>s</i>.[[value]].</p>
      <p>Return Completion {[[type]]: <i>s</i>.[[type]], [[value]]: <i>V</i>, [[target]]: <i>s</i>.[[target]]}.</p>
      <p>NOTE<span>	Steps </span>4 and 5 of the above algoritm ensure that the value of a <i>StatementList </i>is the value of the last value producing <i>Statement</i> in the <i>StatementList</i>.  For example, the following calls to the <b>eval</b> function all return the value 1:</p>
      <p>
        <b>eval("1;;;;;")</b>
      </p>
      <p>
        <b>eval("1;{}")</b>
      </p>
      <p>
        <b>eval("1;var a;")</b>
      </p>
      <p><i>StatementListItem </i><b>:</b><i> Statement</i> </p>
      <p>Return the result of evaluating <i>Statement</i>.</p>
      <p><i>StatementListItem </i><b>:</b><i> Declaration</i> </p>
      <p>Return the result of evaluating <i>Declaration</i>.</p>
      <h2>12.2	Declarations and the Variable Statement</h2>
      <h2>12.2.1<span>	Let </span>and Const Declarations</h2>
      <p>NOTE<span>	A </span><b>let</b> and <b>const</b> declarations define variables that are scoped to the current execution context’s LexicalEnvironment. The variables are created when their containing Lexical Environment is instantiated but may not be accssed in any way until the variable’s <i>Lexical</i><i>Binding</i> is evaluated. A variable defined by a <i>Lexical</i><i>Binding</i> with an <i>Initialiser</i> is assigned the value of its <i>Initialiser</i>’s <i>AssignmentExpression</i> when the <i>LetBinding</i> is evaluated, not when the variable is created. If a <i>Lexical</i><i>Binding</i> in a <b>let</b> declaration<i> </i>does not have an an <i>Initialiser</i> the variable is assigned the value <b>undefined</b> when the <i>LetBinding</i> is executed.</p>
      <p>Syntax</p>
      <p>LexicalDeclaration <b>:</b></p>
      <p>LetOrConst BindingList <b>;</b></p>
      <p>LexicalDeclarationNoIn <b>:</b></p>
      <p>LetOrConst BindingListNoIn</p>
      <p>LetOrConst <b>:</b></p>
      <p><b>let</b><br><b>const</b> </p>
      <p>BindingList <b>:</b></p>
      <p>LexicalBinding<span><br>BindingList </span><b>,</b> LexicalBinding</p>
      <p>BindingListNoIn <b>:</b></p>
      <p>LexicalBindingNoIn<span><br>BindingListNoIn </span><b>,</b> LexicalBindingNoIn</p>
      <p>LexicalBinding <b>:</b></p>
      <p>BindingIdentifier Initialiser<sub>opt</sub><sub><br></sub>BindingPattern  Initialiser</p>
      <p>LexicalBindingNoIn <b>:</b></p>
      <p>BindingIdentifier InitialiserNoIn<sub>opt</sub><sub><br></sub>BindingPattern  InitialiserNoIn</p>
      <p>BindingIdentifier  <b>:</b></p>
      <p>Identifier</p>
      <p>Initialiser <b>:</b></p>
      <p><b>=</b> AssignmentExpression</p>
      <p>InitialiserNoIn <b>:</b></p>
      <p><b>=</b> AssignmentExpressionNoIn</p>
      <p>The semantics of the LexicalDeclarationNoIn, BindingListNoIn, <i>Lexical</i>BindingNoIn and InitialiserNoIn productions are the same as the LexicalDeclaration, BindingList, <i>Lexical</i>Binding and Initialiser productions except that the contained BindingListNoIn, <i>Lexical</i>BindingNoIn, InitialiserNoIn and AssignmentExpressionNoIn are used in place of the contained BindingList, <i>Lexical</i>Binding, Initialiser and AssignmentExpression, respectively.</p>
      <h2> Static Semantics</h2>
      <p>
        <b>Static Semantics:  </b>
        <b>Early Errors</b>
      </p>
      <p>LexicalBinding <b>:</b> <i>Binding</i>Identifier </p>
      <p>It is a Syntax Error if the BindingIdentifier if IsConstantDeclaration of the <i>LexicalDeclaration</i> containing this production is <b>true</b>.</p>
      <p>BindingIdentifier <b>:</b> Identifier </p>
      <p>It is a Syntax Error if the BindingIdentifier is contained in strict code and if the Identifier is <b>eval</b> or <b>arguments</b>.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>Bound</b>
        <b> </b>
        <b>Names</b>
      </p>
      <p><i>Lexical</i><i>Declaration </i><b>:</b><i> </i><i>LetOrConst BindingList</i><i> </i><b>;</b> </p>
      <p>Return the Bound Names of <i>BindingList</i>.</p>
      <p>BindingList<i> </i><b>:</b> LexialBinding </p>
      <p>Return the Bound Names of LexicalBinding.</p>
      <p><i>BindingList </i><b>:</b> <i>BindingList </i><b>,</b> LexicalBinding </p>
      <p>Let <i>names </i>be the Bound ames of <i>BindingList</i>.</p>
      <p>Append to <i>names</i> the elements of the Bound Names of LexialBinding.</p>
      <p>Return names.</p>
      <p>LexicalBinding <b>:</b> <i>BindingIdentifier Initialiser</i><sub>opt</sub> </p>
      <p>Return the Bound Names of <i>BindingIdentifier</i>.</p>
      <p>LexicalBinding<b>:</b> <i>BindingPattern Initialiser</i> </p>
      <p>Return the Bound Names of <i>BindingPattern</i>.</p>
      <p>BindingIdentifier <b>:</b> Identifier </p>
      <p>Return a new List containing the String Value of Identifier.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>IsConstant</b>
        <b>Declaration</b>
      </p>
      <p><i>Lexical</i><i>Declaration </i><b>:</b><i> </i><i>LetOrConst BindingList</i><i> </i><b>;</b> </p>
      <p>Return IsConstantDeclaration of <i>LetOrConst</i>.</p>
      <p><i>LetOrConst BindingList</i><i> </i><i> </i><b>:</b><i> </i> <b>let</b></p>
      <p>Return <b>false</b>.</p>
      <p><i>LetOrConst BindingList</i><i> </i><i> </i><b>:</b><i> </i> <b>const</b></p>
      <p>Return <b>false</b>.</p>
      <p>
        <b>Static</b>
        <b> Semantics: </b>
        <b>String Value</b>
      </p>
      <p>BindingIdentifier <b>:</b> Identifier </p>
      <p>Return the String Value of Identifier.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Binding </b>
        <b>Initialisation</b>
      </p>
      <p>With arguments <i>value</i> and <i>environment</i>.</p>
      <p>NOTE	<b>undefined</b> is passed for <i>environment</i> to indicate that a PutValue operation should be used to assign the initialisation value.  This is the the case for <b>var</b> statements formal parameter lists of non-strict functions. In those cases a lexical binding is hosted and preinitialized prior to evaluation of its initializer. </p>
      <p>BindingIdentifier <b>:</b> Identifier</p>
      <p>Return the result of performing Binding Initialisation for <i>Identifier</i> passing<i> value</i> and <i>env</i> as the arguments.</p>
      <p>Token Identifier</p>
      <p>If <i>environment</i> is not <b>undefined</b>, then </p>
      <p>Return the result of calling the InitializeBinding concrete method of <i>environment</i> passing Identifier and <i>value</i> as the arguments.</p>
      <p>Else</p>
      <p>Let <i>lhs</i> be the result of evaluating <i>Identifier</i> as described in 11.1.2.</p>
      <p>Return PutValue(<i>lhs</i>, <i>value</i>).</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p><i>Lexical</i><i>Declaration</i><i> </i><b>:</b><i> </i><i>LetOrConst </i><i>BindingList </i><b>;</b> </p>
      <p>Let <i>next</i><i> </i>be the result of evaluating <i>BindingList</i>.</p>
      <p>If <i>next</i> is an abrupt completion, return <i>next</i>.</p>
      <p>Return NormalCompletion(empty).</p>
      <p><i>BindingList </i><b>: </b>LexicalBinding </p>
      <p>Return the result of evaluating LexicalBinding.</p>
      <p><i>BindingList </i><b>:</b> <i>BindingList </i><b>,</b> LexicalBinding </p>
      <p>Let <i>next</i><i> </i>be the result of evaluating <i>BindingList</i>.</p>
      <p>If <i>next</i> is an abrupt completion, return <i>next</i>.</p>
      <p>Return the result of evaluating LexialBinding.</p>
      <p>LexicalBinding <b>:</b> <i>BindingIdentifier  </i></p>
      <p>Let <i>env</i> be the running execution context’s LexicalEnvironment.</p>
      <p>Return the result of performing Binding Initialisation for <i>BindingIdentifier</i> passing <b>undefined</b> and <i>env</i> as the arguments.</p>
      <p>NOTE	A static sementic rule ensures that this form of LexicalBinding never occurs in a <b>const</b> declaration. </p>
      <p><i>Lexical</i>Binding <b>:</b> <i>BindingIdentifier Initialiser</i> </p>
      <p>Let <i>rhs </i>be the result of evaluating <i>Initialiser</i>.</p>
      <p>Let <i>value </i>be GetValue(<i>rhs</i>).</p>
      <p>If <i>value</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>Let <i>env</i> be the running execution context’s LexicalEnvironment.</p>
      <p>Return the result of performing Binding Initialisation for <i>BindingIdentifier</i> passing<i> value</i> and <i>env</i> as the arguments.</p>
      <p>LexicalBinding<b>:</b> <i>BindingPattern Initialiser</i> </p>
      <p>Let <i>rhs </i>be the result of evaluating <i>Initialiser</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rhs</i>).</p>
      <p>If <i>rval</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>Let <i>env</i> be the running execution context’s LexicalEnvironment.</p>
      <p>Return the result of performing Binding Initialisation for <i>BindingPattern</i> using <i>rval</i> as the obj<i> </i>parameter and <i>env</i> as the <i>environment</i> parameter.</p>
      <p><i>Initialiser </i><b>:</b><i> </i><b>=</b><i> AssignmentExpression</i> </p>
      <p>Return the result of evaluating <i>AssignmentExpression</i>.</p>
      <h2>12.2.2<span>	Variable Statement</span></h2>
      <p>NOTE<span>	A </span><b>var</b> statement declares variables that are scoped to the current execution context’s VariableEnvironment. Var variables are created when their containing Lexical Environment is instantiated and are initialised to <b>undefined</b> when created. Within the scope of any VariableEnvironemnt a common <i>Identifier</i> may appear in more than one <i>VariableDeclaration</i> but those declarations collective define only one variable. A variable defined by a <i>VariableDeclaration</i> with an <i>Initialiser</i> is assigned the value of its <i>Initialiser</i>’s <i>AssignmentExpression</i> when the <i>VariableDeclaration</i> is executed, not when the variable is created. </p>
      <p>Syntax</p>
      <p>VariableStatement <b>:</b></p>
      <p><b>var</b> VariableDeclarationList <b>;</b></p>
      <p>VariableDeclarationList <b>:</b></p>
      <p>VariableDeclaration<span><br>VariableDeclarationList </span><b>,</b> VariableDeclaration</p>
      <p>VariableDeclarationListNoIn <b>:</b></p>
      <p>VariableDeclarationNoIn<span><br>VariableDeclarationListNoIn </span><b>,</b> VariableDeclarationNoIn</p>
      <p>VariableDeclaration <b>:</b></p>
      <p>BindingIdentifier Initialiser<sub>opt</sub><sub><br></sub>BindingPattern  Initialiser</p>
      <p>VariableDeclarationNoIn <b>:</b></p>
      <p>BindingIdentifier InitialiserNoIn<sub>opt</sub><sub><br></sub>BindingPattern  InitialiserNoIn</p>
      <p>The semantics of the VariableDeclarationListNoIn, VariableDeclarationNoIn and InitialiserNoIn productions are the same as the VariableDeclarationList, VariableDeclaration and Initialiser productions except that the contained VariableDeclarationListNoIn, VariableDeclarationNoIn, InitialiserNoIn and AssignmentExpressionNoIn are used in of the contained VariableDeclarationList, VariableDeclaration, Initialiser and AssignmentExpression, respectively.</p>
      <h2>Static Semantics</h2>
      <p>
        <b>Static Semantics:  </b>
        <b>BoundNames</b>
      </p>
      <p><i>VariableStatement </i><b>:</b><i> </i><b>var</b><i> VariableDeclarationList </i><b>;</b> </p>
      <p>Return BoundNames of <i>VariableDeclarationList</i>.</p>
      <p>VariableDeclarationList <b>:</b>VariableDeclaration </p>
      <p>Return BoundNames of <i>VariableDeclaration</i>.</p>
      <p>VariableDeclarationList <b>:</b> VariableDeclarationList <b>,</b> VariableDeclaration </p>
      <p>Let <i>names </i>be BoundNames of VariableDeclarationList.</p>
      <p>Append to <i>names</i> the elements of BoundNames of VariableDeclaration.</p>
      <p>Return names.</p>
      <p><i>VariableDeclaration </i><b>:</b> <i>BindingIdentifier Initialiser</i><sub>opt</sub> </p>
      <p>Return the BoundNames of <i>BindingIdentifier</i>.</p>
      <p><i>VariableDeclaration </i><b>:</b> <i>BindingPattern Initialiser</i> </p>
      <p>Return the BoundNames of <i>BindingPattern</i>.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Binding </b>
        <b>Initialisation</b>
      </p>
      <p>With arguments <i>value</i> and <i>environment</i>.</p>
      <p>NOTE	<b>undefined</b> is passed for <i>environment</i> to indicate that a PutValue operation should be used to assign the initialisation value.  This is the the case for <b>var</b> statements formal parameter lists of non-strict functions. In those cases a lexical binding is hosted and preinitialized prior to evaluation of its initializer. </p>
      <p><i>VariableDeclaration </i><b>:</b><i> BindingIdentifier</i> </p>
      <p>Return the result of performing Binding Initialisation for <i>BindingIdentifier</i> passing<i> value</i> and <b>undefined</b> as the arguments.</p>
      <p><i>VariableDeclaration</i> <b>:</b> <i>BindingIdentifier Initialiser</i> </p>
      <p>Return the result of performing Binding Initialisation for <i>BindingIdentifier</i> passing<i> value</i> and <b>undefined</b> as the arguments.</p>
      <p><i>VariableDeclaration</i> <b>:</b> <i>BindingPattern Initialiser</i> </p>
      <p>Return the result of performing Binding Initialisation for <i>BindingPattern</i> passing<i> value</i> and <b>undefined</b> as the arguments.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p><i>VariableStatement </i><b>:</b><i> </i><b>var</b><i> VariableDeclarationList </i><b>;</b> </p>
      <p>Let <i>next</i><i> </i>be the result of evaluating <i>VariableDeclarationList</i>.</p>
      <p>If <i>next</i> is an abrupt completion, return <i>next</i>.</p>
      <p>Return NormalCompletion( empty).</p>
      <p>VariableDeclarationList <b>:</b>VariableDeclaration </p>
      <p>Return the result of evaluating <i>VariableDeclaration</i>.</p>
      <p>VariableDeclarationList <b>:</b> VariableDeclarationList <b>,</b> VariableDeclaration </p>
      <p>Let <i>next</i><i> </i>be the result of evaluating <i>VariableDeclarationList</i>.</p>
      <p>If <i>next</i> is an abrupt completion, return <i>next</i>.</p>
      <p>Return the result of evaluating <i>VariableDeclaration</i>.</p>
      <p><i>VariableDeclaration </i><b>:</b><i> BindingIdentifier</i> </p>
      <p>Return NormalCompletion(empty).</p>
      <p><i>VariableDeclaration</i> <b>:</b> <i>BindingIdentifier Initialiser</i> </p>
      <p>Let <i>rhs </i>be the result of evaluating <i>Initialiser</i>.</p>
      <p>Let <i>value </i>be GetValue(<i>rhs</i>).</p>
      <p>If <i>value</i> is an abrupt completion, return <i>value</i>.</p>
      <p>Return the result of performing Binding Initialisation for <i>BindingIdentifier</i> passing<i> value</i> and <b>undefined</b> as the arguments.</p>
      <p>NOTE <span>	If a </span>VariableDeclaration is nested within a with statement and the <i>Identifier</i> in the VariableDeclaration is the same as a property name of the binding object of the with statement’s object environment record, then step 3 will assign value to the property instead of to the VariableEnvironment binding of the Identifier.</p>
      <p><i>VariableDeclaration</i> <b>:</b> <i>BindingPattern Initialiser</i> </p>
      <p>Let <i>rhs </i>be the result of evaluating <i>Initialiser</i>.</p>
      <p>Let <i>rval</i> be GetValue(<i>rhs</i>).</p>
      <p>If <i>rval</i> is an abrupt completion, return <i>rval</i>.</p>
      <p>Return the result of performing Binding Initialisation for <i>BindingPattern</i> passing <i>rval</i> and <b>undefined</b> as arguments.</p>
      <h2>12.2.4<span>	Destructuring Binding Patterns</span></h2>
      <p>Syntax</p>
      <p>BindingPattern <b>:</b></p>
      <p>ObjectBindingPattern<span><br>ArrayBindingPattern</span><b> </b></p>
      <p>ObjectBindingPattern <b>:</b></p>
      <p><b>{ }</b><b><br></b><b>{ </b>BindingPropertyList<b> }</b><b><br>{ </b>BindingPropertyList<b> , }</b></p>
      <p>ArrayBindingPattern <b>:</b></p>
      <p><b>[ </b>Elision<sub>opt</sub><b> </b>BindingRestElement<sub>opt </sub><b>]</b><b><br></b><b>[</b><b> </b>BindingElementList<b> </b><b>]</b><b><br></b><b>[</b><b> </b>BindingElementList<b> , </b>Elision<sub>opt</sub><b> </b>BindingRestElement<sub>opt </sub><b>]</b></p>
      <p>BindingPropertyList <b>:</b></p>
      <p>BindingProperty<span><br>BindingPropertyList </span><b>,</b> BindingProperty</p>
      <p>BindingElementList <b>:</b></p>
      <p>Elision<sub>opt</sub>  BindingElement <span><br>BindingElementList </span><b>,</b> Elision<sub>opt </sub> BindingElement</p>
      <p>BindingProperty <b>:</b></p>
      <p>SingleNameBinding <sub><br></sub> PropertyName<b> : </b>BindingElement</p>
      <p>BindingElement <b>:</b></p>
      <p>SingleNameBinding<br>BindingPattern Initialiser<sub>opt</sub></p>
      <p>SingleNameBinding  <b>:</b></p>
      <p>BindingIdentifier Initialiser<sub>opt</sub></p>
      <p>BindingRestElement <b>:</b></p>
      <p> <b>…</b> BindingIdentifier  </p>
      <h2>Static Semantics</h2>
      <p>
        <b>Static Semantics:  Early Errors</b>
      </p>
      <p>BindingPattern  <b>:</b> ObjectBindingPattern</p>
      <p>It is a Syntax Error if the Bound Names of  ObjectBindingPattern contains the string “<b>eval</b>” or the string “<b>arguments</b>”.</p>
      <p>BindingPattern  <b>:</b> ObjectBindingPattern</p>
      <p>It is a Syntax Error if the Bound Names of  ArrayBindingPattern contains the string “<b>eval</b>” or the string “<b>arguments</b>”.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>Bound</b>
        <b> </b>
        <b>Names</b>
      </p>
      <p>BindingPattern  <b>:</b> ObjectBindingPattern </p>
      <p>Return the Bound Names of ObjectBindingPattern.</p>
      <p>BindingPattern  <b>:</b> ArrayBindingPattern </p>
      <p>Return BoundNames of ArrayBindingPattern.</p>
      <p>ObjectBindingPattern<b>:</b> <b>{ }</b> </p>
      <p>Return an empty List.</p>
      <p>ObjectBindingPattern <b>:</b></p>
      <p><b>{ </b>BindingPropertyList<b> }</b><b><br>{ </b>BindingPropertyList<b> , }</b></p>
      <p>Return the BoundNames of BindingPropertyList.</p>
      <p>ArrayBindingPattern <b>:</b> <b>[</b><span style="font-weight: bold; font-style: italic"> </span><i>Elision</i><sub>opt</sub> <b>]</b> </p>
      <p>Return an empty List.</p>
      <p>ArrayBindingPattern <b>:</b> <b>[</b><span style="font-weight: bold; font-style: italic"> </span><i>Elision</i><sub>opt</sub><span style="font-weight: bold; font-style: italic"> </span>BindingRestElement <span style="vertical-align: sub; font-style: italic"> </span><b>]</b> </p>
      <p>Return the BoundNames of BindingElementList.</p>
      <p>ArrayBindingPattern <b>:</b> <b>[</b><b> </b>BindingElementList<b> </b><b>]</b> </p>
      <p>Return the BoundNames of BindingElementList.</p>
      <p>ArrayBindingPattern <b>:</b> <b>[</b><b> </b>BindingElementList<span style="vertical-align: sub; font-style: italic"> </span><b>, </b><i>Elision</i><sub>opt</sub> <b>]</b> </p>
      <p>Return the BoundNames of BindingElementList.</p>
      <p>ArrayBindingPattern <b>:</b> <b>[ </b>BindingElementList<span style="vertical-align: sub; font-style: italic"> </span><b>, </b><i>Elision</i><sub>opt</sub><span style="font-weight: bold; font-style: italic"> </span>BindingRestElement <span style="vertical-align: sub; font-style: italic"> </span><b>]</b> </p>
      <p>Let <i>names </i>be BoundNames of BindingElementList.</p>
      <p>Append to <i>names</i> the elements of BoundNames of BindingRestElement.</p>
      <p>Return names.</p>
      <p>BindingPropertyList <b>:</b> BindingProperty<b> </b></p>
      <p>Return BoundNames of BindingProperty.</p>
      <p>BindingPropertyList <b>:</b> BindingPropertyList <b>,</b> BindingProperty<b> </b></p>
      <p>Let <i>names </i>be BoundNames of BindingPropertyList.</p>
      <p>Append to <i>names</i> the elements of BoundNames of BindingProperty.</p>
      <p>Return names.</p>
      <p>BindingElementList <b>:</b> <i>Elision</i><sub>opt</sub>  BindingElement<b> </b></p>
      <p>Return BoundNames of BindingElement.</p>
      <p>BindingElementList <b>:</b> BindingElementList <b>,</b> <i>Elision</i><sub>opt</sub>  BindingElement </p>
      <p>Let <i>names </i>be BoundNames of BindingElementList.</p>
      <p>Append to <i>names</i> the elements of BoundNames of BindingElement.</p>
      <p>Return names.</p>
      <p>BindingProperty <b>:</b> <i>SingleNameBinding</i><i> </i></p>
      <p>Return the BoundNames of <i>SingleNameBinding</i> .</p>
      <p>BindingProperty <b>:</b> PropertyName <b>:</b> BindingElement<span style="vertical-align: sub; font-style: italic"> </span></p>
      <p>Return the BoundNames of BindingElement.</p>
      <p><i>SingleNameBinding </i><b>:</b> BindingIdentifier <i>Initialiser</i><sub>opt</sub> </p>
      <p>Return the BoundNames of BindingIdentifier.</p>
      <p>BindingElement <b>:</b> <i>SingleNameBinding</i> </p>
      <p>Return the BoundNames of <i>SingleNameBinding</i> .</p>
      <p>BindingElement <b>:</b> BindingPattern <i>Initialiser</i><sub>opt</sub> </p>
      <p>Return the BoundNames of BindingPattern.</p>
      <p>BindingRestElement <span style="vertical-align: sub; font-style: italic"> </span><b>:</b>  <b>...</b>  BindingIdentifier </p>
      <p>Return the BoundNames of BindingIdentifier.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>HasInitialiser</b>
      </p>
      <p>BindingElement <b>:</b> <i>SingleNameBinding</i> </p>
      <p>Return HasInitializer of <i>SingleNameBinding</i> .</p>
      <p>BindingElement <b>:</b> BindingPattern </p>
      <p>Return <b>false</b>.</p>
      <p>BindingElement <b>:</b> BindingPattern <i>Initialiser</i> </p>
      <p>Return <b>true</b>.</p>
      <p><i>SingleNameBinding </i><b>:</b> BindingIdentifier </p>
      <p>Return <b>false</b>.</p>
      <p><i>SingleNameBinding </i><b>:</b> BindingIdentifier <i>Initialiser</i> </p>
      <p>Return <b>true</b>.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Binding </b>
        <b>Initialisation</b>
      </p>
      <p>With parameters <i>value</i> and <i>environment</i>.</p>
      <p>NOTE	When <b>undefined</b> is passed for <i>environment</i> it indicates that a PutValue operation should be used to assign the initialisation value.  This is the the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name. </p>
      <p>BindingPattern  <b>:</b> ObjectBindingPattern</p>
      <p>If <i>value</i> is neither of <b>null</b> or <b>undefined</b>, then</p>
      <p>Let <i>obj</i> be ToObject(<i>value</i>).</p>
      <p>Else, let <i>obj</i> be <b>undefined</b>.</p>
      <p> Return the result of performing Binding Initialisation for ObjectBindingPattern using obj<i> </i>and <i>environment</i> as arguments.</p>
      <p>BindingPattern  <b>:</b> ArrayBindingPattern </p>
      <p>If <i>value</i> is neither of <b>null</b> or <b>undefined</b>, then</p>
      <p>Let <i>array</i> be ToObject(<i>value</i>).</p>
      <p>Else,</p>
      <p>Let <i>array</i> be <b>undefined</b>.</p>
      <p>Return the result of performing Indexed Binding Initialisation for ArrayBindingPattern using <i>array</i>, 0, and <i>environment</i> as arguments.</p>
      <p>ObjectBindingPattern<b>:</b> <b>{ } </b></p>
      <p>Return. </p>
      <p>ObjectBindingPattern <b>:</b></p>
      <p><b>{ </b>BindingPropertyList<b> }</b><b><br>{ </b>BindingPropertyList<b> , }</b></p>
      <p> Return the result of performing Binding Initialisation for BindingPropertyList<b> </b>using <i>value</i> and <i>environment</i> as arguments.</p>
      <p>BindingPropertyList <b>:</b> BindingProperty<b> </b></p>
      <p>Return the result of performing Binding Initialisation for BindingProperty<b> </b>using <i>value</i> and <i>environment</i> as arguments.</p>
      <p>BindingPropertyList <b>:</b> BindingPropertyList <b>,</b> BindingProperty<b> </b></p>
      <p>Let <i>next</i><i> </i>be the result of performing Binding Initialisation for BindingPropertyList<b> </b>using <i>value</i> and <i>environment</i> as arguments.</p>
      <p>If <i>next</i> is an abrupt completion, return <i>next</i>.</p>
      <p>Return the result of performing Binding Initialisation for BindingProperty<b> </b>using <i>value</i> and <i>environment</i> as arguments.</p>
      <p>BindingProperty <b>:</b> <i>SingleNameBinding</i> </p>
      <p>Let <i>name</i> be the <i>string</i> that is the only element of BoundNames of <i>SingleNameBinding</i>.</p>
      <p>Return the result of performing Keyed Binding Initialisation for <i>SingleNameBinding</i> using  value, <i>environment</i>, and <i>name</i> as the arguments.</p>
      <p>BindingProperty <b>:</b> PropertyName <b>:</b> BindingElement<span style="vertical-align: sub; font-style: italic"> </span></p>
      <p>Let <i>P</i> be the PropName of PropertyName</p>
      <p>Return the result of performing Keyed Binding Initialisation for BindingElement<span style="vertical-align: sub; font-style: italic"> </span>using <i>value</i>, <i>env</i><i>irnment</i>, and <i>P</i> as arguments.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Indexed </b>
        <b>Binding </b>
        <b>Initialisation</b>
      </p>
      <p>With parameters <i>array</i>, <i>nextIndex,</i> and<i> </i> <i>environment</i>.</p>
      <p>NOTE	When <b>undefined</b> is passed for <i>environment</i> it indicates that a PutValue operation should be used to assign the initialisation value.  This is the the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name. </p>
      <p>ArrayBindingPattern <b>:</b> <b>[</b><span style="font-weight: bold; font-style: italic"> </span><i>Elision</i><sub>opt</sub> <b>]</b></p>
      <p>Return. </p>
      <p>ArrayBindingPattern: <b>[ </b>Elision<sub>opt</sub> BindingRestElement <span style="vertical-align: sub; font-style: italic"> </span><b>] </b></p>
      <p>If <i>Elision</i> is present, then let <i>nextIndex</i> be the result of evaluating <i>Elision</i>, otherwise let <i>nextIndex</i> be 0.</p>
      <p>Return the result of performing Indexed Binding Initialisation for BindingRestElement <span style="vertical-align: sub; font-style: italic"> </span>using <i>array, nextIndex</i>, and <i>enviro</i><i>nment</i> as arguments.</p>
      <p>ArrayBindingPattern: <b>[ </b>BindingElementList<span style="vertical-align: sub; font-style: italic"> </span><b> </b><b>] </b></p>
      <p>Return the result of performing Indexed Binding Initialisation for BindingElementList<span style="vertical-align: sub; font-style: italic"> </span>using <i>array</i>,<i> </i><i>nextIndex</i>, and <i>enviro</i><i>nmen</i><i>t </i>as arguments.</p>
      <p>ArrayBindingPattern: <b>[ </b>BindingElementList<span style="vertical-align: sub; font-style: italic"> </span><b>, </b>Elision<sub>opt</sub><b>] </b></p>
      <p>Return the result of performing Indexed Binding Initialisation for BindingElementList<span style="vertical-align: sub; font-style: italic"> </span>using <i>array</i>,<i> </i><i>nextIndex</i>, and <i>enviro</i><i>nmen</i><i>t </i>as arguments.</p>
      <p>ArrayBindingPattern: <b>[ </b>BindingElementList<span style="vertical-align: sub; font-style: italic"> </span><b>, </b>Elision<sub>opt</sub>  BindingRestElement <span style="vertical-align: sub; font-style: italic"> </span><b>] </b></p>
      <p>Let <i>index</i> be the result of performing Indexed Binding Initialisation for BindingElementList<span style="vertical-align: sub; font-style: italic"> </span>using <i>array</i>,<i> </i><i>, nextIndex</i>, and <i>enviro</i><i>nmen</i><i>t</i> as arguments.</p>
      <p>If <i>index</i> is an abrupt completion, return <i>index</i>.</p>
      <p>If <i>Elision</i> is present, then let <i>skip</i> be the result of evaluating <i>Elision</i>, otherwise let <i>skip</i> be 0.</p>
      <p>Return the result of performing Indexed Binding Initialisation for BindingRestElement <span style="vertical-align: sub; font-style: italic"> </span>using <i>array, </i><i>index</i>+<i>skip</i> , and <i>enviro</i><i>nmen</i><i>t </i>as arguments.</p>
      <p>BindingElementList <b>: </b>Elision<sub>opt</sub><span style="font-weight: bold; font-style: italic"> </span>BindingElement<span style="vertical-align: sub; font-style: italic"> </span> </p>
      <p>If <i>Elision</i> is present, then let <i>skip</i> be the result of evaluating <i>Elision</i>, otherwise let <i>skip</i> be 0.</p>
      <p>Let <i>next</i><i> </i>be the result of performing Indexed Binding Initialisation for BindingElement<span style="vertical-align: sub; font-style: italic"> </span> using <i>array</i>, <i>nextIndex</i> +<i>skip</i> , and <i>enviro</i><i>nmen</i><i>t </i>as arguments.</p>
      <p>If <i>next</i> is an abrupt completion, return <i>next</i>.</p>
      <p>Return <i>index</i>+<i>skip</i>+1.</p>
      <p>BindingElementList <b>: </b>BindingElementList <b>,</b> Elision<sub>opt</sub><span style="font-weight: bold; font-style: italic"> </span>BindingElement<span style="vertical-align: sub; font-style: italic"> </span></p>
      <p>Let <i>listNext</i> be the result of performing Indexed Binding Initialisation for BindingElementList using <i> </i><i>array, nextIndex</i>, and <i>enviro</i><i>nment</i><i> </i>as arguments.</p>
      <p>If <i>next</i> is an abrupt completion, return <i>next</i>.</p>
      <p>If <i>Elision</i> is present, then let <i>skip</i> be the result of evaluating <i>Elision</i>, otherwise let <i>skip</i> be 0.</p>
      <p> Let <i>next</i><i> </i>be the result of performing Indexed Binding Initialisation for BindingElement<span style="vertical-align: sub; font-style: italic"> </span>using <i>array</i>,  <i>listNext</i>+<i>skip</i> , and <i>enviro</i><i>nmen</i><i>t </i>as arguments.</p>
      <p>If <i>listN</i><i>ext</i> is an abrupt completion, return <i>listN</i><i>ext</i>.</p>
      <p>Return <i>listNext</i>+<i>skip+</i>1.</p>
      <p>BindingElement<b>:</b> <i>SingleNameBinding</i> </p>
      <p>Return the result of performing Keyed Binding Initialisation for <i>SingleNameBinding</i> using  array, <i>environment</i>, and ToString(<i>nextIndex</i>) as the arguments.</p>
      <p>BindingElement<b>:</b> BindingPattern <i>Initialiser</i><sub>opt</sub> </p>
      <p>Let <i>P</i> be ToString(<i>nextIndex</i>).</p>
      <p>Let <i>exists</i> be the result of calling the [[HasProperty]] internal method of <i>array</i> with argument <i>P</i>. </p>
      <p>If <i>exists</i> is <b>true</b>, then</p>
      <p>Let <i>v</i> be the result of calling the [[Get]] internal method of <i>array</i> with argument <i>P</i>.</p>
      <p>Else </p>
      <p>If <i>Initialiser</i><sub>opt</sub> is present, then</p>
      <p>Let <i>v</i> be the result of evaluating<i> Initialiser</i>.</p>
      <p>Else,</p>
      <p> Let<i> v</i> be <b>undefined</b>.</p>
      <p>If <i>v</i> is an abrupt completion, return <i>v</i>.</p>
      <p>Return the result of performing Binding Initialisation for <i>BindingPattern</i> passing <i>v</i> and <i>environment </i>as arguments.</p>
      <p>BindingRestElement : <b>… </b>BindingIdentifier </p>
      <p>Let <i>A</i> be a new array object created as if by the expression <b>new Array()</b> where <b>Array</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>lenVal</i> be the result of calling the [[Get]] internal method of <i>array</i> with argument “<b>length</b>”.</p>
      <p>Let <i>arrayLength</i> be ToUint32(<i>lenVal</i>).</p>
      <p>If <i>arrayLength</i> is an abrupt completion, return <i>arrayLength</i>.</p>
      <p>Let <i>n</i>=0.</p>
      <p>Let <i>index</i> = <i>nextIndex</i>.</p>
      <p>Repeat, while <i>index</i> &lt; <i>arrayLength</i></p>
      <p>Let <i>P</i> be ToString(<i>index</i>).</p>
      <p>Let <i>exists</i> be the result of calling the [[HasProperty]] internal method of <i>array</i> with argument <i>P</i>.</p>
      <p>If <i>exists</i> is <b>true</b>, then</p>
      <p>Let <i>v</i> be the result of calling the [[Get]] internal method of <i>array</i> passing <i>P </i>as the argument.</p>
      <p>If <i>v</i> is an abrupt completion, return <i>v</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments ToString(<i>n</i>), Property Descriptor {[[Value]]: <i>v</i>.[[value]], [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Let <i>n</i> = <i>n</i>+1.</p>
      <p>Let <i>index</i> = <i>index</i>+1.</p>
      <p>Return the result of performing Binding Initialisation for <i>BindingIdentifer</i> using <i>array</i> and <i>environment </i>as arguments.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Keyed </b>
        <b>Binding </b>
        <b>Initialisation</b>
      </p>
      <p>With parameters <i>obj</i>, <i>environment, </i>and<i> </i> <i>propertyName</i>.</p>
      <p>NOTE	When <b>undefined</b> is passed for <i>environment</i> it indicates that a PutValue operation should be used to assign the initialisation value.  This is the the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name. </p>
      <p>BindingElement<b>:</b> <i>SingleNameBinding</i> </p>
      <p>Return the result of performing Keyed Binding Initialisation for <i>SingleNameBinding</i> using  obj, <i>environment</i>, and <i>propertyName</i> as the arguments.</p>
      <p>BindingElement<b>:</b> BindingPattern  <i>Initialiser</i><sub>opt</sub> </p>
      <p>Let <i>exists</i> be the result of calling the [[HasProperty]] internal method of <i>obj</i> with argument <i>propertyName</i>. </p>
      <p>If <i>exists</i> is <b>true</b>, then</p>
      <p>Let <i>v</i> be the result of calling the [[Get]] internal method of <i>obj</i> with argument <i>propertyName</i>.</p>
      <p>Else </p>
      <p>If <i>Initialiser</i><sub>opt</sub> is present, then</p>
      <p>Let <i>v</i> be the result of evaluating<i> Initialiser</i>.</p>
      <p>Else,</p>
      <p> Let<i> v</i> be <b>undefined</b>.</p>
      <p>If <i>v</i> is an abrupt completion, return <i>v</i>.</p>
      <p>Return the result of performing Binding Initialisation for <i>BindingPattern</i> passing <i>v</i> and <i>environment </i>as arguments.</p>
      <p><i>SingleNameBinding </i><b>:</b> BindingIdentifier <i>Initialiser</i><sub>opt</sub> </p>
      <p>Let <i>exists</i> be the result of calling the [[HasProperty]] internal method of <i>obj</i> with argument <i>propertyName</i>.</p>
      <p>If <i>exists</i> is <b>true</b>, then</p>
      <p>Let <i>v</i> be the result of calling the [[Get]] internal method of <i>obj</i> passing <i>propertyName</i><i> </i>as the argument.</p>
      <p>Else </p>
      <p>If <i>Initialiser</i><sub>opt</sub> is present, then</p>
      <p>Let <i>v</i> be the result of evaluating<i> Initialiser</i>.</p>
      <p>Else,</p>
      <p> Let<i> v</i> be <b>undefined</b>.</p>
      <p>If <i>v</i> is an abrupt completion, return <i>v</i>.</p>
      <p>Return the result of performing Binding Initialisation for <i>BindingIdentifer</i> passing <i>v</i> and <i>environment</i> as arguments.</p>
      <h2>12.3<span>	Empty Statemen</span>t</h2>
      <p>Syntax</p>
      <p>EmptyStatement <b>:</b></p>
      <p>
        <b>;</b>
      </p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p><i>EmptyStatement </i><b>:</b><i> </i><b>;</b> </p>
      <p>Return NormalCompletion(empty).</p>
      <h2>12.4<span>	Expression Statemen</span>t</h2>
      <p>Syntax</p>
      <p>ExpressionStatement <b>:</b></p>
      <p>[lookahead ∈ {<b>{</b>,<b> function</b>}] Expression <b>;</b></p>
      <p>NOTE<span>	An </span>ExpressionStatement cannot start with an opening curly brace because that might make it ambiguous with a Block. Also, an ExpressionStatement cannot start with the <b>function</b> keyword because that might make it ambiguous with a FunctionDeclaration.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p><i>ExpressionStatement </i><b>:</b><i> </i>[lookahead ∈ {<b>{</b><b>,</b><b> function</b>}]<i> Expression</i><b>;</b> </p>
      <p>Let <i>exprRef</i> be the result of evaluating <i>Expression</i>.</p>
      <p>Let <i>value</i> be GetValue(<i>exprRef</i>).</p>
      <p>If <i>value</i> is an abrupt completion, return <i>value</i>.</p>
      <p>Return NormalCompletion(<i>value</i>).</p>
      <h2>12.5<span>	The </span>if Statement</h2>
      <p>Syntax</p>
      <p>IfStatement <b>:</b></p>
      <p><b>if</b> <b>(</b> Expression <b>)</b> Statement  <b>else</b> Statement<br><b>if</b> <b>(</b> Expression <b>)</b> Statement</p>
      <p>Each <b>else</b> for which the choice of associated <b>if</b> is ambiguous shall be associated with the nearest possible <b>if</b> that would otherwise have no corresponding <b>else</b>.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>VarDeclaredNames</b>
      </p>
      <p><i>IfStatement </i><b>:</b><i> </i><b>if</b><i> </i><b>(</b><i> Expression </i><b>)</b><i> Statement </i><b>else</b><i> Statement</i> </p>
      <p>Let <i>names </i>be VarDeclaredNames of the first <i>Statement</i>.</p>
      <p>Append to <i>names</i> the elements of the VarDeclaredNames of the second <i>Statement</i>.</p>
      <p>Return names.</p>
      <p>
        <i>IfStatement </i>
        <b>:</b>
        <i> </i>
        <b>if</b>
        <i> </i>
        <b>(</b>
        <i> Expression </i>
        <b>)</b>
        <i> Statement </i>
      </p>
      <p>Return the VarDeclaredNames of <i>Statement</i>.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p><i>IfStatement </i><b>:</b><i> </i><b>if</b><i> </i><b>(</b><i> Expression </i><b>)</b><i> Statement </i><b>else</b><i> Statement</i> </p>
      <p>Let <i>exprRef</i> be the result of evaluating <i>Expression</i>.</p>
      <p>Let <i>exprValue</i> be ToBoolean(GetValue(<i>exprRef</i>)).</p>
      <p>If <i>exprValue</i> is an abrupt completion, return <i>exprValue</i>.</p>
      <p>If <i>exprValue</i> is <b>true</b>, then</p>
      <p>Return the result of evaluating the first <i>Statement</i>.</p>
      <p>Else,</p>
      <p>Return the result of evaluating the second <i>Statement</i>.</p>
      <p><i>IfStatement </i><b>:</b><i> </i><b>if</b><i> </i><b>(</b><i> Expression </i><b>)</b><i> Statement</i> </p>
      <p>Let <i>exprRef</i> be the result of evaluating <i>Expression</i>.</p>
      <p>Let <i>exprValue</i> be ToBoolean(GetValue(<i>exprRef</i>)).</p>
      <p>If <i>exprValue</i> is an abrupt completion, return <i>exprValue</i>.</p>
      <p>If <i>exprValue</i> is <b>false</b>, return NormalCompletion(<b>undefined</b>).</p>
      <p>Return the result of evaluating <i>Statement</i>.</p>
      <h2>12.6<span>	Iteration Statement</span>s</h2>
      <p>Syntax</p>
      <p>IterationStatement <b>:</b></p>
      <p><b>do </b>Statement<b> while</b> <b>(</b> Expression <b>)</b><b> </b><br><b>while</b> <b>(</b> Expression <b>)</b> Statement<br><b>for</b> <b>(</b>ExpressionNoIn<sub>opt</sub><b>;</b> Expression<sub>opt</sub> <b>;</b> Expression<sub>opt</sub> <b>)</b> Statement<br><b>for</b> <b>(</b> <b>var</b> VariableDeclarationListNoIn<b>;</b> Expression<sub>opt</sub> <b>;</b> Expression<sub>opt</sub> <b>)</b> Statement<br><b>for</b> <b>(</b> LexicalDeclarationNoIn<b>;</b> Expression<sub>opt</sub> <b>;</b> Expression<sub>opt</sub> <b>)</b> Statement<br><b>for</b> <b>(</b> LeftHandSideExpression <b>in</b> Expression <b>)</b> Statement<br><b>for</b> <b>(</b> <b>var</b> BindingIdentifer <b>i</b><b>n</b> Expression <b>)</b> Statement <br><b>for</b> <b>(</b> ForDeclaration  <b>in</b> Expression <b>)</b> Statement <br><b>for</b> <b>(</b> LeftHandSideExpression <b>of</b> Expression <b>)</b> Statement<br><b>for</b> <b>(</b> <b>var</b> ForVarDeclaration <b>o</b><b>f</b> Expression <b>)</b> Statement <br><b>for</b> <b>(</b> ForDeclaration  <b>of</b> Expression <b>)</b> Statement</p>
      <p>ForVarDeclaration <b>:</b></p>
      <p>BindingPattern<b><br></b>VariableDeclarationNoIn</p>
      <p>ForDeclaration <b>:</b></p>
      <p>LetOrConst  ForBinding </p>
      <p>ForBinding <b>:</b></p>
      <p>BindingIdentifier<b><br></b>BindingPattern  </p>
      <p>NOTE<span>	A semicolon is not required after a </span><b>do-while</b> statement. </p>
      <p>The abstract operation loopContinues with arguments <i>c</i><i>ompletion</i> and <i>labelSet</i> is defined by the following step:</p>
      <p>If <i>c</i><i>ompletion</i>.[[type]] is normal, then return <b>true</b>.</p>
      <p>If <i>c</i><i>ompletion</i>.[[type]] is not continue, then return <b>false</b>.</p>
      <p>If <i>c</i><i>ompletion</i>.[[target]] is empty, then return <b>true</b>.</p>
      <p>If <i>c</i><i>ompletion</i>.[[target]] is an element of <i>labelSet</i>, then return <b>true</b>.</p>
      <p>Return <b>false</b>.</p>
      <h2>12.6.1<span>	The </span>do-while Statement</h2>
      <p>
        <b>Static Semantics:  </b>
        <b>VarDeclaredNames</b>
      </p>
      <p><i>IterationStatement </i><b>:</b><i> </i><b>do </b><i>Statement </i><b>while</b><i> </i><b>(</b><i> Expression </i><b>);</b> <i> </i></p>
      <p>Return the VarDeclaredNames of <i>Statement</i>.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Labelled Evaluation</b>
      </p>
      <p>With argument <i>l</i><i>abelSet</i>.</p>
      <p><i>IterationStatement </i><b>:</b><i> </i><b>do </b><i>Statement </i><b>while</b><i> </i><b>(</b><i> Expression </i><b>);</b> </p>
      <p>Let <i>V</i> = <b>undefined</b><b></b><b>.</b></p>
      <p>Repeat </p>
      <p>Let <i>stmt</i> be the result of evaluating <i>Statement</i>.</p>
      <p>If <i>stmt</i>.[[value]] is not empty, let <i>V</i> = <i>stmt</i>.[[value]]<i>.</i></p>
      <p>If <i>stmt</i> is an abrupt completion and loopContinues (<i>stmt</i>,<i>labelSet</i>) is <b>false</b>, return <i>stmt</i>.</p>
      <p>Let <i>exprRef</i> be the result of evaluating <i>Expression</i>.</p>
      <p>Let <i>exprValue</i> be ToBoolean(GetValue(<i>exprRef</i>)).</p>
      <p>If <i>exprValue</i> is <b>false</b>, Return NormalCompletion(<i>V</i>).</p>
      <p>Else if <i>exprValue</i> is a Completion Record, then</p>
      <p>Assert: <i>exprValue</i> is an abrupt completion.</p>
      <p>If  loopContinues (<i>exprValue</i>,<i>labelSet</i>) is <b>false</b>, return <i>exprV</i><i>alue.</i></p>
      <h2>12.6.2<span>	The </span>while Statement</h2>
      <p>
        <b>Static Semantics:  </b>
        <b>VarDeclaredNames</b>
      </p>
      <p>
        <i>IterationStatement </i>
        <b>:</b>
        <i> </i>
        <b>while</b>
        <i> </i>
        <b>(</b>
        <i> Expression </i>
        <b>)</b>
        <i> </i>
      </p>
      <p>Return the VarDeclaredNames of <i>Statement</i>.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Labelled Evaluation</b>
      </p>
      <p>With argument <i>l</i><i>abelSet</i>.</p>
      <p><i>IterationStatement </i><b>:</b><i> </i><b>while</b><i> </i><b>(</b><i> Expression </i><b>)</b><i> Statement</i> </p>
      <p>Let <i>V</i> = <i>undefined</i>.</p>
      <p>Repeat</p>
      <p>Let <i>exprRef</i> be the result of evaluating <i>Expression</i>.</p>
      <p>Let <i>exprValue</i> be ToBoolean(GetValue(<i>exprRef</i>)).</p>
      <p>If <i>exprValue</i> is <b>false</b>, return NormalCompletion(<i>V</i>).</p>
      <p>Else if <i>exprValue</i> is a Completion Record, then</p>
      <p>Assert: <i>exprValue</i> is an abrupt completion.</p>
      <p>If  loopContinues (<i>exprValue</i>,<i>labelSet</i>) is <b>false</b>, return <i>exprV</i><i>alue.</i></p>
      <p>Let <i>stmt</i> be the result of evaluating <i>Statement</i>.</p>
      <p>If <i>stmt</i>.[[value]] is not empty, let <i>V</i> = <i>stmt</i>.[[value]].</p>
      <p>If loopContinues (<i>stmt</i>,<i>labelSet</i>) is <b>false</b>, return <i>stmt</i>.</p>
      <h2>12.6.3	The for Statement</h2>
      <p>
        <b>Static Semantics:  </b>
        <b>VarDeclaredNames</b>
      </p>
      <p><b>for</b> <b>(</b>ExpressionNoIn<sub>opt</sub> <b>;</b> Expression<sub>opt</sub> <b>;</b> Expression<sub>opt</sub><b>)</b> Statement <i> </i></p>
      <p>Return the VarDeclaredNames of <i>Statement</i>.</p>
      <p>IterationStatement <b>:</b>  <b>for</b> <b>(</b> <b>var</b> VariableDeclarationListNoIn <b>;</b> Expression<sub>opt</sub><i> </i><b>;</b> Expression<sub>opt</sub><i> </i><b>)</b> Statement<b> </b></p>
      <p>Let <i>names </i>be BoundNames of VariableDeclarationListNoIn.</p>
      <p>Append to <i>names</i> the elements of the VarDeclaredNames of <i>Statement</i>.</p>
      <p>Return names.</p>
      <p><b>for</b> <b>(</b>LexicalDeclarationNoIn<b>;</b> Expression<sub>opt</sub> <b>;</b> Expression<sub>opt</sub><b>)</b> Statement <i> </i></p>
      <p>Return the VarDeclaredNames of <i>Statement</i>.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Labelled Evaluation</b>
      </p>
      <p>With argument <i>l</i><i>abelSet</i>.</p>
      <p>IterationStatement <b>:</b> <b>for</b> <b>(</b>ExpressionNoIn<sub>opt</sub> <b>;</b> Expression<sub>opt</sub> <b>;</b> Expression<sub>opt</sub><b>)</b> Statement</p>
      <p>If <i>ExpressionNoIn</i> is present, then.</p>
      <p>Let <i>exprRef</i> be the result of evaluating <i>ExpressionNoIn</i>.</p>
      <p>Let <i>exprValue</i> be GetValue(<i>exprRef</i>). (This value is not used but the call may have side-effects.)</p>
      <p>If loopContinues(<i>exprValue</i>,<i>labelSet</i>) is <b>false</b>, return <i>exprV</i><i>alue.</i></p>
      <p>Return the result of performing For Body Evaluation with the first <i>Expression</i> as the <i>incrementExpr</i> argument, the second <i>Expression</i> as the <i>testExpr</i> argument and with <i>labelSet</i>.  </p>
      <p>
      </p>
      <p>The abstraction operation For Body Evaluation with arguments <i>testExpr</i>, <i>incrementExpr</i>, and <i>labelSet</i> is performed as follows:</p>
      <p>Let <i>V</i> = <b>undefined</b>,.</p>
      <p>Repeat</p>
      <p>If <i>testExpr</i> is not [empty], then</p>
      <p>Let <i>testExprRef</i> be the result of evaluating <i>testExpr</i>.</p>
      <p>Let <i>testE</i><i>xprValue</i> be ToBoolean(GetValue(<i>testExprRef</i>))</p>
      <p>If <i>testE</i><i>xprValue</i> is <b>false</b>, return NormalCompletion(<i>V</i>).</p>
      <p>Else loopContinues (<i>testE</i><i>xprValue</i>,<i>labelSet</i>) is <b>false</b>, return <i>testE</i><i>xprValue</i><i>.</i></p>
      <p>Let <i>stmt</i> be the result of evaluating <i>Statement</i>.</p>
      <p>If <i>stmt</i>.[[value]] is not empty, let <i>V</i> = <i>stmt</i>.[[value]].</p>
      <p>If <i>stmt</i> loopContinues (<i>stmt</i>,<i>labelSet</i>) is <b>false</b>, return <i>stmt</i>.</p>
      <p>If <i>incrementExpr</i><i> </i>is not [empty], then</p>
      <p>Let <i>incExprRef</i> be the result of evaluating <i>incrementExpr</i>.</p>
      <p>Let <i>incExpr</i><i>Value</i> be GetValue(<i>incExprRef</i>). </p>
      <p>If loopContinues(<i>incExprValue</i>,<i>labelSet</i>) is <b>false</b>, return <i>incExprValue</i><i>.</i></p>
      <p>IterationStatement <b>:</b>  <b>for</b> <b>(</b> <b>var</b> VariableDeclarationListNoIn <b>;</b> Expression<sub>opt</sub><i> </i><b>;</b> Expression<sub>opt</sub><i> </i><b>)</b> Statement</p>
      <p>Let <i>varDcl</i> be the result of evaluating <i>VariableDeclarationListNoIn</i>.</p>
      <p>If loopContinues(<i>varDcl</i>,<i>labelSet</i>) is <b>false</b>, return <i>varDcl</i>.</p>
      <p>Return the result of performing For Body Evaluation with the first <i>Expression</i> as the <i>incrementExpr</i> argument, the second <i>Expression</i> as the <i>testExpr</i> argument and with <i>labelSet</i>.  </p>
      <p>IterationStatement <b>:</b>  <b>for</b> <b>(</b><b> </b>LexicalDeclarationNoIn <b>;</b> Expression<sub>opt</sub><i> </i><b>;</b> Expression<sub>opt</sub><i> </i><b>)</b> Statement</p>
      <p>Let <i>oldEnv</i> be the running execution context’s LexicalEnvironment.</p>
      <p>Let <i>loop</i><i>Env</i> be the result of calling NewDeclarativeEnvironment passing <i>oldEnv</i> as the argument.</p>
      <p>Let <i>isConst</i> be the the result of performing IsConstantDeclaration of <i>d</i>.</p>
      <p>For each element <i>dn</i> of the BoundNames of LexicalDeclarationNoIn do</p>
      <p>If <i>isConst</i> is <b>true</b>, then</p>
      <p>Call <i>loop</i><i>Env</i>’s CreateImmutableBinding concrete method passing <i>dn </i>as the argument.</p>
      <p>Else,</p>
      <p>Call <i>loop</i><i>Env</i>’s CreateMutableBinding concrete method passing <i>dn </i>and <b>false</b> as the arguments.</p>
      <p>Set the running <b>execution</b> context’s LexicalEnvironment to <i>loop</i><i>Env</i>.</p>
      <p>Let <i>for</i><i>Dcl</i> be the result of evaluating <i>Lexical</i><i>DeclarationNoIn</i>.</p>
      <p>If loopContinues(<i>varDcl</i>,<i>labelSet</i>) is <b>false</b>, then</p>
      <p>Set the running <b>execution</b> context’s LexicalEnvironment to <i>oldEnv</i>.</p>
      <p>Return <i>varDcl</i>.</p>
      <p>Let <i>bodyResult</i> be the result of performing For Body Evaluation with the first <i>Expression</i> as the <i>incrementExpr</i> argument, the second <i>Expression</i> as the <i>testExpr</i> argument and with <i>labelSet</i>.</p>
      <p>Set the running <b>execution</b> context’s LexicalEnvironment to <i>oldEnv</i>.</p>
      <p>Return  <i>bodyResult</i>.</p>
      <h2>12.6.4<span>	The </span>for-in and for-of Statements</h2>
      <h2>Static Semantics</h2>
      <p>
        <b>Static Semantics:  Early Errors</b>
      </p>
      <p><i>IterationStatement</i> <b>:</b> </p>
      <p><b>for</b> <b>(</b>LeftHandSideExpression  <b>in</b> Expression <b>)</b> Statement </p>
      <p><b>for</b> <b>(</b>LeftHandSideExpression  <b>of</b> Expression <b>)</b> Statement </p>
      <p>It is a Syntax Error if the IterationStatement is contained in strict code and LeftHandSideExpression is the Identifier <b>eval</b> or the Identifier <b>arguments</b>.</p>
      <p>It is a Syntax Error if the LeftHandSideExpression is an Identifier that statically resolves to a declarative environment record binding and the resolved binding is an immutable binding.</p>
      <p>It is a Syntax Error if the LeftHandSideExpression is PrimaryExpression : <b>(</b> Expression<b> ) </b>and Expression derived a production that would produce a Syntax Error according to these rules. This rule is recursively applied.</p>
      <p>It is a Syntax Error if the LeftHandSideExpression is an ObjectLiteral or an<i> </i>ArrayLiteral<i> </i>and the source code corresponding to LeftHandSideExpression cannot be parsed using AssignmentPattern as the goal symbol.</p>
      <p><i>IterationStatement</i> <b>:</b> </p>
      <p><b>for</b> <b>(</b>ForDeclaration <b>in</b> Expression <b>)</b> Statement </p>
      <p><b>for</b> <b>(</b>ForDeclaration <b>of</b> Expression <b>)</b> Statement </p>
      <p>It is a Syntax Error if any element of the Lexically Declared Names of <i>ForDeclaration</i> also occurs in the Var Declared Names of <i>Statement</i>.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>Bound</b>
        <b> </b>
        <b>Names</b>
      </p>
      <p>
        <i>For</i>
        <i>Var</i>
        <i>Declaration</i>
        <i> </i>
        <b>:</b>
        <i> </i>
        <i>BindingPattern</i>
        <i> </i>
      </p>
      <p>Return the Bound Names of <i>BindingPattern</i>.</p>
      <p><i>For</i><i>Var</i><i>Declaration</i><i> </i><b>:</b><i> </i><i>VariableDeclarationNoIn</i> </p>
      <p>Return the Bound Names of <i>VariableDeclarationNoIn</i>.</p>
      <p>
        <i>ForDeclaration</i>
        <i> </i>
        <b>:</b>
        <i> </i>
        <i>LetOrConst</i>
        <span style="font-weight: bold; font-style: italic"> </span>
        <i>For</i>
        <i>Binding </i>
      </p>
      <p>Return the Bound Names of <i>For</i><i>Binding</i>.</p>
      <p>
        <i>For</i>
        <i>Binding</i>
        <i> </i>
        <b>:</b>
        <i> Binding</i>
        <i>Identifier</i>
        <i> </i>
      </p>
      <p>Return the Bound Names of <i>BindingIdentifier</i>.</p>
      <p>
        <i>ForDeclaration</i>
        <i> </i>
        <b>:</b>
        <i> Binding</i>
        <i>Pattern</i>
      </p>
      <p>Return the Bound Names of <i>Binding</i><i>Pattern</i>.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>Var</b>
        <b> </b>
        <b>Declared</b>
        <b> </b>
        <b>Names</b>
      </p>
      <p><i>IterationStatement</i> <b>:</b> <b>for</b> <b>(</b><b> </b>LeftHandSideExpression <b>in</b> Expression <b>)</b> Statement </p>
      <p>Return the Var Declared Names of <i>Statement</i>.</p>
      <p><i>IterationStatement</i> <b>:</b> <b>for</b> <b>(</b> <b>var</b> <i>BindingIdentifier</i> <b>in</b> <i>Expression</i> <b>)</b> <i>Statement</i></p>
      <p>Let <i>names </i>be the Bound Names of <i>BindingIdentifier</i>.</p>
      <p>Append to <i>names</i> the elements of the Var Declared Names of <i>Statement</i>.</p>
      <p>Return names</p>
      <p><i>IterationStatement</i> <b>:</b> <b>for</b> <b>(</b><b> </b>ForDeclaration <b>in</b> Expression <b>)</b> Statement </p>
      <p>Return the Var Declared Names of <i>Statement</i>.</p>
      <p><i>IterationStatement</i> <b>:</b> <b>for</b> <b>(</b><b> </b>LeftHandSideExpression <b>of</b> Expression <b>)</b> Statement </p>
      <p>Return the Var Declared Names of <i>Statement</i>.</p>
      <p><i>IterationStatement</i> <b>:</b> <b>for</b> <b>(</b> <b>var</b> <i>ForVarDeclaration</i> <b>of</b> <i>Expression</i> <b>)</b> <i>Statement</i></p>
      <p>Let <i>names </i>be the Bound Names of <i>ForVarDeclaration</i>.</p>
      <p>Append to <i>names</i> the elements of the Var Declared Names of <i>Statement</i>.</p>
      <p>Return names</p>
      <p><i>IterationStatement</i> <b>:</b> <b>for</b> <b>(</b><b> </b>ForDeclaration <b>of</b> Expression <b>)</b> Statement </p>
      <p>Return the Var Declared Names of <i>Statement</i>.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Binding </b>
        <b>Instantiation</b>
      </p>
      <p>With arguments <i>value</i> and <i>environment</i>.</p>
      <p>
        <i>ForDeclaration</i>
        <i> </i>
        <b>:</b>
        <i> </i>
        <i> </i>
        <i>LetOrConst</i>
        <span style="font-weight: bold; font-style: italic"> </span>
        <i>ForBinding</i>
        <i> </i>
      </p>
      <p>For each element <i>name</i> of the Bound Names of <i>ForBinding</i> do</p>
      <p>If IsConstantDeclaration of <i>LetOrConst</i> is <b>false</b>, then</p>
      <p>Call <i>environment</i>’s CreateMutableBinding concrete method with argument <i>name</i>.</p>
      <p>Else, </p>
      <p>Call <i>environment</i>’s CreateImmutableBinding concrete method with argument <i>name</i>.</p>
      <p>Perform Binding Initialisation for <i>For</i><i>Binding</i> passing<i> </i><i>value</i> and <i>environment</i> as the arguments.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Binding </b>
        <b>Initialisation</b>
      </p>
      <p>With arguments <i>value</i> and <i>environment</i>.</p>
      <p>NOTE	<b>undefined</b> is passed for <i>environment</i> to indicate that a PutValue operation should be used to assign the initialisation value.  This is the the case for <b>var</b> statements formal parameter lists of non-strict functions. In those cases a lexical binding is hosted and preinitialized prior to evaluation of its initializer. </p>
      <p>
        <i>For</i>
        <i>Var</i>
        <i>Declaration</i>
        <i> </i>
        <b>:</b>
        <i> </i>
        <i>BindingPattern</i>
        <i> </i>
      </p>
      <p>Perform Binding Initialisation for <i>BindingPattern</i> passing<i> </i><i>value</i> and <i>env</i> as the arguments.</p>
      <p><i>For</i><i>Var</i><i>Declaration</i><i> </i><b>:</b><i> </i><i>VariableDeclarationNoIn</i> </p>
      <p>Perform Binding Initialisation for <i>VariableDeclarationNoIn</i> passing<i> </i><i>value</i> and <i>env</i> as the arguments.</p>
      <p>
        <i>For</i>
        <i>Binding </i>
        <b>:</b>
        <i> </i>
        <i>BindingIdentifier</i>
        <i> </i>
      </p>
      <p>Perform Binding Initialisation for <i>BindingIdentifier </i> passing<i> </i><i>value</i> and <i>env</i> as the arguments.</p>
      <p>
        <i>For</i>
        <i>Binding</i>
        <b>:</b>
        <i> </i>
        <i>BindingPattern</i>
      </p>
      <p>Perform Binding Initialisation for <i>BindingPattern</i> passing<i> </i><i>value</i> and <i>env</i> as the arguments.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Labelled Evaluation</b>
      </p>
      <p>With argument <i>l</i><i>abelSet</i>.</p>
      <p>IterationStatement <b>:</b> <b>for</b> <b>(</b><b> </b>LeftHandSideExpression <b>in</b> Expression <b>)</b> Statement </p>
      <p>Let <i>keyResult</i> be the result of performing For In/Of Expression Evalation with  <i>Statement</i>, enumerate, and <i>labelSet</i>.</p>
      <p>ReturnIfAbrupt(<i>keyResult</i>).</p>
      <p>Return the result of performing For In/Of Body Evalation with  LeftHandSideExpression, <i>Statement</i>, <i>keyResult</i>.[[value]],  assignment, and <i>labelSet</i>.</p>
      <p><i>IterationStatement</i> <b>:</b> <b>for</b> <b>(</b> <b>var</b> <i>BindingIdentifier</i><i> </i> <b>in</b> <i>Expression</i> <b>)</b> <i>Statement</i></p>
      <p>Let <i>keyResult</i> be the result of performing For In/Of Expression Evalation with  <i>Statement</i>, enumerate, and <i>labelSet</i>.</p>
      <p>ReturnIfAbrupt(<i>keyResult</i>).</p>
      <p>Return the result of performing For In/Of Body Evalation with  <i>BindingIdentifier</i>, <i>Statement</i>, <i>keyResult</i>.[[value]],  varBinding, and <i>labelSet</i>.</p>
      <p><i>IterationStatement</i> <b>:</b> <b>for</b> <b>(</b><i>ForDeclaration</i> <b>in</b> <i>Expression</i> <b>)</b> <i>Statement</i></p>
      <p>Let <i>keyResult</i> be the result of performing For In/Of Expression Evalation with  <i>Statement</i>, enumerate, and <i>labelSet</i>.</p>
      <p>ReturnIfAbrupt(<i>keyResult</i>).</p>
      <p>Return the result of performing For In/Of Body Evalation with  <i>ForDeclaration</i>, <i>Statement</i>, <i>keyResult</i>.[[value]],  ForDeclaration, and <i>labelSet</i>.</p>
      <p>IterationStatement <b>:</b> <b>for</b> <b>(</b><b> </b>LeftHandSideExpression <b>of</b> Expression <b>)</b> Statement </p>
      <p>Let <i>keyResult</i> be the result of performing For In/Of Expression Evalation with  <i>Statement</i>, iterate, and <i>labelSet</i>.</p>
      <p>ReturnIfAbrupt(<i>keyResult</i>).</p>
      <p>Return the result of performing For In/Of Body Evalation with  LeftHandSideExpression, <i>Statement</i>, <i>keyResult</i>.[[value]],  assignment, and <i>labelSet</i>.</p>
      <p><i>IterationStatement</i> <b>:</b> <b>for</b> <b>(</b> <b>var</b> <i>BindingIdentifier</i><i> </i> <b>of</b> <i>Expression</i> <b>)</b> <i>Statement</i></p>
      <p>Let <i>keyResult</i> be the result of performing For In/Of Expression Evalation with  <i>Statement</i>, iterate, and <i>labelSet</i>.</p>
      <p>ReturnIfAbrupt(<i>keyResult</i>).</p>
      <p>Return the result of performing For In/Of Body Evalation with  <i>BindingIdentifier</i>, <i>Statement</i>, <i>keyResult</i>.[[value]],  varBinding, and <i>labelSet</i>.</p>
      <p><i>IterationStatement</i> <b>:</b> <b>for</b> <b>(</b><i>ForDeclaration</i> <b>of</b> <i>Expression</i> <b>)</b> <i>Statement</i></p>
      <p>Let <i>keyResult</i> be the result of performing For In/Of Expression Evalation with  <i>Statement</i>, iterate, and <i>labelSet</i>.</p>
      <p>ReturnIfAbrupt(<i>keyResult</i>).</p>
      <p>Return the result of performing For In/Of Body Evalation with  <i>ForDeclaration</i>, <i>Statement</i>, <i>keyResult</i>.[[value]],  ForDeclaration, and <i>labelSet</i>.</p>
      <p>The abstraction operation For In/Of Expression Evaluation with arguments <i>expr</i>, <i>iterationKind</i>, and <i>labelSet</i> is performed as follows:</p>
      <p>Let <i>exprRef</i> be the result of evaluating the production that is <i>expr</i>.</p>
      <p>Let <i>experValue</i> be GetValue(<i>exprRef</i>).</p>
      <p>If <i>experValue</i> is an abrupt completion, then return </p>
      <p>If loopContinues(<i>experValue</i>,<i>labelSet</i>) is <b>false</b>, then return <i>experValue</i>.</p>
      <p>Else, return Completion{type: break, value: <b>undefined</b>, target: empty}.</p>
      <p>If <i>experValue</i>.[value]] is <b>null</b> or <b>undefined</b>, return Completion{type: break, value: <b>undefined</b>, target: empty}..</p>
      <p>Let <i>obj</i> be ToObject(<i>experValue</i>).</p>
      <p>If <i>iterationKind</i> is enumerate, then</p>
      <p>Let <i>keys</i> be the result of calling the [[Enumerate]] internal method of <i>obj</i> with arguments <b>true</b> and <b>true</b>.</p>
      <p>Else,</p>
      <p>Assert <i>iterationKind</i> is iterate.</p>
      <p>Let <i>keys</i> be the result of calling the [[Iterate]] internal method of <i>obj</i>.</p>
      <p>If <i>keys</i> is an abrupt completion, then</p>
      <p>If LoopContinues(<i>experValue</i>,<i>labelSet</i>) is <b>false</b>, then return <i>experValue</i>.</p>
      <p>Asset:   <i>keys</i>.[[type]] is continue</p>
      <p>Return Completion{type: break, value: <b>undefined</b>, target: empty}.</p>
      <p>Return <i>keys</i>.</p>
      <p>The abstraction operation For In/Of Body Evaluation with arguments <i>lhs</i>, <i>stmt</i><i>,</i><i> keys,</i> <i>lhsKind</i>, and <i>labelSet</i> is performed as follows:</p>
      <p>Let <i>oldEnv</i> be the running execution context’s LexicalEnvironment.</p>
      <p>Let <i>V</i> = <b>undefined</b>).</p>
      <p>Repeat</p>
      <p>Let <i>next</i> be the result of performing Invoke with arguments <b>"</b><b>next</b><b>"</b>, <i>keys</i>, and an empty arguments List.</p>
      <p>If IteratorComplete(<i>next</i>) is <i>true</i>, the return NormalCompletion(<i>V</i>).</p>
      <p>If loopContinues(<i>next</i>,<i>labelSet</i>) is <b>false</b>, then return <i>next</i>.</p>
      <p>If <i>next</i> is an abrupt completion, then let <i>status</i> be next.</p>
      <p>Else,</p>
      <p>Assert <i>next</i>.[[type]] is normal.</p>
      <p>Let <i>nextValue</i> be <i>next</i>.[[value]].</p>
      <p>If <i>lhs</i><i>Kind</i> is assignment, then</p>
      <p>If <i>lhs</i> is neither an <i>ObjectLiteral</i> nor an<i> ArrayLiteral  </i>then</p>
      <p>Let <i>lhsRef</i> be the result of evaluating the <i>LeftHandSideExpression</i> ( it may be evaluated repeatedly).</p>
      <p>Let <i>status</i> be the result of performing PutValue(<i>lhsRef</i>, <i> nextValue</i>).</p>
      <p>Else</p>
      <p>Let <i>AssignmentPattern</i> be the parse of the source code corresponding to <i>lhs</i> using <i>AssignmentPattern</i> as the goal symbol.</p>
      <p>Let <i>rval</i> be ToObject(<i>nextValue</i>).</p>
      <p>If <i>rval</i> is an abrupt completion, then let <i>status</i> be <i>rval</i>.</p>
      <p>Else, let <i>status</i> be the result of performing Destructuring Assignment Evaluation of <i>AssignmentPattern</i> using <i>rval</i> as the argument.</p>
      <p>Else if <i>lhs</i><i>Kind</i> is varBinding, then</p>
      <p>Let <i>status</i> be the result of performing Binding Initialisation for <i>lhs</i><i> </i>passing<i> </i><i>nextValue</i> and <b>undefined</b> as the arguments.</p>
      <p>Else, </p>
      <p>Asset <i>lhsKind</i> is ForDeclaration.</p>
      <p>Let <i>iteration</i><i>Env</i> be the result of calling NewDeclarativeEnvironment passing <i>oldEnv</i> as the argument.</p>
      <p>Perform Binding Instantiation for <i>lhs</i> passing <i>nextValue</i> and <i>iteration</i><i>Env</i> as arguments.</p>
      <p>Let <i>status</i> be NormalCompletion(empty)</p>
      <p>Set the running <b>execution</b> context’s LexicalEnvironment to <i>iteration</i><i>Env</i>.</p>
      <p>If <i>status</i>.[[type]] is normal, then</p>
      <p>Let <i>status</i> be the result  of evaluating <i>stmt</i>.</p>
      <p>If <i>status</i>.[[type]] is normal and <i>status</i>.[[value]] not empty, then </p>
      <p>Let <i>V</i> = <i>status</i>.[[value]].</p>
      <p>Set the running <b>execution</b> context’s LexicalEnvironment to <i>oldEnv</i>.</p>
      <p>If <i>status</i> is an abrupt completion and  loopContinues(<i>status</i>,<i>labelSet</i>) is <b>false</b>, then return <i>status</i>.</p>
      <p>
      </p>
      <h2>12.7<span>	The </span>continue Statement</h2>
      <p>Syntax</p>
      <p>ContinueStatement <b>:</b></p>
      <p><b>continue ;</b><b><br>continue </b>[no LineTerminator here] Identifier<b>;</b></p>
      <h2>Static Semantics</h2>
      <p>
        <b>Static Semantics:  Early Errors</b>
      </p>
      <p><i>ContinueStatement</i><i> </i><b>:</b><i> </i><b>continue ;</b> </p>
      <p>It is a Syntax Error if this production is not nested, directly or indirectly (but not crossing function boundaries), within an <i>IterationStatement</i>.</p>
      <p><i>ContinueStatement</i><i> </i><b>:</b><i> </i><b>continue</b><span style="font-weight: bold; font-style: italic"> </span>[no<i> </i><i>LineTerminator</i><i> </i>here] <i>Identifier</i><b>;</b> </p>
      <p>It is a Syntax Error if <i>Identifier</i> does not appear in the <i>CurrentLabelSet</i> of an enclosing (but not crossing function boundaries) <i>IterationStatement</i>.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p><i>ContinueStatement</i><i> </i><b>:</b><i> </i><b>continue ;</b> </p>
      <p>Return Completion {[[type]]: continue, [[value]]: empty, [[target]]: empty}.</p>
      <p><i>ContinueStatement</i><i> </i><b>:</b><i> </i><b>continue</b><span style="font-weight: bold; font-style: italic"> </span>[no<i> </i><i>LineTerminator</i><i> </i>here] <i>Identifier</i><b>;</b> </p>
      <p>Return Completion {[[type]]: continue, [[value]]: empty, [[target]]: <i>Identifier</i>}.</p>
      <h2>12.8<span>	The </span>break Statement</h2>
      <p>Syntax</p>
      <p>BreakStatement <b>:</b></p>
      <p><b>break ;</b><b><br>break</b><b> </b>[no LineTerminator here] Identifier <b>;</b></p>
      <h2>Static Semantics</h2>
      <p>
        <b>Static Semantics:  Early Errors</b>
      </p>
      <p><i>BreakStatement</i><i> </i><b>:</b><i> </i><b>break ;</b> </p>
      <p>It is a Syntax Error if this production not nested, directly or indirectly (but not crossing function boundaries), within an <i>IterationStatement</i> or a <i>SwitchStatement</i>.</p>
      <p><i>BreakStatement</i><i> </i><b>:</b><i> </i><b>break</b><span style="font-weight: bold; font-style: italic"> </span>[no<i> </i><i>LineTerminator</i><i> </i>here] <i>Identifier</i><b>;</b> </p>
      <p>It is a Syntax Error if <i>Identifier</i> does not appear in the <i>CurrentLabelSet</i> of an enclosing (but not crossing function boundaries) <i>Statement</i>.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p><i>BreakStatement</i><i> </i><b>:</b><i> </i><b>break ;</b> </p>
      <p>Return Completion {[[type]]: break, [[value]]: empty, [[target]]: empty}.</p>
      <p><i>BreakStatement</i><i> </i><b>:</b><i> </i><b>break</b><span style="font-weight: bold; font-style: italic"> </span>[no<i> </i><i>LineTerminator</i><i> </i>here] <i>Identifier</i><b>;</b> </p>
      <p>Return Completion {[[type]]: break, [[value]]: empty,<i> </i>[[target]]: <i>Identifier</i>}.</p>
      <h2>12.9<span>	The </span>return Statement</h2>
      <p>Syntax</p>
      <p>ReturnStatement <b>:</b></p>
      <p><b>return ;</b><b><br>return </b>[no LineTerminator here]<b> </b>Expression <b>;</b></p>
      <p>NOTE<span>	A </span><b>return</b> statement causes a function to cease execution and return a value to the caller. If <i>Expression</i> is omitted, the return value is <b>undefined</b>. Otherwise, the return value is the value of <i>Expression</i>.</p>
      <p>
        <b>Static Semantics</b>
      </p>
      <p>
        <b>Static Semantics:  Early Errors</b>
      </p>
      <p>It is a Syntax Error if a <b>return</b> statement that is not within a <i>FunctionBody</i>. </p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p><i>ReturnStatement </i><i> </i><b>:</b><b> </b><i> </i><b>return</b><b> ;</b> </p>
      <p>Return Completion {[[type]]: return, [[value]]: <i> </i><b>undefined</b>, [[target]]: <i> </i>empty}.</p>
      <p><i>ReturnStatement</i><i> </i><b>:</b><i> </i><b>return</b><b> </b>[no<i> </i><i>LineTerminator</i><i> </i>here] <i>Expression</i><b>;</b> </p>
      <p>Let <i>exprRef</i> be the result of evaluating <i>Expression</i>.</p>
      <p>Let <i>exprValue</i> be GetValue(<i>exprRef</i>).</p>
      <p>If <i>exprValue</i> is an abrupt completion, return <i>exprValue</i>.</p>
      <p>Return Completion {[[type]]: return, [[value]]: <i> </i><i>exprValue</i>, [[target]]: empty}.</p>
      <h2>12.10<span>	The </span>with Statement</h2>
      <p>Syntax</p>
      <p>WithStatement <b>:</b></p>
      <p><b>with</b> <b>(</b> Expression <b>)</b> Statement</p>
      <p>NOTE	The <b>with </b>statement adds an object environment record for a computed object to the lexical environment of the current execution context. It then executes a statement using this augmented lexical environment. Finally, it restores the original lexical environment.</p>
      <p>
        <b>Static Semantics</b>
      </p>
      <p>
        <b>Static Semantics:  Early Errors</b>
      </p>
      <p><i>WithStatement </i><b>:</b><i> </i><b>with</b><i> </i><b>(</b><i> Expression </i><b>)</b><i> Statement</i> </p>
      <p>It is a Syntax Error if the code that matches this production is contained in strict code.  </p>
      <p>
        <b>Static Semantics:  </b>
        <b>VarDeclaredNames</b>
      </p>
      <p><i>WithStatement </i><b>:</b><i> </i><b>with</b><i> </i><b>(</b><i> Expression </i><b>)</b><i> Statement</i> </p>
      <p>Return the VarDeclaredNames of <i>Statement</i>.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p><i>WithStatement </i><b>:</b><i> </i><b>with</b><i> </i><b>(</b><i> Expression </i><b>)</b><i> Statement</i> </p>
      <p>Let <i>val</i> be the result of evaluating <i>Expression</i>.</p>
      <p>Let <i>obj</i> be ToObject(GetValue(<i>val</i>)).</p>
      <p>If <i>obj</i> is an abrupt completion, return <i>obj</i>.</p>
      <p>Let <i>oldEnv</i> be the running execution context’s LexicalEnvironment.</p>
      <p>Let <i>newEnv</i> be the result of calling NewObjectEnvironment passing <i>obj</i> and <i>oldEnv</i> as the arguments.</p>
      <p>Set the <i>provideThis</i> flag of <i>newEnv</i> to <b>true</b>.</p>
      <p>Set the running execution context’s LexicalEnvironment to <i>newEnv</i>.</p>
      <p>Let <i>C </i>be the result of evaluating <i>Statement</i>.<i> </i></p>
      <p>Set the running execution context’s Lexical Environment to <i>oldEnv</i>.</p>
      <p>Return <i>C</i>.</p>
      <p>NOTE<span>	No matter how control leaves the embedded </span>Statement, whether normally or by some form of abrupt completion or exception, the LexicalEnvironment is always restored to its former state.</p>
      <h2>12.11<span>	The </span>switch Statement</h2>
      <p>Syntax</p>
      <p>SwitchStatement <b>:</b></p>
      <p><b>switch</b> <b>(</b> Expression <b>)</b> CaseBlock</p>
      <p>CaseBlock <b>:</b></p>
      <p><b>{</b> CaseClauses<sub>opt</sub> <b>}</b><br><b>{</b> CaseClauses<sub>opt</sub> DefaultClause CaseClauses<sub>opt</sub> <b>}</b></p>
      <p>CaseClauses <b>:</b></p>
      <p>CaseClause<span><br>CaseClauses CaseClause</span></p>
      <p>CaseClause <b>:</b></p>
      <p><b>case</b> Expression <b>:</b> StatementList<sub>opt</sub></p>
      <p>DefaultClause <b>:</b></p>
      <p><b>default</b> <b>:</b> StatementList<sub>opt</sub></p>
      <h2>Static Semantics</h2>
      <p>
        <b>Static Semantics:  Early Errors</b>
      </p>
      <p><i>CaseBlock</i> <b>:</b> <b>{</b> <i>CaseClauses</i> <b>}</b>  </p>
      <p>It is a Syntax Error if the LexicallyDeclaredNames of <i>CaseClauses</i> contains any duplicate entiries.</p>
      <p>It is a Syntax Error if any element of the LexicallyDeclaredNames of <i>CaseClauses</i> also occurs in the VarDeclaredNames of <i>CaseClauses</i>.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>LexicalDeclarations</b>
      </p>
      <p><i>CaseBlock</i> <b>:</b> <b>{</b><b> </b><b>}</b> </p>
      <p>Return a new empty List.</p>
      <p><i>CaseBlock</i> <b>:</b> <b>{</b> <i>CaseClauses</i> <b>}</b> </p>
      <p>Return the LexicalDeclarations of <i>CaseClauses</i>.</p>
      <p><i>CaseBlock</i> <b>:</b> <b>{</b> <i>CaseClauses</i><sub>opt</sub><i> DefaultClause CaseClauses</i><sub>opt</sub> <b>}</b> </p>
      <p>If the first <i>CaseClauses</i> is present, let <i>declarations </i>be the LexicalDeclarations of the first <i>CaseClauses</i>.</p>
      <p>Else let <i>declarations </i>be a new empty List.</p>
      <p>Append to <i>declarations </i>the elements of the LexicallyDeclaredNames of the <i>DefaultClause</i>.</p>
      <p>If the second <i>CaseClauses</i> is not present, return names.</p>
      <p>Else return the result of append to <i>names</i> the elements of the the LexicallyDeclaredNames of the second <i>CaseClauses</i>.</p>
      <p><i>CaseClauses </i><b>:</b><i> CaseClause</i> </p>
      <p>Return the LexicalDeclarations of <i>CaseClause</i>.</p>
      <p><i>CaseClauses </i><b>:</b><i> CaseClauses CaseClause</i> </p>
      <p>Let <i>declarations </i>be LexicalDeclarations of <i>CaseClauses</i>.</p>
      <p>Append to <i>names</i> the elements of the LexicalDeclarations of <i>CaseClause</i>.</p>
      <p>Return <i>declarations</i>.</p>
      <p><i>CaseClause</i> <b>:</b> <b>case</b><i> Expression </i><b>:</b><i> StatementList</i><sub>opt</sub> </p>
      <p>If the <i>StatementList </i>is present, return the LexicalDeclarations of <i>StatementList</i>.</p>
      <p>Else return a new empty List.</p>
      <p><i>DefaultClause</i> <b>:</b> <b>default :</b><i> StatementList</i><sub>opt</sub> </p>
      <p>If the <i>StatementList </i>is present, return the LexicalDeclarations of <i>StatementList</i>.</p>
      <p>Else return a new empty List.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>LexicallyDeclaredNames</b>
      </p>
      <p><i>CaseBlock</i> <b>:</b> <b>{</b><b> </b><b>}</b> </p>
      <p>Return a new empty List.</p>
      <p><i>CaseBlock</i> <b>:</b> <b>{</b> <i>CaseClauses</i> <b>}</b> </p>
      <p>Return the LexicallyDeclaredNames of <i>CaseClauses</i>.</p>
      <p><i>CaseBlock</i> <b>:</b> <b>{</b> <i>CaseClauses</i><sub>opt</sub><i> DefaultClause CaseClauses</i><sub>opt</sub> <b>}</b> </p>
      <p>If the first <i>CaseClauses</i> is present, let <i>names </i>be the LexicallyDeclaredNames of the first <i>CaseClauses</i>.</p>
      <p>Else let <i>names</i> be a new empty List.</p>
      <p>Append to <i>names</i> the elements of the LexicallyDeclaredNames of the <i>DefaultClause</i>.</p>
      <p>If the second <i>CaseClauses</i> is not present, return names.</p>
      <p>Else return the result of append to <i>names</i> the elements of the the LexicallyDeclaredNames of the second <i>CaseClauses</i>.</p>
      <p><i>CaseClauses </i><b>:</b><i> CaseClause</i> </p>
      <p>Return the LexicallyDeclaredNames of <i>CaseClause</i>.</p>
      <p><i>CaseClauses </i><b>:</b><i> CaseClauses CaseClause</i> </p>
      <p>Let <i>names </i>be LexicallyDeclaredNames of <i>CaseClauses</i>.</p>
      <p>Append to <i>names</i> the elements of the LexicallyDeclaredNames of <i>CaseClause</i>.</p>
      <p>Return names.</p>
      <p><i>CaseClause</i> <b>:</b> <b>case</b><i> Expression </i><b>:</b><i> StatementList</i><sub>opt</sub> </p>
      <p>If the <i>StatementList </i>is present, return the LexicallyDeclaredNames of <i>StatementList</i>.</p>
      <p>Else return a new empty List.</p>
      <p><i>DefaultClause</i> <b>:</b> <b>default :</b><i> StatementList</i><sub>opt</sub> </p>
      <p>If the <i>StatementList </i>is present, return the LexicallyDeclaredNames of <i>StatementList</i>.</p>
      <p>Else return a new empty List.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>VarDeclaredNames</b>
      </p>
      <p><i>SwitchStatement </i><b>:</b><i> </i><b>switch</b><i> </i><b>(</b><i> Expression </i><b>)</b><i> CaseBlock</i> </p>
      <p>Return the VarDeclaredNames of <i>CaseBlock</i>.</p>
      <p><i>CaseBlock</i> <b>:</b> <b>{</b><b> </b><b>}</b> </p>
      <p>Return a new empty List.</p>
      <p><i>CaseBlock</i> <b>:</b> <b>{</b> <i>CaseClauses</i> <b>}</b> </p>
      <p>Return the VarDeclaredNames of <i>CaseClauses</i>.</p>
      <p><i>CaseBlock</i> <b>:</b> <b>{</b> <i>CaseClauses</i><sub>opt</sub><i> DefaultClause CaseClauses</i><sub>opt</sub> <b>}</b> </p>
      <p>If the first <i>CaseClauses</i> is present, let <i>names </i>be the VarDeclaredNames of the first <i>CaseClauses</i>.</p>
      <p>Else let <i>names</i> be a new empty List.</p>
      <p>Append to <i>names</i> the elements of the VarDeclaredNames of the <i>DefaultClause</i>.</p>
      <p>If the second <i>CaseClauses</i> is not present, return names.</p>
      <p>Else return the result of append to <i>names</i> the elements of the the VarDeclaredNames of the second <i>CaseClauses</i>.</p>
      <p><i>CaseClauses </i><b>:</b><i> CaseClause</i> </p>
      <p>Return the VarDeclaredNames of <i>CaseClause</i>.</p>
      <p><i>CaseClauses </i><b>:</b><i> CaseClauses CaseClause</i> </p>
      <p>Let <i>names </i>be VarDeclaredNames of <i>CaseClauses</i>.</p>
      <p>Append to <i>names</i> the elements of the VarDeclaredNames of <i>CaseClause</i>.</p>
      <p>Return names.</p>
      <p><i>CaseClause</i> <b>:</b> <b>case</b><i> Expression </i><b>:</b><i> StatementList</i><sub>opt</sub> </p>
      <p>If the <i>StatementList </i>is present, return the VarDeclaredNames of <i>StatementList</i>.</p>
      <p>Else return a new empty List.</p>
      <p><i>DefaultClause</i> <b>:</b> <b>default :</b><i> StatementList</i><sub>opt</sub> </p>
      <p>If the <i>StatementList </i>is present, return the VarDeclaredNames of <i>StatementList</i>.</p>
      <p>Else return a new empty List.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Case Evaluation</b>
      </p>
      <p>With argument <i>input</i>.</p>
      <p><i>CaseBlock</i> <b>:</b> <b>{</b> <i>CaseClauses</i><sub>opt</sub> <b>}</b> </p>
      <p>Let <i>V</i> = <b>undefined</b>.</p>
      <p>Let <i>A</i> be the list of <i>CaseClause</i> items in source text order.</p>
      <p>Let <i>searching</i> be <b>true</b>.</p>
      <p>Repeat, while <i>searching</i> is <b>true</b></p>
      <p>Let <i>C</i> be the next <i>CaseClause</i> in <i>A</i>. If there is no such <i>CaseClause</i>, return NormalCompletion(<i>V</i>).</p>
      <p>Let <i>clauseSelector</i> be the result of evaluating <i>C</i>.</p>
      <p>If <i>clauseSelector</i> is an abrupt completion, return <i>clauseSelector</i>.</p>
      <p>If <i>input</i> is equal to <i>clauseSelector</i> as defined by the Strict Equality Comparision Algorithm (11.9.1), then</p>
      <p>Set <i>searching</i> to <b>false</b>.</p>
      <p>If<i> C</i> has a <i>StatementList</i>, then </p>
      <p>Evaluate<i> C</i>’s <i>StatementList</i> and let<i> R</i> be the result.</p>
      <p>If<i> R</i> is an abrupt completion, then return<i> R</i>.</p>
      <p>Let<i> V</i> =<i> R</i>.[[value]].</p>
      <p>Repeat</p>
      <p>Let<i> C</i> be the next <i>CaseClause</i> in<i> A</i>. If there is no such <i>CaseClause</i>, return NormalCompletion(<i>V</i>).</p>
      <p>If<i> C</i> has a <i>StatementList</i>, then </p>
      <p>Evaluate<i> C</i>’s <i>StatementList</i> and let<i> R</i> be the result.</p>
      <p>If<i> R</i>.[[value]] is not<b> </b>empty, then let<i> V</i> =<i> R</i>.[[value]].</p>
      <p>If<i> R</i> is an abrupt completion, then return Completion {[[type]]: <i>R</i>.[[type]],<i> </i>[[value]]: <i> </i><i>V</i>,<i> </i>[[target]]: <i> </i><i>R</i>.[[target]]}.</p>
      <p><i>CaseBlock</i> <b>:</b> { <i>CaseClauses</i><sub>opt</sub><i> DefaultClause CaseClauses</i><sub>opt</sub> } </p>
      <p>Let <i>V</i> = <b>undefined</b>..</p>
      <p>Let <i>A</i> be the list of <i>CaseClause</i> items in the first <i>CaseClauses</i>, in source text order.</p>
      <p>Let <i>B</i> be the list of <i>CaseClause</i> items in the second <i>CaseClauses</i>, in source text order.</p>
      <p>Let <i>found</i> be <b>false</b>.</p>
      <p>Repeat letting <i>C</i> be in order each <i>CaseClause</i> in <i>A</i></p>
      <p>If <i>found</i> is <b>false</b>, then</p>
      <p>Let <i>clauseSelector</i> be the result of evaluating <i>C</i>.</p>
      <p>If <i>clauseSelector</i> is an abrupt completion, then</p>
      <p>If <i>clauseSelector</i>.[[value]] is empty, then return Completion {[[type]]: <i>clauseSelector</i>.[[type]],<i> </i>[[value]]: <i> </i><b>undefined</b>,<i> </i>[[target]]: <i> </i><i>clauseSelector</i>.[[target]]}.</p>
      <p>Else, return <i>clauseSelector</i>.</p>
      <p>If <i>input</i> is equal to <i>clauseSelector</i> as defined by the Strict Equality Comparision Algorithm (11.9.1), then set <i>found</i> to <b>true</b>.</p>
      <p>If <i>found</i> is <b>true</b>, then</p>
      <p>If <i>C</i> has a <i>StatementList</i>, then</p>
      <p>Evaluate <i>C</i>’s <i>StatementList</i> and let <i>R</i> be the result.</p>
      <p>If<i> R</i>.[[value]] is not<b> </b>empty, then let<i> V</i> =<i> R</i>.[[value]].</p>
      <p>If <i>R</i> is an abrupt completion, then return Completion {[[type]]: <i>R</i>.[[type]],<i> </i>[[value]]: <i> </i><i>V</i>,<i> </i>[[target]]: <i> </i><i>R</i>.[[target]]}.</p>
      <p>Let <i>foundInB</i> be <b>false</b>.</p>
      <p>If <i>found</i> is <b>false</b>, then </p>
      <p>Repeat, while <i>foundInB</i> is <b>false</b> and all elements of <i>B</i> have not been processed</p>
      <p>Let <i>C</i> be the next <i>CaseClause</i> in <i>B</i>. </p>
      <p>Let <i>clauseSelector</i> be the result of evaluating <i>C</i>.</p>
      <p>If <i>clauseSelector</i> is an abrupt completion, then.</p>
      <p>If <i>clauseSelector</i>.[[value]] is empty, then return Completion {[[type]]: <i>clauseSelector</i>.[[type]],<i> </i>[[value]]: <i> </i><b>undefined</b>,<i> </i>[[target]]: <i> </i><i>clauseSelector</i>.[[target]]}.</p>
      <p>Else, return <i>clauseSelector</i>.</p>
      <p>If <i>input</i> is equal to <i>clauseSelector</i> as defined by the Strict Equality Comparision Algorithm (11.9.1), then</p>
      <p>Set <i>foundInB</i> to <b>true</b>.</p>
      <p>If<i> C</i> has a <i>StatementList</i>, then</p>
      <p>Evaluate <i>C</i>’s <i>StatementList</i> and let <i>R</i> be the result.</p>
      <p>If<i> R</i>.[[value]] is not<b> </b>empty, then let<i> V</i> =<i> R</i>.[[value]].</p>
      <p>If <i>R</i> is an abrupt completion, then return Completion {[[type]]: <i>R</i>.[[type]],<i> </i>[[value]]: <i> </i><i>V</i>,<i> </i>[[target]]: <i> </i><i>R</i>.[[target]]}.</p>
      <p>If <i>foundInB</i> is <b>false</b> and the <i>DefaultClause</i> has a <i>StatementList</i>, then</p>
      <p>Evaluate the <i>DefaultClause’s</i> <i>StatementList</i> and let <i>R</i> be the result.</p>
      <p>If <i>R</i>.[[value]] is not empty, then let <i>V</i> = <i>R</i>.[[value]].</p>
      <p>If <i>R</i> is an abrupt completion, then return Completion {[[type]]: <i>R</i>.[[type]],<i> </i>[[value]]: <i> </i><i>V</i>,<i> </i>[[target]]: <i> </i><i>R</i>.[[target]]}.</p>
      <p>Repeat (Note that if step 7.a.i has been performed this loop does not start at the beginning of <i>B</i>)</p>
      <p>Let <i>C</i> be the next <i>CaseClause</i> in <i>B</i>. If there is no such <i>CaseClause</i>, return NormalCompletion(<i>V</i>).</p>
      <p>If <i>C</i> has a <i>StatementList</i>, then </p>
      <p>Evaluate <i>C</i>’s <i>StatementList</i> and let <i>R</i> be the result.</p>
      <p>If <i>R</i>.[[value]] is not empty, then let <i>V</i> = <i>R</i>.[[value]].</p>
      <p>If <i>R</i> is an abrupt completion, then Completion {[[type]]: <i>R</i>.[[type]],<i> </i>[[value]]: <i> </i><i>V</i>,<i> </i>[[target]]: <i> </i><i>R</i>.[[target]]}.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p><i>SwitchStatement </i><b>:</b><i> </i><b>switch</b><i> </i><b>(</b><i> Expression </i><b>)</b><i> CaseBlock</i> </p>
      <p>Let <i>exprRef</i> be the result of evaluating <i>Expression</i>.</p>
      <p>Let <i>switchValue</i> be GetValue(<i>exprRef</i>).</p>
      <p>If <i>switchValue</i> is an abrupt completion, return <i>switchValue</i>.</p>
      <p>Let <i>oldEnv</i> be the running execution context’s LexicalEnvironment.</p>
      <p>Let <i>blockEnv</i> be the result of calling NewDeclarativeEnvironment passing <i>oldEnv</i> as the argument.</p>
      <p>Perform Block Declaration Instantiation using <i>CaseBlock</i> and <i>blockEnv</i>.</p>
      <p>Let <i>R</i> be the result of performing Case Evaluation <i>CaseBlock</i> with argument <i>switchValue</i>.</p>
      <p>Set the running execution context’s LexicalEnvironment to <i>oldEnv</i>.</p>
      <p>Return <i>R</i>.</p>
      <p>NOTE<span>	No matter how control leaves the </span>SwitchStatement the LexicalEnvironment is always restored to its former state.</p>
      <p><i>CaseClause</i> <b>:</b> <b>case</b><i> Expression </i><b>:</b><i> StatementList</i><sub>opt</sub> </p>
      <p>Let <i>exprRef</i> be the result of evaluating <i>Expression</i>.</p>
      <p>Return GetValue(<i>exprRef</i>).</p>
      <p>NOTE<span>	Evaluating </span>CaseClause does not execute the associated StatementList. It simply evaluates the Expression and returns the value, which the CaseBlock algorithm uses to determine which StatementList to start executing.</p>
      <h2>12.12<span>	Labelled Statements</span></h2>
      <p>Syntax</p>
      <p>LabelledStatement <b>:</b></p>
      <p>Identifier <b>:</b> Statement</p>
      <p>NOTE	A <i>Statement</i> may be prefixed by a label. Labelled statements are only used in conjunction with labelled <b>break</b> and <b>continue</b> statements. ECMAScript has no <b>goto</b> statement. A <i>Statement</i> can be part of a <i>LabelledStatement</i>, which itself can be part of a <i>LabelledStatement</i>, and so on. The labels introduced this way are collectively referred to as the “current label set” when describing the semantics of individual statements. A <i>LabelledStatement</i> has no semantic meaning other than the introduction of a label to a <i>label set</i>. The label set of an <i>IterationStatement</i> or a<i> SwitchStatement</i> initially contains the single element <b>empty</b>. The label set of any other statement is initially empty.</p>
      <p>
      </p>
      <h2>Static Semantics</h2>
      <p>
        <b>Static Semantics:  Early Errors</b>
      </p>
      <p>It is a Syntax Error if a <i>LabelledStatement</i> is enclosed by a <i>LabelledStatement</i> with the same <i>Identifier</i> as label. This does not apply to labels appearing within the body of a <i>FunctionDeclaration</i> that is nested, directly or indirectly, within a labelled statement.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>VarDeclaredNames</b>
      </p>
      <p>
        <i>LabelledStatement</i>
        <i> </i>
        <b>:</b>
        <i> Identifier </i>
        <b>:</b>
        <i> Statemen</i>
        <i>t</i>
      </p>
      <p>Return the VarDeclaredNames of <i>Statement</i>.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Labelled Evaluation</b>
      </p>
      <p>With argument <i>l</i><i>abelSet</i>.</p>
      <p>
        <i>LabelledStatement</i>
        <i> </i>
        <b>:</b>
        <i> Identifier </i>
        <b>:</b>
        <i> Statemen</i>
        <i>t</i>
      </p>
      <p>Let <i>label</i> be the StringValue of <i>Identifi</i><i>er</i>.</p>
      <p>Let <i>newLabelSet </i> be a new List containing  <i>label</i> and the elements of  <i>l</i><i>abe</i><i>l</i><i>Set</i>.</p>
      <p>If Statement is either <i>LabelledStatement</i> or <i>Breakable</i><i>Statement</i>, then</p>
      <p>Let <i>stmtResult</i> be the result of performing Labelled Evaluation of <i>Statement</i><i> </i>with argument <i>newLabelSet</i>.</p>
      <p>Else,</p>
      <p>Let <i>stmtResult</i> be the result of evaluating <i>Statement</i>.</p>
      <p>If <i>stmtResult</i>.[[type]] is <b>break</b>  and  <i>stmtResult</i>.[[target]] is the same value as <i>label</i>, then</p>
      <p>Let result be NormalCompletion(<i>stmtResult</i>.[[value]]).</p>
      <p>Else, let <i>result</i> be <i>stmtResult</i>.</p>
      <p>Return <i>result</i>.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>
        <i>LabelledStatement</i>
        <i> </i>
        <b>:</b>
        <i> Identifier </i>
        <b>:</b>
        <i> Statemen</i>
        <i>t</i>
      </p>
      <p>Let <i>newLabelSet </i> be a new empty List.</p>
      <p>Return the result of performing Labelled Evaluation of this <i>LabelledStatement</i><i> </i>wth argument <i>newLabelSet</i>.</p>
      <h2>12.13<span>	The </span>throw Statement</h2>
      <p>Syntax</p>
      <p>ThrowStatement<b> </b><b>:</b></p>
      <p><b>throw</b><b> </b>[no LineTerminator here] Expression <b>;</b></p>
      <p>Semantics</p>
      <p>The production <i>ThrowStatement</i> <b>:</b> <b>throw</b><b> </b>[no <i>LineTerminator</i> here]<span style="font-weight: bold; font-style: italic"> </span><i>Expression</i> <b>;</b> is evaluated as follows:</p>
      <p>Let <i>exprRef</i> be the result of evaluating <i>Expression</i>.</p>
      <p>Return (throw, GetValue(<i>exprRef</i>), empty).</p>
      <h2>12.14<span>	The </span>try Statement</h2>
      <p>Syntax</p>
      <p>TryStatement <b>:</b></p>
      <p><b>try</b> Block Catch<sub><br></sub><b>try</b> Block Finally<sub><br></sub><b>try</b> Block Catch Finally</p>
      <p>Catch <b>:</b></p>
      <p><b>catch</b> <b>( </b>CatchParameter <b>)</b> Block</p>
      <p>Finally <b>:</b></p>
      <p><b>finally</b> Block</p>
      <p>CatchParameter <b>:</b></p>
      <p>BindingIdentifier<sub><br></sub>BindingPattern </p>
      <p>NOTE	The <b>try </b>statement encloses a block of code in which an exceptional condition can occur, such as a runtime error or a <b>throw</b> statement. The <b>catch</b> clause provides the exception-handling code. When a catch clause catches an exception, its <i>Identifier</i> is bound to that exception.</p>
      <h2>Static Semantics</h2>
      <p>
        <b>Static Semantics:  Early Errors</b>
      </p>
      <p><i>Catch</i> <b>:</b> <b>catch</b> <b>( </b><i>CatchParameter </i><b>)</b> <i>Block</i>  </p>
      <p>It is a Syntax Error if any element of the BoundNames of <i>CatchParameter</i> also occurs in the LexicallyDeclaredNames of <i>Block</i>.</p>
      <p>It is a Syntax Error if any element of the BoundNames of <i>CatchParameter</i> also occurs in the VarDeclaredNames of <i>Block</i>.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>BoundNames</b>
      </p>
      <p><i>CatchParameter</i><b>:</b> <i>Binding</i>Identifier </p>
      <p>Return the BoundNames of <i>Binding</i>Identifier.</p>
      <p><i>CatchParameter</i><b>:</b> <i>Binding</i>Pattern </p>
      <p>Return the BoundNames of <i>Binding</i>Pattern.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>VarDeclaredNames</b>
      </p>
      <p><i>TryStatement</i> <b>:</b> <b>try</b> <i>Block</i> <i>Catch</i> </p>
      <p>Let <i>names </i>be VarDeclaredNames of <i>Block</i>.</p>
      <p>Append to <i>names</i> the elements of the VarDeclaredNames of <i>Catch</i>.</p>
      <p>Return names.</p>
      <p><i>TryStatement</i> <b>:</b> <b>try</b> <i>Block</i> <i>Finally</i> </p>
      <p>Let <i>names </i>be VarDeclaredNames of <i>Block</i>.</p>
      <p>Append to <i>names</i> the elements of the VarDeclaredNames of <i>Finally</i>.</p>
      <p>Return names.</p>
      <p><i>TryStatement</i> <b>:</b> <b>try</b> <i>Block</i> <i>Catch</i> <i>Finally</i> </p>
      <p>Let <i>names </i>be VarDeclaredNames of <i>Block</i>.</p>
      <p>Append to <i>names</i> the elements of the VarDeclaredNames of <i>Catch</i>.</p>
      <p>Append to <i>names</i> the elements of the VarDeclaredNames of <i>Finally</i>.</p>
      <p>Return names.</p>
      <p><i>Catch</i> <b>:</b> <b>catch</b> <b>( </b><i>CatchParameter</i> <b>)</b> <i>Block</i> </p>
      <p>Return the VarDeclaredNames of <i>Block</i>.</p>
      <p><i>Finally</i> <b>: finally</b> <i>Block</i> </p>
      <p>Return the VarDeclaredNames of <i>Block</i>.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Binding </b>
        <b>Initialisation</b>
      </p>
      <p>With arguments <i>value</i> and <i>environment</i>.</p>
      <p>NOTE	<b>undefined</b> is passed for <i>environment</i> to indicate that a PutValue operation should be used to assign the initialisation value.  This is the the case for <b>var</b> statements formal parameter lists of non-strict functions. In those cases a lexical binding is hosted and preinitialized prior to evaluation of its initializer. </p>
      <p><i>CatchParameter</i><b>:</b> <i>Binding</i>Identifier</p>
      <p>Return the result of performing Binding Initialisation for <i>Binding</i>Identifier passing<i> value</i> and <i>environment</i> as the arguments.</p>
      <p><i>CatchParameter</i><b>:</b> <i>Binding</i>Pattern</p>
      <p>Let <i>exceptionObj</i> be ToObject(<i>value</i>).</p>
      <p>Return the result of performing Binding Initialisation for <i>Binding</i>Pattern passing<i> </i><i>exceptionObj</i> and <i>environment</i> as the arguments.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Catch Clause Evaluation</b>
      </p>
      <p>with parameter <i>thrownValue</i> </p>
      <p><i>Catch</i> <b>:</b> <b>catch</b> <b>(</b><i> CatchParameter</i> <b>)</b> <i>Block</i> </p>
      <p>Let <i>oldEnv</i> be the running execution context’s LexicalEnvironment.</p>
      <p>Let <i>catchEnv</i> be the result of calling NewDeclarativeEnvironment passing <i>oldEnv</i> as the argument. </p>
      <p>For each element <i>argName</i> of the BoundNames of <i>CatchParameter, do</i></p>
      <p>Call the CreateMutableBinding concrete method of <i>catchEnv</i> passing <i>argName</i> as the argument.</p>
      <p>Let <i>status</i> be the result of performing Binding Initialisation for <i>CatchParameter</i> passing <i>thrownValue</i><i> </i>and <i>cat</i><i>c</i><i>h</i><i>Env</i><b> </b>as arguments. </p>
      <p>If <i>status</i> is an abrupt completion, then return <i>status</i>.</p>
      <p>Set the running execution context’s LexicalEnvironment to <i>catchEnv</i>.</p>
      <p>Let <i>B</i> be the result of evaluating <i>Block</i>.</p>
      <p>Set the running execution context’s LexicalEnvironment to <i>oldEnv</i>.</p>
      <p>Return <i>B</i>.</p>
      <p>NOTE<span>	No matter how control leaves the </span>Block the LexicalEnvironment is always restored to its former state.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p><i>TryStatement</i> <b>:</b> <b>try</b> <i>Block</i> <i>Catch</i> </p>
      <p>Let <i>B</i> be the result of evaluating <i>Block</i>.</p>
      <p>If <i>B</i>.[[type]] is not throw, return <i>B</i>.</p>
      <p>Return the result of performing Catch Clause Evaluation of <i>Catch</i> with parameter <i>B</i>.[[value]].</p>
      <p><i>TryStatement</i> <b>:</b> <b>try</b> <i>Block</i> <i>Finally</i> </p>
      <p>Let <i>B</i> be the result of evaluating <i>Block</i>.</p>
      <p>Let <i>F</i> be the result of evaluating <i>Finally</i>.</p>
      <p>If <i>F</i>.[[type]] is normal, return <i>B</i>.</p>
      <p>Return <i>F</i>.</p>
      <p><i>TryStatement</i> <b>:</b> <b>try</b> <i>Block</i> <i>Catch</i> <i>Finally</i> </p>
      <p>Let <i>B</i> be the result of evaluating <i>Block</i>.</p>
      <p>If <i>B</i>.[[type]] is throw, then</p>
      <p>Let <i>C</i> be the result of performing Catch Clause Evaluation of <i>Catch</i> with parameter <i>B</i>.value.</p>
      <p>Else, <i>B</i>.[[type]] is not throw<b>,</b></p>
      <p>Let <i>C</i> be<i> B</i>.</p>
      <p>Let <i>F</i> be the result of evaluating <i>Finally</i>.</p>
      <p>If <i>F</i>.[[type]] is normal, return <i>C</i>.</p>
      <p>Return <i>F</i>.</p>
      <p><i>Finally</i> <b>: finally</b> <i>Block</i> </p>
      <p>Return the result of evaluating <i>Block</i>.</p>
      <h2>12.15<span>	The </span>debugger statement</h2>
      <p>Syntax</p>
      <p>DebuggerStatement <b>:</b></p>
      <p>
        <b>debugger ;</b>
      </p>
      <p>Semantics</p>
      <p>NOTE	Evaluating the <i>DebuggerStatement </i>production may allow an implementation to cause a breakpoint when run under a debugger. If a debugger is not present or active this statement has no observable effect.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p>The production <i>DebuggerStatement </i><b>:</b><i> </i><b>debugger ;</b> is evaluated as follows:</p>
      <p>If an implementation defined debugging facility is available and enabled, then</p>
      <p>Perform an implementation defined debugging action.</p>
      <p>Let <i>result</i> be an implementation defined Completion value. </p>
      <p>Else</p>
      <p>Let <i>result</i> be NormalCompletion(empty).</p>
      <p>Return <i>result</i>.</p>
      <h1>13	Functions and Generators</h1>
      <h2>13.1	Function Definitions</h2>
      <p>Syntax</p>
      <p>FunctionDeclaration <b>:</b></p>
      <p><b>function</b> BindingIdentifier <b>(</b> FormalParameterList <b>)</b> <b>{</b> FunctionBody <b>}</b></p>
      <p>FunctionExpression <b>:</b></p>
      <p><b>function</b> BindingIdentifier<sub>opt</sub> <b>(</b> FormalParameterList <b>)</b> <b>{</b> FunctionBody <b>}</b></p>
      <p>FormalParameterList <b>:</b></p>
      <p>[empty]<b><br></b>FunctionRestParameter<span><br>FormalsList</span><br>FormalsList<b>,</b><b> </b>FunctionRestParameter</p>
      <p>FormalsList <b>:</b></p>
      <p>FormalParameter<br>FormalsList <b>,</b> FormalParameter</p>
      <p>FunctionRestParameter <b>:</b></p>
      <p><b>...</b> BindingIdentifier</p>
      <p>FormalParameter <b>:</b></p>
      <p>BindingElement </p>
      <p>FunctionBody <b>:</b></p>
      <p>StatementList<sub>opt</sub> </p>
      <h2>Static Semantics</h2>
      <p>
        <b>Static Semantics:  </b>
        <b>Early Errors</b>
      </p>
      <p><i>FunctionDeclaration </i><b>:</b><i> </i><b>function</b> <i>BindingIdentifier </i><b>(</b><i> FormalParameterList </i><b>)</b> <b>{</b> <i>FunctionBody</i> <b>}</b><br>and<br><i>FunctionExpression</i> <b>: </b><b>function</b> <i>BindingIdentifier</i><sub>opt</sub><i> </i><b>(</b><i> FormalParameterList </i><b>)</b> <b>{</b> <i>FunctionBody</i> <b>}</b></p>
      <p>It is a Syntax Error if the any element of the LexicallyDeclaredNames of <i>FormalParameterList</i> also occurs in the VarDeclaredNames of <i>FunctionBody</i>.</p>
      <p>It is a Syntax Error if any element of the BoundNames of <i>FormalParameterList</i> also occurs in the LexicallyDeclaredNames of <i>FunctionBody</i>.</p>
      <p>
      </p>
      <p>
        <i>FunctionBody </i>
        <b>:</b>
        <i> StatementList </i>
      </p>
      <p>It is a Syntax Error if the LexicallyDeclaredNames of <i>StatementList</i> contains any duplicate entiries.</p>
      <p>It is a Syntax Error if any element of the LexicallyDeclaredNames of <i>StatementList</i> also occurs in the VarDeclaredNames of <i>StatementList</i>.</p>
      <p>FormalParameterList <b>:</b> FormalsList<span style="font-weight: bold; font-style: italic">,</span> FunctionRestParameter</p>
      <p>It is a Syntax Error if BoundNames of FormalsList contains the String Value of  Identifier.</p>
      <p>FormalsList <b>:</b> FormalsList<span style="font-weight: bold; font-style: italic">,</span> FormalParameter </p>
      <p>It is a Syntax Error if the source code matching this production is strict code and BoundNames of FormalsList contains an element which is also contained in BoundNames of  FormalParameter.</p>
      <p><i>FunctionRestParameter</i> <b>:</b>  <b>...</b><b> </b><i> </i><i>Binding</i><i>Identifier</i> </p>
      <p>It is a Syntax Error if the source code parsed with this production is not extended code.</p>
      <p>FormalParameter <b>:</b> <i>Binding</i>Element </p>
      <p>It is a Syntax Error if the derivation of <i>Binding</i>Element is <i>Binding</i>Identifier  Initialiser and the source code matching this production is not extended code.</p>
      <p>It is a Syntax Error if the derivation of <i>Binding</i>Element is BindingPattern  Initialiser<sub>opt</sub> and the source code parsed with this production is not extended code.</p>
      <p>It is a Syntax Error if BoundNames of BindingElement  contains any duplicate elements.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>BoundNames</b>
      </p>
      <p><i>FunctionDeclaration</i> <b>:</b> <b>function</b> <i>BindingIdentifier</i> <b>(</b> <i>FormalParameterList</i> <b>)</b> <b>{</b> <i>FunctionBody</i> <b>}</b></p>
      <p>Return the BoundNames of <i>BindingIdentifier</i>.</p>
      <p>FormalParameterList <b>: </b>[empty]</p>
      <p>Return an empty List.</p>
      <p>FormalParameterList <b>: </b>FunctionRestParameter</p>
      <p>Return the BoundNames of <i>FunctionRestParameter</i>.</p>
      <p>FormalParameterList <b>: </b>FormalsList</p>
      <p>Return the BoundNames of <i>FormalsList</i>.</p>
      <p>FormalParameterList <b>: </b>FormalsList <b>, </b>FunctionRestParameter</p>
      <p>Let <i>names </i>be BoundNames of FormalsList.</p>
      <p>Append to <i>names</i> the BoundNames of <i>FunctionRestParameter</i>.</p>
      <p>Return <i>names</i>.</p>
      <p>FormalsList <b>:</b> FormalsList <span style="font-weight: bold; font-style: italic">,</span> FormalParameter </p>
      <p>Let <i>names </i>be BoundNames of FormalsList.</p>
      <p>Append to <i>names</i> the elements of BoundNames of FormalParameter.</p>
      <p>Return <i>names</i>.</p>
      <p>FormalParameterList <b>: </b><b>...</b><b> </b> BindingIdentifier</p>
      <p>Return the BoundNames of <i>Binding</i>Identifier.</p>
      <p>FormalParameter <b>:</b> <i>Binding</i>Element  </p>
      <p>Return the BoundNames of <i>Binding</i>Element .</p>
      <p>
        <b>Static Semantics:  </b>
        <b>ExpectedArgumentCount</b>
      </p>
      <p>FormalParameterList <b>:</b></p>
      <p>[empty]<b><br></b>FunctionRestParameter</p>
      <p>Return 0.</p>
      <p>FormalParameterList <b>:</b></p>
      <p>FormalsList<span><br>FormalsList</span> <b>, </b>FunctionRestParameter</p>
      <p>Return the ExpectedArgumentCount of FormalsList.</p>
      <p>NOTE<span>	The </span>ExpectedArgumentCount of a <i>FormalParameterList</i> is the number of <i>FormalParameters</i> to the left of either the rest parameter or the first FormalParameter with an Initialiser.</p>
      <p>FormalsList <b>:</b> FormalParameter<sub> </sub> </p>
      <p>If HasInitialiser of FormalParameter<sub> </sub> is <b>false</b> return 0</p>
      <p>Return 1.</p>
      <p>FormalsList <b>:</b> FormalsList<span style="font-weight: bold; font-style: italic">,</span> FormalParameter<sub> </sub> </p>
      <p>Let <i>count</i> be the ExpectedArgumentCount of FormalsList.</p>
      <p>If HasInitialiser of <i>FormalsList</i> is <b>true</b> or HasInitialiser of <i>FormalParameter</i> is <b>true</b>, then return <i>count</i>.</p>
      <p>Return <i>count</i>+1.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>HasInitialiser</b>
      </p>
      <p>FormalsList <b>:</b> FormalParameter<sub> </sub> </p>
      <p>Return HasInitialiser of FormalParameter.</p>
      <p>FormalsList <b>:</b> FormalsList <span style="font-weight: bold; font-style: italic">,</span> FormalParameter<sub> </sub> </p>
      <p>If HasInitialiser of FormalsList is <b>true</b>, then return <b>true</b>.</p>
      <p>Return HasInitialiser of FormalParameter.</p>
      <p>FormalParameter <b>:</b> <i>Binding</i>Element  </p>
      <p>Return HasInitialiser of BindingElement.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>IsConstantDeclaration</b>
      </p>
      <p><i>FunctionDeclaration </i><b>:</b><i> </i><b>function</b> <i>BindingIdentifier </i><b>(</b><i> FormalParameterList </i><b>)</b> <b>{</b> <i>FunctionBody</i> <b>}</b> </p>
      <p>Return <b>false</b>.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>LexicallyDeclaredNames</b>
      </p>
      <p>FunctionBody <b>:  </b>[empty] </p>
      <p>Return an empty List.</p>
      <p>FunctionBody <b>:  </b>StatementList </p>
      <p>Return the LexicllyDeclaredNames of <i>StatementList</i>.</p>
      <p>
        <b>Static Semantics:  </b>
        <b>VarDeclaredNames</b>
      </p>
      <p><i>FunctionDeclaration</i> <b>:</b> <b>function</b> <i>BindingIdentifier</i> <b>(</b> <i>FormalParameterList</i> <b>)</b> <b>{</b> <i>FunctionBody</i> <b>}</b></p>
      <p>Return an empty List.</p>
      <p>FunctionBody <b>:  </b>[empty] </p>
      <p>Return an empty List.</p>
      <p>FunctionBody <b>:  </b>StatementList </p>
      <p>Return the VarDeclaredNames of <i>StatementList</i>.</p>
      <h2>Runtime Semantics</h2>
      <p>
        <b>Runtime Semantics: </b>
        <b>Binding </b>
        <b>Initialisation</b>
      </p>
      <p>With parameters <i>value</i> and <i>environment</i> and optional parameter <i>index</i>.</p>
      <p>NOTE	When <b>undefined</b> is passed for <i>environment</i> it indicates that a PutValue operation should be used to assign the initialisation value.  This is the the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name. </p>
      <p>FormalParameterList <b>:</b><b> </b>[empty]</p>
      <p>Return NormalCompletion(empty).</p>
      <p>FormalParameterList <b>:</b><b> </b>FunctionRestParameter</p>
      <p>Return the result of performing Indexed Binding Initialisation for <i>FunctionRestParameter </i>using <i>value</i>,<i> </i><i>lenValue</i>,<i> </i>0, and <i>environment</i> as the arguments..</p>
      <p>FormalParameterList <b>:</b><b> </b>FormalsList</p>
      <p>Asset: <i>value</i> is a new created arguments object and hence it has a valid integer valued "<b>length</b>" property.</p>
      <p>Let <i>lenValue</i> be the result of calling the [[Get]] internal method of <i>value</i> with argument "<b>length</b>".</p>
      <p>Return the result of performing Indexed Binding Initialisation for <i>FormalsList </i>using <i>value</i>,<i> </i><i>lenValue</i>.[[value]],<i> </i>0, and <i>environment</i> as the arguments.</p>
      <p>FormalParameterList <b>:</b><b> </b>FormalsList <b>,</b><b> </b>FunctionRestParameter</p>
      <p>Let <i>restI</i><i>ndex</i> be the result of performing Indexed Binding Initialisation for <i>FormalsList </i>using <i>value</i>,<i> </i><i>lenValue</i>,<i> </i>0, and <i>environment</i> as the arguments.</p>
      <p>ReturnIfAbrupt(<i>restI</i><i>ndex</i>).</p>
      <p>Return the result of performing Indexed Binding Initialisation for <i>FunctionRestParameter </i>using <i>value</i>,<i> </i><i>lenValue</i>,<i> </i><i>restI</i><i>ndex</i>.[[value]], and <i>environment</i> as the arguments.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Indexed </b>
        <b>Binding </b>
        <b>Initialisation</b>
      </p>
      <p>With parameters <i>array</i>, <i>arrayLength</i><i>, nextIndex,</i> and<i> </i> <i>environment</i>.</p>
      <p>FormalsList <b>:</b><b> </b>FormalParameter</p>
      <p>Let <i>status</i> be the result of performing Binding Initialisation for <i>FormalParameter </i>using <i>value</i>,<i> env</i>,  and <i>index</i> as the arguments.</p>
      <p>ReturnIfAbrupt(<i>status</i>).</p>
      <p>Return <i>index</i> + 1.</p>
      <p>FormalsList <b>:</b><b> </b>FormalsList <b>,</b> FormalParameter</p>
      <p>Let <i>lastI</i><i>ndex</i> be the result of performing Indexed Binding Initialisation for <i>FormalsList </i>using <i>value</i>,<i> </i><i> lenValue</i>,<i> </i><i>nextIndex</i>, and <i>environment</i> as the arguments.</p>
      <p>Let status be the result of performing Indexed Binding Initialisation for <i>FormalParameter </i>using <i>value</i>,<i> </i><i>lenValue</i>,<i> </i><i>lastI</i><i>ndex</i>, and <i>environment</i> as the arguments.</p>
      <p>ReturnIfAbrupt(status).</p>
      <p>Return <i>lastI</i><i>ndex</i> + 1.</p>
      <p>FunctionRestParameter <b>: </b><b>...</b> BindingIdentifier</p>
      <p>Let <i>A</i> be a new array object created as if by the expression <b>new Array()</b> where <b>Array</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>n</i>=0;</p>
      <p>Repeat, while <i>nextIndex</i> &lt; <i>arrayLength</i></p>
      <p>Let <i>P</i> be ToString(<i>nextIndex</i>).</p>
      <p>Assert: <i>array</i> is a well formed arguments object, hence it must have a property <i>P</i>.</p>
      <p>Let <i>v</i> be the result of calling the [[Get]] internal method of <i>array</i> passing <i>P </i>as the argument.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments ToString(<i>n</i>), Property Descriptor {[[Value]]: <i>v</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Let <i>n</i> = <i>n</i>+1.</p>
      <p>Let <i>nextIndex</i> = <i>nextIndex</i> +1.</p>
      <p>Return the result of performing Binding Initialisation for <i>Binding</i><i>Identifer</i> using <i>A</i> and <i>environment</i> as arguments.</p>
      <p>FormalParameter <b>:</b><b> </b>BindingElement </p>
      <p>Return the result of performing Indexed Binding Initialisation for <i>BindingElement</i><i> </i>using <i>array</i>,<i> </i><i>arrayLength</i>,<i> </i><i>nextIndex</i>, and <i>environment</i> as the arguments.</p>
      <p>
        <b>Runtime Semantics: </b>
        <b>Evaluation</b>
      </p>
      <p><i>FunctionDeclaration </i><b>:</b><i> </i><b>function</b> <i>Binding</i><i>Identifier </i><b>(</b><i> FormalParameterList </i><b>)</b> <b>{</b> <i>FunctionBody</i> <b>}</b></p>
      <p>Return (normal, empty, empty).</p>
      <p><i>FunctionExpression </i><b>:</b><i> </i><b>function</b> <b>(</b><i> FormalParameterList </i><b>)</b> <b>{</b> <i>FunctionBody</i> <b>}</b> </p>
      <p>Return the result of creating a new Function object as specified in 13.2 with parameters specified by <i>FormalParameterList</i> and body specified by <i>FunctionBody</i>. Pass in the LexicalEnvironment of the running execution context as the <i>Scope</i>. Pass in <b>true</b> as the <i>Strict</i> flag if the <i>FunctionExpression</i> is contained in strict code or if its <i>FunctionBody</i> is strict code.</p>
      <p><i>FunctionExpression</i> <b>:</b> <b>function</b> <i>Binding</i><i>Identifier</i> <b>(</b> <i>FormalParameterList</i> <b>)</b> <b>{</b> <i>FunctionBody</i> <b>}</b></p>
      <p>Let <i>funcEnv </i>be the result of calling NewDeclarativeEnvironment passing the running execution context’s Lexical Environment as the argument</p>
      <p>Let <i>envRec </i>be <i>funcEnv’s </i>environment record.</p>
      <p>Call the CreateImmutableBinding concrete method of <i>envRec </i>passing the String value of <i>Binding</i><i>Identifier</i> as the argument.</p>
      <p>Let <i>closure </i>be the result of creating a new Function object as specified in 13.2 with parameters specified by <i>FormalParameterList</i> and body specified by <i>FunctionBody</i>. Pass in <i>funcEnv </i>as the <i>Scope</i>. Pass in <b>true</b> as the <i>Strict</i> flag if the <i>FunctionExpression</i> is contained in strict code or if its <i>FunctionBody</i> is strict code.</p>
      <p>Call the InitializeBinding concrete method of <i>envRec </i>passing the String value of <i>Identifier </i>and <i>closure </i>as the arguments.</p>
      <p>Return <i>closure</i>.</p>
      <p>NOTE<span>	The </span>BindingIdentifier in a FunctionExpression can be referenced from inside the FunctionExpression's FunctionBody to allow the function to call itself recursively. However, unlike in a FunctionDeclaration, the <i>Binding</i>Identifier in a FunctionExpression cannot be referenced from and does not affect the scope enclosing the FunctionExpression.</p>
      <p><i>FunctionBody </i><b>:</b><i> </i><i>Statement</i><i>List</i><sub>opt</sub><i> </i> </p>
      <p>The code of this <i>FunctionBody </i>is strict mode code if it is part of a <i>FunctionDeclaration</i> or <i>FunctionExpression</i> that is contained in strict mode code or if the Directive Prologue (14.1) of its <i>StatementList</i> contains a Use Strict Directive or if any of the conditions in 10.1.1 apply.  If the code of this <i>FunctionBody </i>is strict mode code, <i>StatementList</i> is evaluated in the following steps as strict mode code. Otherwise, <i>StatementList</i> is evaluated in the following steps as non-strict mode code.</p>
      <p>If <i>StatementList</i> is present return the result of evaluating <i>StatementList</i>.</p>
      <p>Else return NormalCompletion(<b>undefined</b>).</p>
      <h2>13.1.1<span>	Creating Function Objects</span></h2>
      <p>A Function object is constructed as follows given an parameter list specified by <i>FormalParameterList</i>, a body specified by <i>FunctionBody</i>, a Lexical Environment specified by <i>Scope</i>, a Boolean flag <i>Strict</i>, and optionally, an object <i>homeObject</i> and a string <i>methodNam</i><i>e</i>:</p>
      <p>Create a new native ECMAScript object and let <i>F</i> be that object.</p>
      <p>Set all the internal methods, except for [[Get]], of <i>F</i> as described in 8.12.</p>
      <p>Add the [[NativeBrand]] internal property with value NativeFunction to <i>F</i>.</p>
      <p>Set the [[Prototype]] internal property of <i>F</i> to the standard built-in Function prototype object as specified in 15.3.3.1.</p>
      <p>Set the [[Get]] internal property of <i>F</i> as described in 15.3.5.4.</p>
      <p>Set the [[Call]] internal property of <i>F</i> as described in 13.2.1.</p>
      <p>Set the [[Construct]] internal property of <i>F</i> as described in 13.2.2.</p>
      <p>Set the [[HasInstance]] internal property of <i>F</i> as described in 15.3.5.3.</p>
      <p>Set the [[Scope]] internal property of <i>F</i> to the value of <i>Scope</i>.</p>
      <p>Set the [[FormalParameters]] internal property of <i>F </i>to <i>FormalParameterList</i>. .</p>
      <p>Set the [[Code]] internal property of <i>F </i>to <i>FunctionBody</i>.</p>
      <p>Set the [[Extensible]] internal property of <i>F </i>to <b>true</b>.</p>
      <p>If the <i>homeObject</i> argument was provided, set the [[Home]] internal property of <i>F</i> to <i>homeObject</i>.</p>
      <p>If the <i>methodNam</i><i>e</i>argument was provided, set the [[MethodName]] internal property of <i>F</i> to <i>methodNam</i><i>e</i>.</p>
      <p>Let <i>len</i> be the ExpectedArgumentCount of <i>FormalParameterList</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>F</i> with arguments <b>"</b><b>length</b><b>"</b>, Property Descriptor {[[Value]]: <i>len</i>, [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b>}, and <b>false</b>. </p>
      <p>Let <i>proto</i> be the result of creating a new object as would be constructed by the expression <b>new Object()</b>where <b>Object</b> is the standard built-in constructor with that name.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>proto</i> with arguments <b>"</b><b>constructor</b><b>"</b>, Property Descriptor {[[Value]]: <i>F</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>F</i> with arguments <b>"</b><b>prototype</b><b>"</b>, Property Descriptor {[[Value]]: <i>proto</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b>}, and <b>false</b>.</p>
      <p>If <i>Strict</i> is <b>true</b>, then</p>
      <p>Let <i>thrower</i> be the [[ThrowTypeError]] function Object (13.2.3).</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>F</i> with arguments <b>"caller"</b>, PropertyDescriptor {[[Get]]: <i>thrower</i>, [[Set]]: <i>thrower</i>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b>}, and <b>false</b>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>F</i> with arguments <b>"arguments"</b>, PropertyDescriptor {[[Get]]: <i>thrower</i>, [[Set]]: <i>thrower</i>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b>}, and <b>false</b>.</p>
      <p>Set the [[Strict]] internal property of <i>F </i>to <i>Strict</i>.</p>
      <p>Return <i>F</i>.</p>
      <p>NOTE<span>	A </span><b>prototype</b> property is automatically created for every function, to allow for the possibility that the function will be used as a constructor.</p>
      <h2>13.1.1.1<span>	[[Call]]</span></h2>
      <p>When the [[Call]] internal method for a Function object <i>F</i> is called with a this value and a list of arguments, the following steps are taken:</p>
      <p>Let <i>callerContext</i> be the current execution context.</p>
      <p>Let <i>status</i><i> </i>be the result of establishing a new execution context for function code using <i>F</i>, the passed arguments List <i>args</i>, and the <b>this</b> value as described in 10.4.3.</p>
      <p>If <i>status</i> is an abrupt completion, then</p>
      <p>Restore <i>callerContext</i> as the current execution context.</p>
      <p>Return <i>status</i>.</p>
      <p>If <i>F</i> does not have a [[Code]] internal property, then </p>
      <p>Let <i>result</i> be NormalCompletion(undefined).</p>
      <p>Else,</p>
      <p>Let <i>result </i>be the result of evaluating the <i>FunctionBody</i> that is the value of<i> F</i>'s [[Code]] internal property. </p>
      <p>Restore <i>callerContext</i> as the current execution context.</p>
      <p>Return <i>result</i>.</p>
      <h2>13.1.1.2<span>	[[Construct]]</span></h2>
      <p>When the [[Construct]] internal method for a Function object <i>F</i> is called with a possibly empty list of arguments, the following steps are taken:</p>
      <p>Let <i>obj </i>be a newly created native ECMAScript object.</p>
      <p>Set all the internal methods of <i>obj</i> as specified in 8.12.</p>
      <p>Set the [[Extensible]] internal property of <i>obj </i>to <b>true</b>.</p>
      <p>Let <i>proto </i>be the value of calling the [[Get]] internal property of <i>F</i> with argument <b>"prototype"</b>.</p>
      <p>ReturnIfAbrupt(<i>proto</i>).</p>
      <p>If Type(<i>proto</i>)<i> </i>is Object, set the [[Prototype]] internal property of <i>obj </i>to <i>proto</i>.</p>
      <p>If Type(<i>proto</i>)<i> </i>is not Object, set the [[Prototype]] internal property of <i>obj </i>to the standard built-in Object prototype object as described in 15.2.4.</p>
      <p>Let <i>result </i>be the result of calling the [[Call]] internal property of <i>F</i>, providing <i>obj </i>as the <b>this</b> value and providing the argument list passed into [[Construct]] as <i>args</i>.</p>
      <p>ReturnIfAbrupt(<i>proto</i>).</p>
      <p>If Type(<i>result</i>.[[value]]) is Object then return <i>result</i>.</p>
      <p>Return NormalCompletion(<i>obj</i>).</p>
      <h2>13.1.1.3<span>	The [[ThrowTypeError]] Function Object</span></h2>
      <p>The [[ThrowTypeError]] object is a unique function object that is defined once as follows:</p>
      <p>Create a new native ECMAScript object and let <i>F</i> be that object.</p>
      <p>Set all the internal methods of <i>F</i> as described in 8.12.</p>
      <p>Add the [[NativeBrand]] internal property with value NativeFunction to <i>F</i>.</p>
      <p>Set the [[Prototype]] internal property of <i>F</i> to the standard built-in Function prototype object as specified in 15.3.3.1.</p>
      <p>Set the [[Call]] internal property of <i>F</i> as described in 13.2.1.</p>
      <p>Set the [[Scope]] internal property of <i>F</i> to the Global Environment.</p>
      <p>Set the [[FormalParameters]] internal property of <i>F </i>to the FormalParameterList <b>:</b> [empty] production.</p>
      <p>Set the [[Code]] internal property of <i>F </i>to be a <i>FunctionBody</i> that unconditionally throws a <b>TypeError</b> exception and performs no other action.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>F</i> with arguments <b>"</b><b>length</b><b>"</b>, Property Descriptor {[[Value]]: <i>0</i>, [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b>}, and <b>false</b>. </p>
      <p>Set the [[Extensible]] internal property of <i>F </i>to <b>false</b>.</p>
      <p>Let [[ThrowTypeError]] be <i>F</i>.</p>
      <h2>13.2<span>	Generator</span> Definitions</h2>
      <p>Syntax</p>
      <p>GeneratorDeclaration <b>:</b></p>
      <p><b>Function</b><b> * </b>BindingIdentifier <b>(</b> FormalParameterList <b>)</b> <b>{</b> FunctionBody <b>}</b></p>
      <p>GeneratorExpression <b>:</b></p>
      <p><b>Function</b><b> * </b>BindingIdentifier<sub>opt</sub> <b>(</b> FormalParameterList <b>)</b> <b>{</b> FunctionBody <b>}</b></p>
      <h1>14<span>	Progra</span>m</h1>
      <p>Syntax</p>
      <p>Program <b>:</b></p>
      <p>ProgramBody<sub>opt</sub></p>
      <p>ProgramBody <b>:</b></p>
      <p>StatementList</p>
      <p>Semantics</p>
      <p>The production <i>Program </i><b>:</b><i> </i><i>ProgramBody</i><sub>opt</sub> is evaluated as follows:</p>
      <p>The code of this <i>Program</i> is strict mode code if the Directive Prologue (14.1) of its <i>ProgramBody</i> contains a Use Strict Directive or if any of the conditions of 10.1.1 apply. If the code of this <i>Program</i> is strict mode code, <i>ProgramBody</i> is evaluated in the following steps as strict mode code.  Otherwise <i>ProgramBody</i> is evaluated in the following steps as non-strict mode code.</p>
      <p>If <i>ProgramBody</i> is not present, return NormalCompletion(empty).</p>
      <p>Let <i>progCxt</i> be a new execution context for global code as described in 10.4.1. </p>
      <p>Let <i>result </i>be the result of evaluating <i>ProgramBody</i>.</p>
      <p>Exit the execution context <i>progCxt</i>.</p>
      <p>Return <i>result</i>.</p>
      <p>NOTE<span>	The processes for initiating the evaluation of a </span>Program and for dealing with the result of such an evaluation are defined by an ECMAScript implementation and not by this specification.</p>
      <p>The production ProgramBody <b>:</b> StatementList is evaluated as follows:</p>
      <p>Return the result of evaluating <i>StatementList</i>. </p>
      <h2>14.1<span>	Directive Prologues and the Use Strict Directive</span></h2>
      <p>A Directive Prologue is the longest sequence of <i>ExpressionStatement </i>productions occurring as the initial <i>StatementListItem</i> productions of a <i>ProgramBody</i> or <i>FunctionBody</i> and where each <i>ExpressionStatement </i>in the sequence consists entirely of a <i>StringLiteral</i> token followed a semicolon. The semicolon may appear explicitly or may be inserted by automatic semicolon insertion. A Directive Prologue may be an empty sequence.</p>
      <p>A Use Strict Directive is an <i>ExpressionStatement</i> in a Directive Prologue whose <i>StringLiteral</i> is either the exact character sequences <b>"use</b> <b>strict"</b> or<b> 'use</b> <b>strict'</b>. A Use Strict Directive may not contain an <i>EscapeSequence</i> or <i>LineContinuation</i>.</p>
      <p>A Directive Prologue may contain more than one Use Strict Directive. However, an implementation may issue a warning if this occurs.</p>
      <p>NOTE<span>	The </span>ExpressionStatement productions of a Directive Prologue are evaluated normally during evaluation of the containing production. Implementations may define implementation specific meanings for ExpressionStatement productions which are not a Use Strict Directive and which occur in a Directive Prologue.  If an appropriate notification mechanism exists, an implementation should issue a warning if it encounters in a Directive Prologue an ExpressionStatement that is not a Use Strict Directive or which does not have a meaning defined by the implementation.</p>
      <h1>15	Standard Built-in ECMAScript Objects</h1>
      <p>There are certain built-in objects available whenever an ECMAScript program begins execution. One, the global object, is part of the lexical environment of the executing program. Others are accessible as initial properties of the global object.</p>
      <p>Unless specified otherwise, a built-in object has the [[NativeBrand]] internal property with value NativeFunction if that built-in object has a [[Call]] internal property. Unless specified otherwise, the [[Extensible]] internal property of a built-in object initially has the value <b>true</b>.</p>
      <p>Many built-in objects are functions: they can be invoked with arguments. Some of them furthermore are constructors: they are functions intended for use with the <b>new</b> operator. For each built-in function, this specification describes the arguments required by that function and properties of the Function object. For each built-in constructor, this specification furthermore describes properties of the prototype object of that constructor and properties of specific object instances returned by a <b>new</b> expression that invokes that constructor.</p>
      <p>Unless otherwise specified in the description of a particular function, if a function or constructor described in this clause is given fewer arguments than the function is specified to require, the function or constructor shall behave exactly as if it had been given sufficient additional arguments, each such argument being the <b>undefined</b> value.</p>
      <p>Unless otherwise specified in the description of a particular function, if a function or constructor described in this clause is given more arguments than the function is specified to allow, the extra arguments are evaluated by the call and then ignored by the function. However, an implementation may define implementation specific behaviour relating to such arguments as long as the behaviour is not the throwing of a <b>TypeError</b> exception that is predicated simply on the presence of an extra argument.</p>
      <p>NOTE<span>	Implementations that add additional capabilities to the set of built-in functions are encouraged to do so by adding new functions rather than adding new parameters to existing functions.</span></p>
      <p>Every built-in function and every built-in constructor has the Function prototype object, which is the initial value of the expression <b>Function.prototype</b> (15.3.4), as the value of its [[Prototype]] internal property.</p>
      <p>Unless otherwise specified every built-in prototype object has the Object prototype object, which is the initial value of the expression <b>Object.prototype</b> (15.2.4), as the value of its [[Prototype]] internal property, except the Object prototype object itself.</p>
      <p>None of the built-in functions described in this clause that are not constructors shall implement the [[Construct]] internal method unless otherwise specified in the description of a particular function. The behavior specified in this clause for each built-in function is the specification of the [[Call]] internal method behavior for that function.  None of the built-in functions described in this clause shall have a <b>prototype</b> property unless otherwise specified in the description of a particular function.</p>
      <p>This clause generally describes distinct behaviours for when a constructor is “called as a function” and for when it is “called as part of a <b>new</b> expression”. The “called as a function” behaviour corresponds to the invocation of the constructor’s [[Call]] internal method and the “called as part of a new expression” behaviour corresponds to the invocation of the constructor’s [[Construct]] internal method. </p>
      <p>Every built-in Function object described in this clause—whether as a constructor, an ordinary function, or both—has a <b>length</b> property whose value is an integer. Unless otherwise specified, this value is equal to the largest number of named arguments shown in the subclause headings for the function description, including optional parameters.</p>
      <p>NOTE<span>	For example, the Function object that is the initial value of the </span>slice property of the String prototype object is described under the subclause heading “String.prototype.slice (start, end)” which shows the two named arguments start and end; therefore the value of the length property of that Function object is 2.</p>
      <p>In every case, the <b>length</b> property of a built-in Function object described in this clause has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }. Every other property described in this clause has the attributes { [[Writable]]: <b>true</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>true</b> } unless otherwise specified.</p>
      <h2>15.1<span>	The Global Objec</span>t</h2>
      <p>The unique <i>global object</i> is created before control enters any execution context. </p>
      <p>Unless otherwise specified, the standard built-in properties of the global object have attributes {[[Writable]]: <b>true</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>true</b>}.</p>
      <p>The global object does not have a [[Construct]] internal property; it is not possible to use the global object as a constructor with the <b>new</b> operator.</p>
      <p>The global object does not have a [[Call]] internal property; it is not possible to invoke the global object as a function.</p>
      <p>The value of the [[Prototype]] internal property of the global object is implementation-dependent.</p>
      <p>In addition to the properties defined in this specification the global object may have additional host defined properties. This may include a property whose value is the global object itself; for example, in the HTML document object model the <b>window</b> property of the global object is the global object itself.</p>
      <h2>15.1.1<span>	Value Properties of the Global Objec</span>t</h2>
      <h2>15.1.1.1<span>	Na</span>N</h2>
      <p>The value of <b>NaN</b> is <b>NaN</b> (see 8.5). This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.1.1.2<span>	Infinit</span>y</h2>
      <p>The value of <b>Infinity</b> is <b>+</b><b>∞</b> (see 8.5). This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.1.1.3<span>	undefined</span></h2>
      <p>The value of <b>undefined</b> is <b>undefined</b> (see 8.1). This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.1.2<span>	Function Properties of the Global Objec</span>t</h2>
      <h2>15.1.2.1<span>	eval (x</span>)</h2>
      <p>When the <b>eval</b> function is called with one argument <i>x</i>, the following steps are taken:</p>
      <p>If Type(<i>x</i>) is not String, return <i>x</i>.</p>
      <p>Let <i>prog </i>be the ECMAScript code that is the result of parsing <i>x </i>as a <i>Program</i>. If the parse fails, throw a <b>SyntaxError</b> exception (but see also clause 16).</p>
      <p>Let <i>evalCtx </i>be the result of establishing a new execution context (10.4.2) for the eval code <i>prog</i>.</p>
      <p>Let <i>result </i>be the result of evaluating the program <i>prog</i>.</p>
      <p>Exit the running execution context <i>evalCtx</i>, restoring the previous execution context.</p>
      <p>If <i>result</i>.type is normal and its completion value is a value <i>V</i>, then return the value <i>V</i>.</p>
      <p>If <i>result</i>.type is normal and its completion value is empty, then return the value <b>undefined</b>.</p>
      <p>Otherwise, <i>result</i>.type must be throw. Throw <i>result</i>.value as an exception.</p>
      <p>15.1.2.1.1<span>	Direct Call to Eval</span></p>
      <p>A direct call to the eval function is one that is expressed as a <i>CallExpression</i> that meets the following two conditions:</p>
      <p>The Reference that is the result of evaluating the <i>MemberExpression</i> in the <i>CallExpression</i> has an environment record as its base value and its reference name is "<b>eval</b>".</p>
      <p>The result of calling the abstract operation GetValue with that Reference as the argument is the standard built-in function defined in 15.1.2.1.</p>
      <h2>15.1.2.2<span>	parseInt (string , radix</span>)</h2>
      <p>The <b>parseInt</b> function produces an integer value dictated by interpretation of the contents of the <i>string</i> argument according to the specified <i>radix</i>. Leading white space in <i>string</i> is ignored. If <i>radix</i> is <b>undefined</b> or 0, it is assumed to be 10 except when the number begins with the character pairs <b>0x</b> or <b>0X</b>, in which case a radix of 16 is assumed. If <i>radix</i> is 16, the number may also optionally begin with the character pairs <b>0x</b> or <b>0X</b>.</p>
      <p>When the <b>parseInt</b> function is called, the following steps are taken:</p>
      <p>Let <i>inputString</i> be ToString(<i>string</i>).</p>
      <p>Let <i>S</i> be a newly created substring of <i>inputString</i> consisting of the first character that is not a <i>StrWhiteSpaceChar</i> and all characters following that character. (In other words, remove leading white space.) If <i>inputString</i> does not contain any such characters, let <i>S</i> be the empty string.</p>
      <p>Let <i>sign</i> be 1.</p>
      <p>If <i>S</i> is not empty and the first character of <i>S</i> is a minus sign <b>-</b>, let <i>sign</i> be −1.</p>
      <p>If <i>S</i> is not empty and the first character of <i>S</i> is a plus sign <b>+</b> or a minus sign <b>-</b>, then remove the first character from <i>S</i>.</p>
      <p>Let <i>R</i> = ToInt32(<i>radix</i>).</p>
      <p>Let <i>stripPrefix</i> be <b>true</b>.</p>
      <p>If <i>R</i> ≠ 0, then</p>
      <p>If <i>R</i> &lt; 2 or <i>R</i> &gt; 36, then return <b>NaN</b>.</p>
      <p>If <i>R</i> ≠ 16, let <i>stripPrefix</i> be <b>false</b>.</p>
      <p>Else, <i>R</i> = 0</p>
      <p>Let <i>R</i> = 10.</p>
      <p>If <i>stripPrefix</i> is <b>true</b>, then</p>
      <p>If the length of <i>S</i> is at least 2 and the first two characters of <i>S</i> are either “<b>0x</b>” or “<b>0X</b>”, then remove the first two characters from <i>S</i> and let <i>R</i> = 16.</p>
      <p>If <i>S</i> contains any character that is not a radix-<i>R</i> digit, then let <i>Z</i> be the substring of <i>S</i> consisting of all characters before the first such character; otherwise, let <i>Z</i> be <i>S</i>.</p>
      <p>If <i>Z</i> is empty, return <b>NaN</b>.</p>
      <p>Let <i>mathInt</i> be the mathematical integer value that is represented by <i>Z</i> in radix-<i>R</i> notation, using the letters <b>A</b>-<b>Z</b> and <b>a</b>-<b>z</b> for digits with values 10 through 35. (However, if <i>R</i> is 10 and <i>Z</i> contains more than 20 significant digits, every significant digit after the 20th may be replaced by a <b>0 </b>digit, at the option of the implementation; and if <i>R</i> is not 2, 4, 8, 10, 16, or 32, then <i>mathInt</i> may be an implementation-dependent approximation to the mathematical integer value that is represented by <i>Z</i> in radix-<i>R</i> notation.)</p>
      <p>Let <i>number</i> be the Number value for <i>mathInt</i>.</p>
      <p>Return <i>sign</i> × <i>number</i>.</p>
      <p>NOTE	<b>parseInt</b> may interpret only a leading portion of <i>string</i> as an integer value; it ignores any characters that cannot be interpreted as part of the notation of an integer, and no indication is given that any such characters were ignored.</p>
      <h2>15.1.2.3<span>	parseFloat (string</span>)</h2>
      <p>The <b>parseFloat</b> function produces a Number value dictated by interpretation of the contents of the <i>string</i> argument as a decimal literal.</p>
      <p>When the <b>parseFloat</b> function is called, the following steps are taken:</p>
      <p>Let <i>inputString</i> be ToString(<i>string</i>).</p>
      <p>Let <i>trimmedString</i> be a substring of <i>inputString</i> consisting of the leftmost character that is not a <i>StrWhiteSpaceChar</i> and all characters to the right of that character. (In other words, remove leading white space.) If <i>inputString</i> does not contain any such characters, let <i>trimmedString</i> be the empty string.</p>
      <p>If neither <i>trimmedString</i> nor any prefix of <i>trimmedString</i> satisfies the syntax of a <i>StrDecimalLiteral</i> (see 9.3.1), return <b>NaN</b>.</p>
      <p>Let <i>numberString</i> be the longest prefix of <i>trimmedString</i>, which might be <i>trimmedString</i> itself, that satisfies the syntax of a <i>StrDecimalLiteral</i>.</p>
      <p>Return the Number value for the MV of <i>numberString</i>.</p>
      <p>NOTE	<b>parseFloat</b> may interpret only a leading portion of <i>string</i> as a Number value; it ignores any characters that cannot be interpreted as part of the notation of an decimal literal, and no indication is given that any such characters were ignored.</p>
      <h2>15.1.2.4<span>	isNaN (number</span>)</h2>
      <p>Returns <b>true</b> if the argument coerces to <b>NaN</b>, and otherwise returns <b>false</b>.</p>
      <p>If ToNumber(<i>number</i>) is <b>NaN</b>, return <b>true</b>.</p>
      <p>Otherwise, return <b>false</b>.</p>
      <p>NOTE<span>	A reliable way for ECMAScript code to test if a value </span>X is a <b>NaN</b> is an expression of the form X !== X. The result will be <b>true</b> if and only if X is a <b>NaN</b>.</p>
      <h2>15.1.2.5<span>	isFinite (number</span>)</h2>
      <p>Returns <b>false</b> if the argument coerces to <b>NaN</b>, <b>+</b><b>∞</b>, or <b>−</b><b>∞</b>, and otherwise returns <b>true</b>.</p>
      <p>If ToNumber(<i>number</i>) is <b>NaN</b>, <b>+</b><b>∞</b>, or <b>−</b><b>∞</b>, return <b>false</b>.</p>
      <p>Otherwise, return <b>true</b>.</p>
      <h2>15.1.3<span>	URI Handling Function Properties</span></h2>
      <p>Uniform Resource Identifiers, or URIs, are Strings that identify resources (e.g. web pages or files) and transport protocols by which to access them (e.g. HTTP or FTP) on the Internet. The ECMAScript language itself does not provide any support for using URIs except for functions that encode and decode URIs as described in 15.1.3.1, 15.1.3.2, 15.1.3.3 and 15.1.3.4.</p>
      <p>NOTE<span>	Many implementations of ECMAScript provide additional function</span>s and methods that manipulate web pages; these functions are beyond the scope of this standard.</p>
      <p>A URI is composed of a sequence of components separated by component separators. The general form is:</p>
      <p>     Scheme <b>:</b> First <b>/</b> Second <b>;</b> Third <b>?</b> Fourth</p>
      <p>where the italicised names represent components and “<b>:</b>”, “<b>/</b>”, “<b>;</b>” and “<b>?</b>” are reserved characters used as separators. The <b>encodeURI</b> and <b>decodeURI</b> functions are intended to work with complete URIs; they assume that any reserved characters in the URI are intended to have special meaning and so are not encoded. The  <b>encodeURIComponent</b><b> </b>and <b>decodeURIComponent</b><b> </b>functions<b> </b>are intended to work with the individual component parts of a URI; they assume that any reserved characters represent text and so must be encoded so that they are not interpreted as reserved characters when the component is part of a complete URI.</p>
      <p>The following lexical grammar specifies the form of encoded URIs.</p>
      <p>Syntax</p>
      <p>uri <b>:::</b></p>
      <p>uriCharacters<sub>opt</sub></p>
      <p>uriCharacters <b>:::</b></p>
      <p>uriCharacter uriCharacters<sub>opt</sub></p>
      <p>uriCharacter <b>:::</b></p>
      <p>uriReserved<span><br>uriUnescaped</span><span><br>uriEscaped</span></p>
      <p>uriReserved <b>:::</b> <b>one of</b></p>
      <p>
        <b>;  /  ?  :  @  &amp;  =  +  $  ,</b>
      </p>
      <p>uriUnescaped <b>:::</b></p>
      <p>uriAlpha<span><br>DecimalDigit</span><span><br>uriMark</span></p>
      <p>uriEscaped <b>:::</b></p>
      <p><b>%</b> HexDigit HexDigit</p>
      <p>uriAlpha <b>:::</b> <b>one of</b></p>
      <p>
        <b>a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z</b>
        <b><br>A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z</b>
      </p>
      <p>uriMark <b>:::</b> <b>one of</b></p>
      <p>
        <b>-  _  .  !  ~  *  '  (  )</b>
      </p>
      <p>NOTE<span>	The above syntax is based upon RFC 2396 and does not reflect changes introduced by the more recent RFC 3986.  </span></p>
      <p>When a character to be included in a URI is not listed above or is not intended to have the special meaning sometimes given to the reserved characters, that character must be encoded. The character is transformed into its UTF-8 encoding, with surrogate pairs first converted from UTF-16 to the corresponding code point value. (Note that for code units in the range [0,127] this results in a single octet with the same value.) The resulting sequence of octets is then transformed into a String with each octet represented by an escape sequence of the form “<b>%</b>xx”.</p>
      <p>The encoding and escaping process is described by the abstract operation Encode taking two String arguments <i>string</i> and <i>unescapedSet</i>.</p>
      <p>Let <i>strLen</i> be the number of characters in <i>string</i>.</p>
      <p>Let <i>R</i> be the empty String.</p>
      <p>Let <i>k</i> be 0.</p>
      <p>Repeat</p>
      <p>If <i>k</i> equals <i>strLen</i>, return <i>R</i>.</p>
      <p>Let <i>C</i> be the character at position <i>k</i> within <i>string</i>.</p>
      <p>If <i>C</i> is in <i>unescapedSet</i>, then</p>
      <p>Let <i>S</i> be a String containing only the character <i>C</i>.</p>
      <p>Let <i>R</i> be a new String value computed by concatenating the previous value of <i>R</i> and <i>S</i>.</p>
      <p>Else, <i>C</i> is not in <i>unescapedSet</i></p>
      <p>If the code unit value of <i>C</i> is not less than 0xDC00 and not greater than 0xDFFF, throw a <b>URIError</b> exception.</p>
      <p>If the code unit value of <i>C</i> is less than 0xD800 or greater than 0xDBFF, then</p>
      <p>Let <i>V</i> be the code unit value of <i>C</i>.</p>
      <p>Else, </p>
      <p>Increase <i>k</i> by 1.</p>
      <p>If <i>k</i> equals <i>strLen</i>, throw a <b>URIError</b> exception.</p>
      <p>Let <i>kChar</i> be the code unit value of the character at position <i>k</i> within <i>string</i>.</p>
      <p>If <i>kChar</i> is less than 0xDC00 or greater than 0xDFFF, throw a <b>URIError</b> exception.</p>
      <p>Let <i>V</i> be (((the code unit value of <i>C</i>) – 0xD800) × 0x400 + (<i>kChar</i> – 0xDC00) + 0x10000).</p>
      <p>Let <i>Octets</i> be the array of octets resulting by applying the UTF-8 transformation to <i>V</i>, and let <i>L</i> be the array size.</p>
      <p>Let <i>j</i> be 0.</p>
      <p>Repeat, while <i>j</i> &lt; <i>L</i></p>
      <p>Let <i>jOctet</i> be the value at position <i>j</i> within <i>Octets</i>.</p>
      <p>Let <i>S</i> be a String containing three characters “<b>%</b><i>XY</i>” where <i>XY</i> are two uppercase hexadecimal digits encoding the value of <i>jOctet</i>.</p>
      <p>Let <i>R</i> be a new String value computed by concatenating the previous value of <i>R</i> and <i>S</i>.</p>
      <p>Increase <i>j</i> by 1.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>The unescaping and decoding process is described by the abstract operation Decode taking two String arguments <i>string</i> and <i>reservedSet</i>.</p>
      <p>Let <i>strLen</i> be the number of characters in <i>string</i>.</p>
      <p>Let <i>R</i> be the empty String.</p>
      <p>Let <i>k</i> be 0.</p>
      <p>Repeat</p>
      <p>If <i>k</i> equals <i>strLen</i>, return <i>R</i>.</p>
      <p>Let <i>C</i> be the character at position <i>k</i> within <i>string</i>.</p>
      <p>If <i>C</i> is not ‘<b>%</b>’, then</p>
      <p>Let <i>S</i> be the String containing only the character <i>C</i>.</p>
      <p>Else, <i>C</i> is ‘<b>%</b>’</p>
      <p>Let <i>start</i> be <i>k</i>.</p>
      <p>If <i>k</i> + 2 is greater than or equal to <i>strLen</i>, throw a <b>URIError</b> exception.</p>
      <p>If the characters at position (<i>k</i>+1) and (<i>k</i> + 2) within <i>string </i>do not represent hexadecimal digits, throw a <b>URIError</b> exception.</p>
      <p>Let <i>B</i> be the 8-bit value represented by the two hexadecimal digits at position (<i>k</i> + 1) and (<i>k</i> + 2).</p>
      <p>Increment <i>k</i> by 2.</p>
      <p>If the most significant bit in <i>B</i> is 0, then</p>
      <p>Let <i>C</i> be the character with code unit value <i>B</i>.</p>
      <p>If <i>C</i> is not in <i>reservedSet</i>, then</p>
      <p>Let <i>S</i> be the String containing only the character <i>C</i>.</p>
      <p>Else, <i>C</i> is in <i>reservedSet</i></p>
      <p>Let <i>S</i> be the substring of <i>string</i> from position <i>start</i> to position <i>k</i> included.</p>
      <p>Else, the most significant bit in <i>B</i> is 1</p>
      <p>Let <i>n</i> be the smallest non-negative number such that (<i>B</i> &lt;&lt; <i>n</i>) &amp; 0x80 is equal to 0.</p>
      <p>If <i>n</i> equals 1 or <i>n</i> is greater than 4, throw a <b>URIError</b> exception.</p>
      <p>Let <i>Octets</i> be an array of 8-bit integers of size <i>n</i>.</p>
      <p>Put <i>B</i> into <i>Octets</i> at position 0.</p>
      <p>If <i>k</i> + (3 × (<i>n</i> – 1)) is greater than or equal to <i>strLen</i>, throw a <b>URIError</b> exception.</p>
      <p>Let <i>j</i> be 1.</p>
      <p>Repeat, while <i>j</i> &lt; <i>n</i></p>
      <p>Increment <i>k</i> by 1.</p>
      <p>If the character at position <i>k</i> is not ‘%’, throw a <b>URIError</b> exception.</p>
      <p>If the characters at position (<i>k</i> +1) and (<i>k</i> + 2) within <i>string</i> do not represent hexadecimal digits, throw a <b>URIError</b> exception.</p>
      <p>Let <i>B</i> be the 8-bit value represented by the two hexadecimal digits at position (<i>k</i> + 1) and (<i>k</i> + 2).</p>
      <p>If the two most significant bits in <i>B</i> are not 10, throw a <b>URIError</b> exception.</p>
      <p>Increment <i>k</i> by 2.</p>
      <p>Put <i>B</i> into <i>Octets</i> at position <i>j</i>.</p>
      <p>Increment <i>j</i> by 1.</p>
      <p>Let <i>V</i> be the value obtained by applying the UTF-8 transformation to <i>Octets</i>, that is, from an array of octets into a 21-bit value. If <i>Octets</i> does not contain a valid UTF-8 encoding of a Unicode code point throw an <b>URIError</b> exception.</p>
      <p>If <i>V</i> is less than 0x10000, then</p>
      <p>Let <i>C</i> be the character with code unit value <i>V</i>.</p>
      <p>If <i>C</i> is not in <i>reservedSet</i>, then</p>
      <p>Let <i>S</i> be the String containing only the character <i>C</i>.</p>
      <p>Else, <i>C</i> is in <i>reservedSet</i></p>
      <p>Let <i>S</i> be the substring of <i>string</i> from position <i>start</i> to position <i>k</i> included.</p>
      <p>Else, <i>V</i> is ≥ 0x10000</p>
      <p>Let <i>L</i> be (((<i>V</i> – 0x10000) &amp; 0x3FF) + 0xDC00).</p>
      <p>Let <i>H</i> be ((((<i>V</i> – 0x10000) &gt;&gt; 10) &amp; 0x3FF) + 0xD800).</p>
      <p>Let <i>S</i> be the String containing the two characters with code unit values <i>H</i> and <i>L</i>.</p>
      <p>Let <i>R</i> be a new String value computed by concatenating the previous value of <i>R</i> and <i>S</i>.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>NOTE<span>	This syntax of Uniform Resource Identifiers is based upon RFC 2396 and does not reflect the more recent RFC 3986 which replaces RFC 2396.  A formal description and implementation of UTF-8 is given in RFC 3629.</span></p>
      <p>In UTF-8, characters are encoded using sequences of 1 to 6 octets. The only octet of a "sequence" of one has the higher-order bit set to 0, the remaining 7 bits being used to encode the character value. In a sequence of n octets, n&gt;1, the initial octet has the n higher-order bits set to 1, followed by a bit set to 0. The remaining bits of that octet contain bits from the value of the character to be encoded. The following octets all have the higher-order bit set to 1 and the following bit set to 0, leaving 6 bits in each to contain bits from the character to be encoded. The possible UTF-8 encodings of ECMAScript characters are specified in Table 22.</p>
      <p>Table 22 — UTF-8 Encodings</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Code Unit Value</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Representation</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">1</span>
                <span style="font-weight: bold; vertical-align: super; font-style: italic">st</span>
                <span style="font-weight: bold; font-style: italic"> Octet</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">2</span>
                <span style="font-weight: bold; vertical-align: super; font-style: italic">nd</span>
                <span style="font-weight: bold; font-style: italic"> Octet</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">3</span>
                <span style="font-weight: bold; vertical-align: super; font-style: italic">rd</span>
                <span style="font-weight: bold; font-style: italic"> Octet</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">4</span>
                <span style="font-weight: bold; vertical-align: super; font-style: italic">th</span>
                <span style="font-weight: bold; font-style: italic"> Octet</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>0x0000 - 0x007F</b>
              </p>
            </td>
            <td>
              <p><b>00000000</b> <b>0</b><i>zzzzzzz</i></p>
            </td>
            <td>
              <p>
                <b>0</b>
                <i>zzzzzzz</i>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>0x0080 - 0x07FF</b>
              </p>
            </td>
            <td>
              <p>
                <b>00000</b>
                <i>yyy yyzzzzzz</i>
              </p>
            </td>
            <td>
              <p>
                <b>110</b>
                <i>yyyyy</i>
              </p>
            </td>
            <td>
              <p>
                <b>10</b>
                <i>zzzzzz</i>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>0x0800 - 0xD7FF</b>
              </p>
            </td>
            <td>
              <p>
                <i>xxxxyyyy yyzzzzzz</i>
              </p>
            </td>
            <td>
              <p>
                <b>1110</b>
                <i>xxxx</i>
              </p>
            </td>
            <td>
              <p>
                <b>10</b>
                <i>yyyyyy</i>
              </p>
            </td>
            <td>
              <p>
                <b>10</b>
                <i>zzzzzz</i>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>0xD800 - 0xDBFF</b>
              </p>
              <p>
                <i>followed by</i>
              </p>
              <p>
                <b>0xDC00 – 0xDFFF</b>
              </p>
            </td>
            <td>
              <p>
                <b>110110</b>
                <i>vv vvwwwwxx</i>
              </p>
              <p>
                <i>followed by</i>
              </p>
              <p>
                <b>110111</b>
                <i>yy yyzzzzzz</i>
              </p>
            </td>
            <td>
              <p>
              </p>
              <p>
                <b>11110</b>
                <i>uuu</i>
              </p>
            </td>
            <td>
              <p>
              </p>
              <p>
                <b>10</b>
                <i>uuwwww</i>
              </p>
            </td>
            <td>
              <p>
              </p>
              <p>
                <b>10</b>
                <i>xxyyyy</i>
              </p>
            </td>
            <td>
              <p>
              </p>
              <p>
                <b>10</b>
                <i>zzzzzz</i>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>0xD800 - 0xDBFF</b>
              </p>
              <p>
                <i>not followed by</i>
              </p>
              <p>
                <b>0xDC00 – 0xDFFF</b>
              </p>
            </td>
            <td>
              <p>
              </p>
              <p><i>causes</i> URIError</p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>0xDC00 – 0xDFFF</b>
              </p>
            </td>
            <td>
              <p><i>causes</i> URIError</p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>0xE000 - 0xFFFF</b>
              </p>
            </td>
            <td>
              <p>
                <i>xxxxyyyy yyzzzzzz</i>
              </p>
            </td>
            <td>
              <p>
                <b>1110</b>
                <i>xxxx</i>
              </p>
            </td>
            <td>
              <p>
                <b>10</b>
                <i>yyyyyy</i>
              </p>
            </td>
            <td>
              <p>
                <b>10</b>
                <i>zzzzzz</i>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>Where</p>
      <p>uuuuu = <i>vvvv </i> + 1</p>
      <p>to account for the addition of 0x10000 as in Surrogates, section 3.7, of the Unicode Standard.</p>
      <p>The range of code unit values 0xD800-0xDFFF is used to encode surrogate pairs; the above transformation combines a UTF-16 surrogate pair into a UTF-32 representation and encodes the resulting 21-bit value in UTF-8. Decoding reconstructs the surrogate pair.</p>
      <p>RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For example, the invalid sequence C0 80 must not decode into the character U+0000. Implementations of the Decode algorithm are required to throw a <b>URIError</b> when encountering such invalid sequences.</p>
      <h2>15.1.3.1<span>	decodeURI (encodedURI)</span></h2>
      <p>The <b>decodeURI</b> function computes a new version of a URI in which each escape sequence and UTF-8 encoding of the sort that might be introduced by the <b>encodeURI</b> function is replaced with the character that it represents. Escape sequences that could not have been introduced by <b>encodeURI</b> are not replaced.</p>
      <p>When the <b>decodeURI</b> function is called with one argument <i>encodedURI</i>, the following steps are taken:</p>
      <p>Let <i>uriString</i> be ToString(<i>encodedURI</i>).</p>
      <p>Let <i>reservedURISet</i> be a String containing one instance of each character valid in <i>uriReserved</i> plus “<b>#</b>”.</p>
      <p>Return the result of calling Decode(<i>uriString</i>, <i>reservedURISet</i>)</p>
      <p>NOTE<span>	The character “</span><b>#</b>” is not decoded from escape sequences even though it is not a reserved URI character.</p>
      <h2>15.1.3.2<span>	decodeURIComponent (encodedURIComponent)</span></h2>
      <p>The <b>decodeURIComponent</b> function computes a new version of a URI in which each escape sequence and UTF-8 encoding of the sort that might be introduced by the <b>encodeURIComponent</b> function is replaced with the character that it represents.</p>
      <p>When the <b>decodeURIComponent</b> function is called with one argument <i>encodedURIComponent</i>, the following steps are taken:</p>
      <p>Let <i>componentString</i> be ToString(<i>encodedURIComponent</i>).</p>
      <p>Let <i>reservedURIComponentSet</i> be the empty String.</p>
      <p>Return the result of calling Decode(<i>componentString</i>, <i>reservedURIComponentSet</i>)</p>
      <h2>15.1.3.3<span>	encodeURI (uri)</span></h2>
      <p>The <b>encodeURI</b> function computes a new version of a URI in which each instance of certain characters is replaced by one, two, three, or four escape sequences representing the UTF-8 encoding of the character.</p>
      <p>When the <b>encodeURI</b> function is called with one argument <i>uri</i>, the following steps are taken:</p>
      <p>Let <i>uriString</i> be ToString(<i>uri</i>).</p>
      <p>Let <i>unescapedURISet</i> be a String containing one instance of each character valid in <i>uriReserved</i> and <i>uriUnescaped</i> plus “<b>#</b>”.</p>
      <p>Return the result of calling Encode(<i>uriString</i>, <i>unescapedURISet</i>)</p>
      <p>NOTE<span>	The character “</span><b>#</b>” is not encoded to an escape sequence even though it is not a reserved or unescaped URI character.</p>
      <h2>15.1.3.4<span>	encodeURIComponent (uriComponent)</span></h2>
      <p>The <b>encodeURIComponent</b> function computes a new version of a URI in which each instance of certain characters is replaced by one, two, three, or four escape sequences representing the UTF-8 encoding of the character.</p>
      <p>When the <b>encodeURIComponent</b> function is called with one argument <i>uriComponent</i>, the following steps are taken:</p>
      <p>Let <i>componentString</i> be ToString(<i>uriComponent</i>).</p>
      <p>Let <i>unescapedURIComponentSet</i> be a String containing one instance of each character valid in <i>uriUnescaped</i>.</p>
      <p>Return the result of calling Encode(<i>componentString</i>, <i>unescapedURIComponentSet</i>)</p>
      <h2>15.1.4<span>	Constructor Properties of the Global Objec</span>t</h2>
      <h2>15.1.4.1<span>	Object ( . . . </span>)</h2>
      <p>See 15.2.1 and 15.2.2.</p>
      <h2>15.1.4.2<span>	Function ( . . . </span>)</h2>
      <p>See 15.3.1 and 15.3.2.</p>
      <h2>15.1.4.3<span>	Array ( . . . </span>)</h2>
      <p>See 15.4.1 and 15.4.2.</p>
      <h2>15.1.4.4<span>	String ( . . . </span>)</h2>
      <p>See 15.5.1 and 15.5.2.</p>
      <h2>15.1.4.5<span>	Boolean ( . . . </span>)</h2>
      <p>See 15.6.1 and 15.6.2.</p>
      <h2>15.1.4.6<span>	Number ( . . . </span>)</h2>
      <p>See 15.7.1 and 15.7.2.</p>
      <h2>15.1.4.7<span>	Date ( . . . </span>)</h2>
      <p>See 15.9.2.</p>
      <h2>15.1.4.8<span>	RegExp ( . . . )</span></h2>
      <p>See 15.10.3 and 15.10.4.</p>
      <h2>15.1.4.9<span>	Error ( . . . )</span></h2>
      <p>See 15.11.1 and 15.11.2.</p>
      <h2>15.1.4.10<span>	EvalError ( . . . )</span></h2>
      <p>See 15.11.6.1.</p>
      <h2>15.1.4.11<span>	RangeError ( . . . )</span></h2>
      <p>See 15.11.6.2.</p>
      <h2>15.1.4.12<span>	ReferenceError ( . . . )</span></h2>
      <p>See 15.11.6.3.</p>
      <h2>15.1.4.13<span>	SyntaxError ( . . . )</span></h2>
      <p>See 15.11.6.4.</p>
      <h2>15.1.4.14<span>	TypeError ( . . . )</span></h2>
      <p>See 15.11.6.5.</p>
      <h2>15.1.4.15<span>	URIError ( . . . )</span></h2>
      <p>See 15.11.6.6.</p>
      <h2>15.1.5<span>	Other Properties of the Global Objec</span>t</h2>
      <h2>15.1.5.1<span>	Mat</span>h</h2>
      <p>See 15.8.</p>
      <h2>15.1.5.2<span>	JSON</span></h2>
      <p>See 15.12.</p>
      <h2>15.2<span>	Object Objec</span>ts</h2>
      <h2>15.2.1<span>	The Object Constructor Called as a Functio</span>n</h2>
      <p>When <b>Object</b> is called as a function rather than as a constructor, it performs a type conversion.</p>
      <h2>15.2.1.1<span>	Object ( [ value</span> ] )</h2>
      <p>When the <b>Object</b> function is called with no arguments or with one argument <i>value</i>, the following steps are taken:</p>
      <p>If <i>value</i> is <b>null</b>, <b>undefined</b> or not supplied, create and return a new Object object exactly as if the standard built-in Object constructor had been called with the same arguments (15.2.2.1).</p>
      <p>Return ToObject(<i>value</i>).</p>
      <h2>15.2.2<span>	The Object Constructo</span>r</h2>
      <p>When <b>Object</b> is called as part of a <b>new</b> expression, it is a constructor that may create an object.</p>
      <h2>15.2.2.1<span>	new Object ( [ value</span> ] )</h2>
      <p>When the <b>Object</b> constructor is called with no arguments or with one argument <i>value</i>, the following steps are taken:</p>
      <p>If <i>value</i> is supplied, then</p>
      <p>If Type(<i>value</i>)  is Object, then</p>
      <p>If the <i>value</i> is a native ECMAScript object, do not create a new object but simply return <i>value</i>.</p>
      <p>If the <i>value</i> is a host object, then actions are taken and a result is returned in an implementation-dependent manner that may depend on the host object.</p>
      <p>If Type(<i>value</i>) is String, return ToObject(<i>value</i>).</p>
      <p>If Type(<i>value</i>) is Boolean, return ToObject(<i>value</i>).</p>
      <p>If Type(<i>value</i>) is Number, return ToObject(<i>value</i>).</p>
      <p>Assert: The argument <i>value</i> was not supplied or its type was Null or Undefined. </p>
      <p>Let <i>obj</i> be a newly created native ECMAScript object.</p>
      <p>Set the [[Prototype]] internal property of <i>obj</i> to the standard built-in Object prototype object (15.2.4).</p>
      <p>Set the [[Extensible]] internal property of <i>obj</i> to <b>true</b>.</p>
      <p>Set all the internal methods of <i>obj</i> as specified in 8.12.</p>
      <p>Return <i>obj</i>.</p>
      <h2>15.2.3<span>	Properties of the Object Constructo</span>r</h2>
      <p>The value of the [[Prototype]] internal property of the Object constructor is the standard built-in Function prototype object.</p>
      <p>Besides the internal properties and the <b>length</b> property (whose value is <b>1</b>), the Object constructor has the following properties:</p>
      <h2>15.2.3.1<span>	Object.prototyp</span>e</h2>
      <p>The initial value of <b>Object.prototype</b> is the standard built-in Object prototype object (15.2.4).</p>
      <p>This property has the attributes {[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</p>
      <h2>15.2.3.2<span>	Object.getPrototypeOf ( O )</span></h2>
      <p>When the <b>getPrototypeOf</b> function is called with argument <i>O</i>, the following steps are taken:</p>
      <p>If Type(<i>O</i>) is not Object throw a <b>TypeError </b>exception.</p>
      <p>Return the value of the [[Prototype]] internal property of <i>O</i>.</p>
      <h2>15.2.3.3<span>	Object.getOwnPropertyDescriptor ( O, P ) </span></h2>
      <p>When the <b>getOwnPropertyDescriptor</b> function is called, the following steps are taken:</p>
      <p>If Type(<i>O</i>) is not Object throw a <b>TypeError </b>exception.</p>
      <p>Let <i>name </i>be ToString(<i>P</i>).</p>
      <p>Let <i>desc </i>be the result of calling the [[GetOwnProperty]] internal method of <i>O </i>with argument <i>name</i>.</p>
      <p>Return the result of calling FromPropertyDescriptor(<i>desc</i>) (8.10.4). </p>
      <h2>15.2.3.4<span>	Object.getOwnPropertyNames ( O )</span></h2>
      <p>When the <b>getOwnPropertyNames</b> function is called, the following steps are taken:</p>
      <p>If Type(<i>O</i>) is not Object throw a <b>TypeError </b>exception.</p>
      <p>Let <i>array </i>be the result of creating a new object as if by the expression <b>new Array ()</b> where <b>Array</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>n</i> be 0.</p>
      <p>For each named own property <i>P </i>of <i>O</i></p>
      <p>Let <i>name </i>be the String value that is the name of <i>P</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>array</i> with arguments ToString(<i>n</i>), the PropertyDescriptor {[[Value]]: <i>name</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Increment <i>n</i> by 1.</p>
      <p>Return <i>array</i>.</p>
      <p>NOTE<span>	If </span><i>O</i> is a String instance, the set of own properties processed in step 4 includes the implicit properties defined in 15.5.5.2 that correspond to character positions within the object’s [[PrimitiveValue]] String.</p>
      <h2>15.2.3.5<span>	Object.create ( O [, Properties] )</span></h2>
      <p>The <b>create</b> function creates a new object with a specified prototype. When the <b>create</b> function is called, the following steps are taken:</p>
      <p>If Type(<i>O</i>) is not Object or Null throw a <b>TypeError </b>exception.</p>
      <p>Let <i>obj </i>be the result of creating a new object as if by the expression new Object() where Object is the standard built-in constructor with that name</p>
      <p>Set the [[Prototype]] internal property of <i>obj </i>to <i>O</i>.</p>
      <p>If the argument <i>Properties</i> is present and not <b>undefined</b>, add own properties to <i>obj </i>as if by calling the standard built-in function <b>Object.defineProperties </b>with arguments <i>obj </i>and <i>Properties</i>.</p>
      <p>Return <i>obj</i>.</p>
      <h2>15.2.3.6<span>	Object.defineProperty ( O, P, Attributes )</span></h2>
      <p>The <b>defineProperty</b> function is used to add an own property and/or update the attributes of an existing own property of an object. When the <b>defineProperty</b> function is called, the following steps are taken:</p>
      <p>If Type(<i>O</i>) is not Object throw a <b>TypeError </b>exception.</p>
      <p>Let <i>name </i>be ToString(<i>P</i>).</p>
      <p>Let <i>desc </i>be the result of calling ToPropertyDescriptor with <i>Attributes</i> as the argument.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>O </i>with arguments <i>name</i>, <i>desc</i>, and <b>true</b>.</p>
      <p>Return <i>O</i>.</p>
      <h2>15.2.3.7<span>	Object.defineProperties ( O, Properties )</span></h2>
      <p>The <b>defineProperties</b> function is used to add own properties and/or update the attributes of existing own properties of an object. When the <b>defineProperties</b> function is called, the following steps are taken:</p>
      <p>If Type(<i>O</i>) is not Object throw a <b>TypeError</b> exception.</p>
      <p>Let <i>props</i> be ToObject(<i>Properties</i>).</p>
      <p>Let <i>names</i> be an internal list containing the names of each enumerable own property of <i>props</i><i>.</i></p>
      <p>Let <i>descriptors</i> be an empty internal List.</p>
      <p>For each element <i>P</i> of <i>names</i> in list order,</p>
      <p>Let <i>descObj</i> be the result of calling the [[Get]] internal method of <i>props</i> with <i>P</i> as the argument.</p>
      <p>Let <i>desc</i> be the result of calling ToPropertyDescriptor with <i>descObj</i> as the argument.</p>
      <p>Append the pair (a two element List) consisting of <i>P</i> and <i>desc</i> to the end of <i>descriptors</i>.</p>
      <p>For  each <i>pair</i> from <i>descriptors</i> in list order,</p>
      <p>Let <i>P</i> be the first element of <i>pair</i>.</p>
      <p>Let <i>desc</i> be the second element of <i>pair</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>O</i> with arguments <i>P</i>, <i>desc</i>, and <b>true</b>.</p>
      <p>Return <i>O</i>.</p>
      <p>If an implementation defines a specific order of enumeration for the for-in statement, that same enumeration order must be used to order the list elements in step 3 of this algorithm.</p>
      <h2>15.2.3.8<span>	Object.seal ( O )</span></h2>
      <p>When the <b>seal</b> function is called, the following steps are taken:</p>
      <p>If Type(<i>O</i>) is not Object throw a <b>TypeError </b>exception.</p>
      <p>For each named own property name <i>P</i> of <i>O</i>,</p>
      <p>Let <i>desc </i>be the result of calling the [[GetOwnProperty]] internal method of <i>O </i>with <i>P</i>.</p>
      <p>If <i>desc</i>.[[Configurable]] is <b>true</b>, set <i>desc</i>.[[Configurable]] to <b>false</b>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>O </i>with <i>P</i>, <i>desc</i>, and <b>true</b> as arguments.</p>
      <p>Set the [[Extensible]] internal property of <i>O </i>to <b>false</b>.</p>
      <p>Return <i>O</i>.</p>
      <h2>15.2.3.9<span>	Object.freeze ( O )</span></h2>
      <p>When the <b>freeze</b> function is called, the following steps are taken:</p>
      <p>If Type(<i>O</i>) is not Object throw a <b>TypeError </b>exception.</p>
      <p>For each named own property name <i>P</i> of <i>O</i>,</p>
      <p>Let <i>desc </i>be the result of calling the [[GetOwnProperty]] internal method of <i>O </i>with <i>P</i>.</p>
      <p>If IsDataDescriptor(<i>desc</i>) is <b>true</b>, then</p>
      <p>If <i>desc</i>.[[Writable]] is <b>true</b>, set <i>desc</i>.[[Writable]] to <b>false</b>.</p>
      <p>If <i>desc</i>.[[Configurable]] is <b>true</b>, set <i>desc</i>.[[Configurable]] to <b>false</b>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>O </i>with <i>P</i>, <i>desc</i>, and <b>true</b> as arguments.</p>
      <p>Set the [[Extensible]] internal property of <i>O </i>to <b>false</b>.</p>
      <p>Return <i>O</i>.</p>
      <h2>15.2.3.10<span>	Object.preventExtensions ( O )</span></h2>
      <p>When the <b>preventExtensions</b> function is called, the following steps are taken:</p>
      <p>If Type(<i>O</i>) is not Object throw a <b>TypeError </b>exception.</p>
      <p>Set the [[Extensible]] internal property of <i>O </i>to <b>false</b>.</p>
      <p>Return <i>O</i>.</p>
      <h2>15.2.3.11<span>	Object.isSealed ( O )</span></h2>
      <p>When the <b>isSealed</b> function is called with argument <i>O</i>, the following steps are taken:</p>
      <p>If Type(<i>O</i>) is not Object throw a <b>TypeError </b>exception.</p>
      <p>For each named own property name <i>P</i> of <i>O</i>,</p>
      <p>Let <i>desc </i>be the result of calling the [[GetOwnProperty]] internal method of <i>O </i>with <i>P</i>.</p>
      <p>If <i>desc</i>.[[Configurable]] is <b>true</b>, then return <b>false</b>.</p>
      <p>If the [[Extensible]] internal property of <i>O </i>is <b>false</b>, then return <b>true</b>.</p>
      <p>Otherwise, return <b>false</b>.</p>
      <h2>15.2.3.12<span>	Object.isFrozen ( O )</span></h2>
      <p>When the <b>isFrozen</b> function is called with argument <i>O</i>, the following steps are taken:</p>
      <p>If Type(<i>O</i>) is not Object throw a <b>TypeError </b>exception.</p>
      <p>For each named own property name <i>P</i> of <i>O</i>,</p>
      <p>Let <i>desc </i>be the result of calling the [[GetOwnProperty]] internal method of <i>O </i>with <i>P</i>.</p>
      <p>If IsDataDescriptor(<i>desc</i>) is <b>true</b> then</p>
      <p>If <i>desc</i>.[[Writable]] is <b>true</b>, return <b>false</b>.</p>
      <p>If <i>desc</i>.[[Configurable]] is <b>true</b>, then return <b>false</b>.</p>
      <p>If the [[Extensible]] internal property of <i>O </i>is <b>false</b>, then return <b>true</b>.</p>
      <p>Otherwise, return <b>false</b>.</p>
      <h2>15.2.3.13<span>	Object.isExtensible ( O )</span></h2>
      <p>When the <b>isExtensible</b> function is called with argument <i>O</i>, the following steps are taken:</p>
      <p>If Type(<i>O</i>) is not Object throw a <b>TypeError </b>exception.</p>
      <p>Return the Boolean value of the [[Extensible]] internal property of <i>O</i>.</p>
      <h2>15.2.3.14<span>	Object.keys ( O )</span></h2>
      <p>When the <b>keys</b> function is called with argument <i>O</i>, the following steps are taken:</p>
      <p>If the Type(<i>O</i>) is not Object, throw a <b>TypeError</b> exception.</p>
      <p>Let <i>n</i> be the number of own enumerable properties of <i>O</i></p>
      <p>Let <i>array </i>be the result of creating a new Object as if by the expression <b>new Array(n) </b>where <b>Array</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>index</i> be 0.</p>
      <p>For each own enumerable property of <i>O</i> whose name String is <i>P</i> </p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>array</i> with arguments ToString(<i>index</i>), the PropertyDescriptor {[[Value]]: <i>P</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Increment <i>index</i> by 1.</p>
      <p>Return <i>array</i>.</p>
      <p>If an implementation defines a specific order of enumeration for the for-in statement, that same enumeration order must be used in step 5 of this algorithm.</p>
      <h2>15.2.4<span>	Properties of the Object Prototype Objec</span>t</h2>
      <p>The value of the [[Prototype]] internal property of the Object prototype object is <b>null</b> and the initial value of the [[Extensible]] internal property is <b>true</b>.</p>
      <h2>15.2.4.1<span>	Object.prototype.constructo</span>r</h2>
      <p>The initial value of <b>Object.prototype.constructor</b> is the standard built-in <b>Object</b> constructor.</p>
      <h2>15.2.4.2<span>	Object.prototype.toString</span> ( )</h2>
      <p>When the <b>toString</b> method is called, the following steps are taken:</p>
      <p>If the <b>this</b> value is <b>undefined</b>, return <b>"[object Undefined]"</b>.</p>
      <p>If the <b>this</b> value is <b>null</b>, return <b>"[object Null]"</b>.</p>
      <p>Let <i>O </i>be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>If <i>O</i> has a [[NativeBrand]] internal property, let <i>tag</i> be the corresponding value from the Table 23.</p>
      <p>Else if <i>O</i> is a host object, let <i>tag</i> be an implementation defined string value. This value may not be<b> </b><b>"Array"</b>, <b>"Boolean"</b>, <b>"Date"</b>, <b>"Error"</b>, <b>"Function"</b>, <b>"JSON"</b>, <b>"Math"</b>, <b>"Number"</b>, <b>"Object"</b>, <b>"RegExp"</b>, or <b>"String"</b>.</p>
      <p>Else, let <i>tag</i> be the string value <b>"Object"</b>.</p>
      <p>Return the String value that is the result of concatenating the three Strings <b>"[object "</b>, <i>tag</i>, and <b>"]"</b>.</p>
      <p>Table 23 — Tags for Classified Native Objects</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <b>[[NativeBrand]] Value</b>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">tag</span>
                <b> Value</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeFunction</p>
            </td>
            <td>
              <p>
                <b>"Function"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeArray</p>
            </td>
            <td>
              <p>
                <b>"Array"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>StringWrapper</p>
            </td>
            <td>
              <p>
                <b>"String"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>BooleanWrapper</p>
            </td>
            <td>
              <p>
                <b>"Boolean"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NumberWrapper</p>
            </td>
            <td>
              <p>
                <b>"Number"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeMath</p>
            </td>
            <td>
              <p>
                <b>"Math"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeDate</p>
            </td>
            <td>
              <p>
                <b>"Date"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeRegExp</p>
            </td>
            <td>
              <p>
                <b>"</b>
                <b>R</b>
                <b>e</b>
                <b>gExp</b>
                <b>"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeError</p>
            </td>
            <td>
              <p>
                <b>"</b>
                <b>Error</b>
                <b>"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeJSON</p>
            </td>
            <td>
              <p>
                <b>"JSON"</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>NativeArguments</p>
            </td>
            <td>
              <p>
                <b>"Arguments"</b>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <h2>15.2.4.3<span>	Object.prototype.toLocaleString ( )</span></h2>
      <p>When the <b>toLocaleString </b>method is called, the following steps are taken:</p>
      <p>Let <i>O </i>be the <b>this </b>value.</p>
      <p>Return the result of calling Invoke with arguments <b>"toString"</b><b>,</b> <i>O</i>,<i> </i>and an empty arguments List.</p>
      <p>NOTE 1<span>	This function is provided to give all Objects a generic </span><b>toLocaleString</b> interface, even though not all may use it. Currently, <b>Array</b>, <b>Number</b>, and <b>Date</b> provide their own locale-sensitive <b>toLocaleString</b> methods.</p>
      <p>NOTE 2<span>	The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.</span></p>
      <h2>15.2.4.4<span>	Object.prototype.valueOf</span> ( )</h2>
      <p>When the <b>valueOf</b> method is called, the following steps are taken: </p>
      <p>Let <i>O </i>be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>If <i>O</i> is the result of calling the Object constructor with a host object (15.2.2.1), then</p>
      <p>Return either <i>O</i> or another value such as the host object originally passed to the constructor. The specific result that is returned is implementation-defined.</p>
      <p>Return <i>O</i>.</p>
      <h2>15.2.4.5<span>	Object.prototype.hasOwnProperty (V)</span></h2>
      <p>When the <b>hasOwnProperty</b> method is called with argument <i>V</i>, the following steps are taken:</p>
      <p>Let <i>P</i> be ToString(<i>V</i>).</p>
      <p>Let <i>O</i> be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>desc</i> be the result of calling the [[GetOwnProperty]] internal method of <i>O</i> passing <i>P</i> as the argument.</p>
      <p>If <i>desc</i> is <b>undefined</b>, return <b>false</b>.</p>
      <p>Return <b>true</b>.</p>
      <p>NOTE 1<span>	Unlike [[HasProperty]] (8.12.6), this method does not consider objects in the prototype chain.</span></p>
      <p>NOTE 2<span>	The ordering of steps 1 and 2 is chosen to ensure that any exception that would have been thrown by step 1 in previous editions of this specification will continue to be thrown even if the </span><b>this</b> value is <b>undefined</b> or <b>null</b>.</p>
      <h2>15.2.4.6<span>	Object.prototype.isPrototypeOf (V)</span></h2>
      <p>When the <b>isPrototypeOf</b> method is called with argument <i>V</i>, the following steps are taken:</p>
      <p>If <i>V</i> is not an object, return <b>false</b>.</p>
      <p>Let <i>O</i> be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Repeat</p>
      <p>Let <i>V</i> be the value of the [[Prototype]] internal property of <i>V</i>.</p>
      <p>if <i>V</i> is <b>null</b>, return <b>false</b></p>
      <p>If <i>O</i> and <i>V</i> refer to the same object, return <b>true</b>.</p>
      <p>NOTE<span>	The ordering of steps 1 and 2 is chosen to preserve the behaviour specified by previous editions of this specification for the case where V is not an object and the this value is undefined or null.</span></p>
      <h2>15.2.4.7<span>	Object.prototype.propertyIsEnumerable (V)</span></h2>
      <p>When the <b>propertyIsEnumerable</b> method is called with argument <i>V</i>, the following steps are taken:</p>
      <p>Let <i>P</i> be ToString(<i>V</i>).</p>
      <p>Let <i>O</i> be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>desc</i> be the result of calling the [[GetOwnProperty]] internal method of <i>O</i> passing <i>P</i> as the argument.</p>
      <p>If <i>desc</i> is <b>undefined</b>, return <b>false</b>.</p>
      <p>Return the value of <i>desc</i>.[[Enumerable]].</p>
      <p>NOTE 1<span>	This method does not consider objects in the prototype chain.</span></p>
      <p>NOTE 2<span>	The ordering of steps 1 and 2 is chosen to ensure that any exception that would have been thrown by step 1 in previous editions of this specification will continue to be thrown even if the </span><b>this</b> value is <b>undefined</b> or <b>null</b>.</p>
      <h2>15.2.5<span>	Properties of Object Instance</span>s</h2>
      <p>Object instances have no special properties beyond those inherited from the Object prototype object.</p>
      <h2>15.3<span>	Function</span> Objects</h2>
      <h2>15.3.1<span>	The Function Constructor Called as a Functio</span>n</h2>
      <p>When <b>Function</b> is called as a function rather than as a constructor, it creates and initialises a new Function object. Thus the function call <b>Function(</b>…<b>)</b> is equivalent to the object creation expression <b>new Function(</b>…<b>)</b> with the same arguments.</p>
      <h2>15.3.1.1<span>	Function (p1, p2, </span>… , pn, body)</h2>
      <p>When the <b>Function</b> function is called with some arguments <i>p1</i>, <i>p2</i>, … , <i>pn</i>, <i>body</i> (where <i>n</i> might be 0, that is, there are no “<i>p</i>” arguments, and where <i>body</i> might also not be provided), the following steps are taken:</p>
      <p>Create and return a new Function object as if the standard built-in constructor Function was used in a <b>new </b>expression with the same arguments (15.3.2.1).</p>
      <h2>15.3.2<span>	The Function Constructo</span>r</h2>
      <p>When <b>Function</b> is called as part of a <b>new</b> expression, it is a constructor: it initialises the newly created object.</p>
      <h2>15.3.2.1<span>	new Function (p1, p2, </span>… , pn, body)</h2>
      <p>The last argument specifies the body (executable code) of a function; any preceding arguments specify formal parameters.</p>
      <p>When the <b>Function</b> constructor is called with some arguments <i>p1</i>, <i>p2</i>, … , <i>pn</i>, <i>body</i> (where <i>n</i> might be 0, that is, there are no “<i>p</i>” arguments, and where <i>body</i> might also not be provided), the following steps are taken:</p>
      <p>Let <i>argCount</i> be the total number of arguments passed to this function invocation.</p>
      <p>Let <i>P</i> be the empty String.</p>
      <p>If <i>argCount</i> = 0, let <i>body</i><i>Text</i> be the empty String.</p>
      <p>Else if <i>argCount</i> = 1, let <i>body</i><i>Text</i> be that argument.</p>
      <p>Else, <i>argCount</i> &gt; 1</p>
      <p>Let <i>firstArg</i> be the first argument.</p>
      <p>Let <i>P</i> be ToString(<i>firstArg</i>).</p>
      <p>Let <i>k</i> be 2.</p>
      <p>Repeat, while <i>k</i> &lt; <i>argCount</i></p>
      <p>Let <i>nextArg</i> be the <i>k</i>’th argument.</p>
      <p>Let <i>P</i> be the result of concatenating the previous value of <i>P</i>, the String <b>","</b> (a comma), and ToString(<i>nextArg</i>).</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Let <i>body</i><i>Text</i> be the <i>k</i>’th argument.</p>
      <p>Let <i>body</i><i>Text</i> be ToString(<i>body</i><i>Text</i>).</p>
      <p>Let <i>parameters</i> be the result of parsing <i>P</i> using <i>FormalParameterList</i> as the goal symbol. Throw a <b>SyntaxError</b> exception if the parse fails.</p>
      <p>Let <i>body</i> be the result of parsing <i>bodyText</i> using <i>FunctionBody</i> as the goal symbol. Throw a <b>SyntaxError</b> exception if the parse fails.</p>
      <p>If<i> body</i><i>Text</i><i> </i>is strict mode code (see 10.1.1) then let <i>strict</i> be <b>true</b>, else let <i>strict</i> be <b>false</b>.</p>
      <p>If <i>strict</i> is <b>true</b>, throw any exceptions specified in 13.1 that apply. </p>
      <p>Return a new Function object created as specified in 13.2 passing <i>parameters</i> as the <i>FormalParameterList</i> and <i>body</i> as the <i>FunctionBody</i>. Pass in the Global Environment as the <i>Scope</i> parameter and <i>strict</i> as the <i>Strict</i> flag.</p>
      <p>A <b>prototype</b> property is automatically created for every function, to provide for the possibility that the function will be used as a constructor.</p>
      <p>NOTE<span>	It is permissible but not necessary to have one argument for each formal parameter to be specified. For example, all three of the following expressions produce the same result:</span></p>
      <p>new Function("a", "b", "c", "return a+b+c")</p>
      <p>new Function("a, b, c", "return a+b+c")</p>
      <p>new Function("a,b", "c", "return a+b+c")</p>
      <h2>15.3.3<span>	Properties of the Function Constructo</span>r</h2>
      <p>The Function constructor is itself a Function object and has a [[NativeBrand]] internal property whose value is NativeFunction. The value of the [[Prototype]] internal property of the Function constructor is the standard built-in Function prototype object (15.3.4).</p>
      <p>The value of the [[Extensible]] internal property of the Function constructor is <b>true</b>.</p>
      <p>The Function constructor has the following properties:</p>
      <h2>15.3.3.1<span>	Function.prototyp</span>e</h2>
      <p>The initial value of <b>Function.prototype</b> is the standard built-in Function prototype object (15.3.4).</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.3.3.2<span>	Function.length</span></h2>
      <p>This is a data property with a value of 1. This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.3.4<span>	Properties of the Function Prototype Objec</span>t</h2>
      <p>The Function prototype object is itself a Function object and has a [[NativeBrand]] internal property whose value is NativeFunction . When invoked, it accepts any arguments and returns <b>undefined</b>.</p>
      <p>The value of the [[Prototype]] internal property of the Function prototype object is the standard built-in Object prototype object (15.2.4). The initial value of the [[Extensible]] internal property of the Function prototype object is <b>true</b>.</p>
      <p>The Function prototype object does not have a <b>valueOf</b> property of its own; however, it inherits the <b>valueOf</b> property from the Object prototype Object.</p>
      <p>The <b>length</b> property of the Function prototype object is <b>0</b>.</p>
      <h2>15.3.4.1<span>	Function.prototype.constructo</span>r</h2>
      <p>The initial value of <b>Function.prototype.constructor</b> is the built-in <b>Function</b> constructor.</p>
      <h2>15.3.4.2<span>	Function.prototype.toString</span> ( )</h2>
      <p>An implementation-dependent representation of the function is returned. This representation has the syntax of a <i>FunctionDeclaration</i>. Note in particular that the use and placement of white space, line terminators, and semicolons within the representation String is implementation-dependent.</p>
      <p>The <b>toString</b> function is not generic; it throws a <b>TypeError</b> exception if its <b>this</b> value is not a Function object. Therefore, it cannot be transferred to other kinds of objects for use as a method.</p>
      <h2>15.3.4.3<span>	Function.prototype.apply (thisArg, argArray)</span></h2>
      <p>When the <b>apply</b> method is called on an object <i>func</i> with arguments <i>thisArg</i> and <i>argArray</i>, the following steps are taken: </p>
      <p>If IsCallable(<i>func</i>) is <b>false</b>, then throw a <b>TypeError</b> exception.</p>
      <p>If <i>argArray</i> is <b>null</b> or <b>undefined</b>, then</p>
      <p>Return the result of calling the [[Call]] internal method of <i>func</i>, providing <i>thisArg</i> as the <b>this</b> value and an empty list of arguments.</p>
      <p>If Type(<i>argArray</i>) is not Object, then throw a <b>TypeError</b> exception.</p>
      <p>Let <i>len</i> be the result of calling the [[Get]] internal method of <i>argArray</i> with argument <b>"length"</b>.</p>
      <p>Let <i>n</i> be ToUint32(<i>len</i>).</p>
      <p>Let <i>argList</i>  be an empty List.</p>
      <p>Let <i>index</i> be 0.</p>
      <p>Repeat while <i>index</i> &lt; <i>n</i></p>
      <p>Let <i>indexName</i> be ToString(<i>index</i>).</p>
      <p>Let <i>nextArg</i> be the result of calling the [[Get]] internal method of <i>argArray</i> with <i>indexName</i> as the argument.</p>
      <p>Append <i>nextArg</i> as the last element of <i>argList</i>.</p>
      <p>Set <i>index</i> to <i>index</i> + 1.</p>
      <p>Return the result of calling the [[Call]] internal method of <i>func</i>, providing <i>thisArg</i> as the <b>this</b> value and <i>argList</i> as the list of arguments.</p>
      <p>The <b>length</b> property of the <b>apply</b> method is <b>2</b>.</p>
      <p>NOTE<span>	The thisArg value is passed without modification as the </span><b>this</b> value. This is a change from Edition 3, where a <b>undefined</b> or <b>null</b> thisArg is replaced with the global object and ToObject is applied to all other values and that result is passed as the <b>this</b> value.</p>
      <h2>15.3.4.4<span>	Function.prototype.call (thisArg [ , arg1 [ , arg2, … ] ] )</span></h2>
      <p>When the <b>call</b> method is called on an object <i>func</i> with argument <i>thisArg</i> and optional arguments <i>arg1</i>, <i>arg2</i> etc, the following steps are taken:</p>
      <p> If IsCallable(<i>func</i>) is <b>false</b>, then throw a <b>TypeError</b> exception.</p>
      <p>Let <i>argList</i> be an empty List.</p>
      <p>If this method was called with more than one argument then in left to right order starting with <i>arg1</i> append each argument as the last element of <i>argList</i></p>
      <p>Return the result of calling the [[Call]] internal method of <i>func</i>, providing <i>thisArg</i> as the <b>this</b> value and <i>argList</i> as the list of arguments.</p>
      <p>The <b>length</b> property of the <b>call</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The thisArg value is passed without modification as the </span><b>this</b> value. This is a change from Edition 3, where a <b>undefined</b> or <b>null</b> thisArg is replaced with the global object and ToObject is applied to all other values and that result is passed as the <b>this</b> value.</p>
      <h2>15.3.4.5<span>	Function.prototype.bind (thisArg [, arg1 [, arg2, …]])</span></h2>
      <p>The bind method takes one or more arguments, <i>thisArg</i> and (optionally) <i>arg1</i>, <i>arg2</i>, etc, and returns a new function object by performing the following steps:</p>
      <p>Let <i>Target </i>be the <b>this </b>value.</p>
      <p>If IsCallable(<i>Target</i>) is <b>false</b>, throw a <b>TypeError </b>exception.</p>
      <p>Let <i>A </i>be a new (possibly empty) internal list of all of the argument values provided after <i>thisArg </i>(<i>arg1</i>, <i>arg2</i> etc), in order.</p>
      <p>Let <i>F</i> be a new native ECMAScript object .</p>
      <p>Set all the internal methods, except for [[Get]], of <i>F</i> as specified in 8.12.</p>
      <p>Set the [[Get]] internal property of <i>F </i>as specified in 15.3.5.4.</p>
      <p>Set the [[TargetFunction]] internal property of <i>F </i>to <i>Target</i>.</p>
      <p>Set the [[BoundThis]] internal property of <i>F</i> to the value of <i>thisArg</i>.</p>
      <p>Set the [[BoundArgs]] internal property of <i>F </i>to <i>A</i>.</p>
      <p>Add the [[NativeBrand]] internal property with value NativeFunction to <i>F</i>.</p>
      <p>Set the [[Prototype]] internal property of <i>F </i>to the standard built-in Function prototype object as specified in 15.3.3.1.</p>
      <p>Set the [[Call]] internal property of <i>F </i>as described in 15.3.4.5.1.</p>
      <p>Set the [[Construct]] internal property of <i>F </i>as described in 15.3.4.5.2.</p>
      <p>Set the [[HasInstance]] internal property of <i>F </i>as described in 15.3.4.5.3.</p>
      <p>If <i>Target </i>has the [[NativeBrand]] internal property with value NativeFunction, then</p>
      <p>Let <i>targetLen</i> be the result of calling the [[Get]] internal method of <i>Target</i> with argument <b>"</b><b>length</b><b>"</b>.</p>
      <p>Let <i>L </i>be the larger of 0 and the result of <i>targetLen</i><i> </i>minus the number of element of <i>A</i>.</p>
      <p>Else let<i> </i><i>L</i> be 0.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>F</i> with arguments <b>"</b><b>length</b><b>"</b>, PropertyDescriptor {[[value]]: <i>L</i>, [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b>}, and <b>false</b>.</p>
      <p>Set the [[Extensible]] internal property of <i>F</i> to <b>true</b>.</p>
      <p>Let <i>thrower</i> be the [[ThrowTypeError]] function Object (13.2.3).</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>F</i> with arguments <b>"caller"</b>, PropertyDescriptor {[[Get]]: <i>thrower</i>, [[Set]]: <i>thrower</i>, [[Enumerable]]: <b>false</b>, [[Configurable]]:<b> false</b>}, and <b>false</b>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>F</i> with arguments <b>"arguments"</b>, PropertyDescriptor {[[Get]]: <i>thrower</i>, [[Set]]: <i>thrower</i>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b>}, and <b>false</b>.</p>
      <p>Return <i>F</i>.</p>
      <p>The <b>length</b> property of the <b>bind</b> method is <b>1</b>.</p>
      <p>NOTE<span>	Function objects created using </span><b>Function.prototype.bind</b> do not have a <b>prototype</b> property or the [[Code]], [[FormalParameters]], and [[Scope]] internal properties.</p>
      <p>15.3.4.5.1<span>	[[Call]]</span></p>
      <p>When the [[Call]] internal method of a function object, <i>F</i>, which was created using the bind function is called with a <b>this</b> value and a list of arguments <i>ExtraArgs</i>, the following steps are taken:</p>
      <p>Let <i>boundArgs</i> be the value of <i>F’s</i> [[BoundArgs]] internal property.</p>
      <p>Let <i>boundThis</i> be the value of <i>F’s</i> [[BoundThis]] internal property.</p>
      <p>Let <i>target</i> be the value of <i>F’s</i> [[TargetFunction]] internal property.</p>
      <p>Let <i>args</i> be a new list containing the same values as the list <i>boundArgs</i> in the same order followed by the same values as the list <i>ExtraArgs</i> in the same order.</p>
      <p>Return the result of  calling the [[Call]] internal method of <i>target</i> providing <i>boundThis</i> as the <b>this </b>value and providing <i>args</i> as the arguments.</p>
      <p>15.3.4.5.2<span>	[[Construct]]</span></p>
      <p>When the [[Construct]] internal method of a function object, <i>F</i> that was created using the bind function is called with a list of arguments <i>ExtraArgs</i>, the following steps are taken:</p>
      <p>Let <i>target</i> be the value of <i>F’s</i> [[TargetFunction]] internal property.</p>
      <p>If <i>target</i> has no [[Construct]] internal method, a <b>TypeError</b> exception is thrown.</p>
      <p>Let <i>boundArgs</i> be the value of <i>F’s</i> [[BoundArgs]] internal property.</p>
      <p>Let <i>args</i> be a new list containing the same values as the list <i>boundArgs</i> in the same order followed by the same values as the list <i>ExtraArgs</i> in the same order.</p>
      <p>Return the result of calling the [[Construct]] internal method of<i> target</i> providing <i>args</i> as the arguments.</p>
      <p>15.3.4.5.3<span>	[[HasInstance]] (V)</span></p>
      <p>When the [[HasInstance]] internal method of a function object <i>F</i>, that was created using the bind function is called with argument <i>V</i>, the following steps are taken:</p>
      <p>Let <i>target</i> be the value of <i>F’s</i> [[TargetFunction]] internal property.</p>
      <p>If <i>target</i> has no [[HasInstance]] internal method, a <b>TypeError</b> exception is thrown.</p>
      <p>Return the result of calling the [[HasInstance]] internal method of<i> target</i> providing <i>V</i> as the argument.</p>
      <h2>15.3.5<span>	Properties of Function Instance</span>s</h2>
      <p>In addition to the required internal properties, every function instance has a [[Call]] internal property and in most cases uses a different version of the [[Get]] internal property. Depending on how they are created (see 8.6.2, 13.2, 15, and 15.3.4.5), function instances may have a [[HasInstance]] internal property, a [[Scope]] internal property, a [[Construct]] internal property, a [[FormalParameters]] internal property, a [[Code]] internal property, a [[TargetFunction]] internal property, a [[BoundThis]] internal property, and a [[BoundArgs]] internal property.</p>
      <p>Every function instance has a [[NativeBrand]] internal property whose value is NativeFunction.</p>
      <p>Function instances that correspond to strict mode functions (13.2) and function instances created using the <b>Function.prototype.bind method</b> (15.3.4.5) have properties named “caller” and “arguments” that throw a <b>TypeError</b> exception. An ECMAScript implementation must not associate any implementation specific behaviour with accesses of these properties from strict mode function code. </p>
      <h2>15.3.5.1<span>	lengt</span>h</h2>
      <p>The value of the <b>length</b> property is an integer that indicates the “typical” number of arguments expected by the function. However, the language permits the function to be invoked with some other number of arguments. The behaviour of a function when invoked on a number of arguments other than the number specified by its <b>length</b> property depends on the function. This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.3.5.2<span>	prototyp</span>e</h2>
      <p>The value of the <b>prototype</b> property is used to initialise the [[Prototype]] internal property of a newly created object before the Function object is invoked as a constructor for that newly created object. This property has the attribute { [[Writable]]: <b>true</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <p>NOTE<span>	Function objects created using </span><b>Function.prototype.bind</b> do not have a <b>prototype</b> property.</p>
      <h2>15.3.5.3<span>	[[HasInstance]] (V)</span></h2>
      <p>Assume <i>F</i> is a Function object.</p>
      <p>When the [[HasInstance]] internal method of <i>F</i> is called with value <i>V</i>, the following steps are taken:</p>
      <p>If <i>V</i> is not an object, return <b>false</b>.</p>
      <p>Let <i>O</i> be the result of calling the [[Get]] internal method of <i>F</i> with property name <b>"prototype"</b>.</p>
      <p>If Type(<i>O</i>) is not Object, throw a <b>TypeError</b> exception.</p>
      <p>Repeat</p>
      <p>Let <i>V</i> be the value of the [[Prototype]] internal property of <i>V</i>.</p>
      <p>If <i>V</i> is <b>null</b>, return <b>false</b>.</p>
      <p>If <i>O</i> and <i>V</i> refer to the same object, return <b>true</b>.</p>
      <p>NOTE<span>	Function objects created using </span><b>Function.prototype.bind</b> have a different implementation of [[HasInstance]] defined in 15.3.4.5.3.</p>
      <h2>15.3.5.4<span>	[[Get]] (P)</span></h2>
      <p>Function objects use a variation of the [[Get]] internal method used for other native ECMAScript objects (8.12.3).</p>
      <p>Assume <i>F</i> is a Function object. When the [[Get]] internal method of <i>F</i> is called with property name <i>P</i>, the following steps are taken:</p>
      <p>Let <i>v</i> be the result of calling the default [[Get]] internal method (8.12.3) on <i>F</i> passing <i>P</i> as the property name argument.</p>
      <p>If <i>P</i> is <b>"caller" </b>and <i>v</i> is a strict mode Function object, throw a <b>TypeError</b> exception. </p>
      <p>Return <i>v</i>.</p>
      <p>NOTE<span>	Function objects created using </span><b>Function.prototype.bind</b> use the default [[Get]] internal method.</p>
      <h2>15.4<span>	Array Object</span>s</h2>
      <p>Array objects give special treatment to a certain class of property names. A property name <i>P</i> (in the form of a String value) is an <i>array index</i> if and only if ToString(ToUint32(<i>P</i>)) is equal to <i>P</i> and ToUint32(<i>P</i>) is not equal to 2<sup>32</sup>−1. A property whose property name is an array index is also called an <i>element</i>. Every Array object has a <b>length</b> property whose value is always a nonnegative integer less than 2<sup>32</sup>. The value of the <b>length</b> property is numerically greater than the name of every property whose name is an array index; whenever a property of an Array object is created or changed, other properties are adjusted as necessary to maintain this invariant. Specifically, whenever a property is added whose name is an array index, the <b>length</b> property is changed, if necessary, to be one more than the numeric value of that array index; and whenever the <b>length</b> property is changed, every property whose name is an array index whose value is not smaller than the new length is automatically deleted. This constraint applies only to own properties of an Array object and is unaffected by <b>length</b> or array index properties that may be inherited from its prototypes.</p>
      <p>An object, <i>O</i>,  is said to be <i>sparse</i> if the following algorithm returns <b>true</b>:</p>
      <p>Let <i>len</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <b>"length"</b>.</p>
      <p>For each integer <i>i</i> in the range 0≤<i>i</i>&lt;ToUint32(<i>len</i>)</p>
      <p>Let <i>elem</i> be the result of calling the [[GetOwnProperty]] internal method of <i>O</i> with argument ToString(<i>i</i>).</p>
      <p>If <i>elem</i> is <b>undefined</b>, return <b>true</b>.</p>
      <p>Return <b>false</b>.</p>
      <h2>15.4.1<span>	The Array Constructor Called as a Functio</span>n</h2>
      <p>When <b>Array</b> is called as a function rather than as a constructor, it creates and initialises a new Array object. Thus the function call <b>Array(</b>…<b>)</b> is equivalent to the object creation expression <b>new Array(</b>…<b>)</b> with the same arguments.</p>
      <h2>15.4.1.1<span>	Array ( [ item1 [ , item2 [ , </span>… ] ] ] )</h2>
      <p>When the <b>Array</b> function is called the following steps are taken:</p>
      <p>Create and return a new Array object exactly as if the standard built-in constructor <b>Array</b> was used in a <b>new</b> expression with the same arguments (15.4.2).</p>
      <h2>15.4.2<span>	The Array Constructo</span>r</h2>
      <p>When <b>Array</b> is called as part of a <b>new</b> expression, it is a constructor: it initialises the newly created object.</p>
      <h2>15.4.2.1<span>	new Array ( [ item0 [ , item1 [ , </span>… ] ] ] )</h2>
      <p>This description applies if and only if the Array constructor is given no arguments or at least two arguments.</p>
      <p>The [[Prototype]] internal property of the newly constructed object is set to the original Array prototype object, the one that is the initial value of <b>Array.prototype</b> (15.4.3.1).</p>
      <p>The newly constructed object has the [[NativeBrand]] internal property with value NativeArray.</p>
      <p>The [[Extensible]] internal property of the newly constructed object is set to <b>true</b>.</p>
      <p>The <b>length</b> property of the newly constructed object is set to the number of arguments.</p>
      <p>The <b>0</b> property of the newly constructed object is set to <i>item0</i> (if supplied); the <b>1</b> property of the newly constructed object is set to <i>item1</i> (if supplied); and, in general, for as many arguments as there are, the <i>k</i> property of the newly constructed object is set to argument <i>k</i>, where the first argument is considered to be argument number <b>0</b>. These properties all have the attributes {[[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}.</p>
      <h2>15.4.2.2<span>	new Array (len</span>)</h2>
      <p>The [[Prototype]] internal property of the newly constructed object is set to the original Array prototype object, the one that is the initial value of <b>Array.prototype</b> (15.4.3.1). The newly constructed object has the [[NativeBrand]] internal property with value NativeArray. The [[Extensible]] internal property of the newly constructed object is set to <b>true</b>.</p>
      <p>If the argument <i>len</i> is a Number and ToUint32(<i>len</i>) is equal to <i>len</i>, then the <b>length</b> property of the newly constructed object is set to ToUint32(<i>len</i>). If the argument <i>len</i> is a Number and ToUint32(<i>len</i>) is not equal to <i>len</i>, a <b>RangeError</b> exception is thrown.</p>
      <p>If the argument <i>len</i> is not a Number, then the <b>length</b> property of the newly constructed object is set to <b>1</b> and the <b>0</b> property of the newly constructed object is set to <i>len</i> with attributes {[[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}.</p>
      <h2>15.4.3<span>	Properties of the Array Constructo</span>r</h2>
      <p>The value of the [[Prototype]] internal property of the Array constructor is the Function prototype object (15.3.4).</p>
      <p>Besides the internal properties and the <b>length</b> property (whose value is <b>1</b>), the Array constructor has the following properties:</p>
      <h2>15.4.3.1<span>	Array.prototyp</span>e</h2>
      <p>The initial value of <b>Array.prototype</b> is the Array prototype object (15.4.4).</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.4.3.2<span>	Array.isArray ( arg )</span></h2>
      <p>The isArray function takes one argument <i>arg</i>, and returns the Boolean value <b>true </b>if the argument is an object whose class internal property is <b>"Array"</b>; otherwise it returns <b>false</b>. The following steps are taken:</p>
      <p>If Type(<i>arg</i>) is not Object, return <b>false</b>.</p>
      <p>If <i>arg </i>has the [[NativeBrand]] internal property with value NativeArray, then return <b>true</b>.</p>
      <p>Return <b>false</b>.</p>
      <h2>15.4.4<span>	Properties of the Array Prototype Objec</span>t</h2>
      <p>The value of the [[Prototype]] internal property of the Array prototype object is the standard built-in Object prototype object (15.2.4).</p>
      <p>The Array prototype object is itself an array; it has an [[NativeBrand]] internal property with value NativeArray, and it has a <b>length</b> property (whose initial value is <b>+0</b>) and the special [[DefineOwnProperty]] internal method described in 15.4.5.1.</p>
      <p>In following descriptions of functions that are properties of the Array prototype object, the phrase “this object” refers to the object that is the <b>this</b> value for the invocation of the function. It is permitted for the <b>this</b> to be an object which does not have an [[NativeBrand]] internal property with value NativeArray.</p>
      <p>NOTE<span>	The Array prototype object does not have a </span><b>valueOf</b> property of its own; however, it inherits the <b>valueOf</b> property from the standard built-in Object prototype Object.</p>
      <h2>15.4.4.1<span>	Array.prototype.constructo</span>r</h2>
      <p>The initial value of <b>Array.prototype.constructor</b> is the standard built-in <b>Array</b> constructor.</p>
      <h2>15.4.4.2<span>	Array.prototype.toString</span> ( )</h2>
      <p>When the <b>toString</b> method is called, the following steps are taken:</p>
      <p>Let <i>array</i> be the result of calling ToObject on the <b>this</b> value.</p>
      <p>If <i>array</i> is an abrupt completion, return <i>array</i>.</p>
      <p>Let <i>func</i> be the result of calling the [[Get]] internal method of <i>array</i> with argument <b>"join"</b>.</p>
      <p>If <i>func</i> is an abrupt completion, return <i>func</i>.</p>
      <p>If IsCallable(<i>func</i>) is <b>false</b>, then let <i>func</i> be the standard built-in method Object.prototype.toString (15.2.4.2).</p>
      <p>Return  the result of calling the [[Call]] internal method of <i>func</i> providing <i>array</i> as the <b>this</b> value and an empty arguments list.</p>
      <p>NOTE<span>	The </span><b>toString</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>toString</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.3<span>	Array.prototype.toLocaleString ( )</span></h2>
      <p>The elements of the array are converted to Strings using their <b>toLocaleString</b> methods, and these Strings are then concatenated, separated by occurrences of a separator String that has been derived in an implementation-defined locale-specific way. The result of calling this function is intended to be analogous to the result of <b>toString</b>, except that the result of this function is intended to be locale-specific.</p>
      <p>The result is calculated as follows:</p>
      <p>Let <i>array </i>be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>arrayLen</i> be the result of calling the [[Get]] internal method of <i>array</i> with argument <b>"length"</b>.</p>
      <p>Let <i>len</i> be ToUint32(<i>arrayLen</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>Let <i>separator</i> be the String value for the list-separator String appropriate for the host environment’s current locale (this is derived in an implementation-defined way).</p>
      <p>If <i>len</i> is zero, return the empty String.</p>
      <p>Let <i>firstElement</i> be the result of calling the [[Get]] internal method of <i>array</i> with argument <b>"0"</b>.</p>
      <p>If <i>firstElement</i> is <b>undefined</b> or <b>null</b>, then</p>
      <p>Let <i>R</i> be the empty String.</p>
      <p>Else </p>
      <p>Let <i>R</i> be the result of calling Invoke with arguments <b>"to</b><b>Locale</b><b>String"</b><b>,</b> <i>firstElement</i>,<i> </i>and an empty arguments List.</p>
      <p>If <i>R</i> is an abrupt completion, return <i>R</i>.</p>
      <p>Let <i>k</i> be <b>1</b>.</p>
      <p>Repeat, while <i>k</i> &lt; <i>len</i></p>
      <p>Let <i>S</i> be a String value produced by concatenating <i>R</i> and <i>separator</i>.</p>
      <p>Let <i>nextElement</i> be the result of calling the [[Get]] internal method of <i>array</i> with argument ToString(<i>k</i>).</p>
      <p>If <i>nextElement</i> is <b>undefined</b> or <b>null</b>, then</p>
      <p>Let <i>R</i> be the empty String.</p>
      <p>Else </p>
      <p>Let <i>R</i> be the result of calling Invoke with arguments <b>"to</b><b>Locale</b><b>String"</b><b>,</b> <i>nextElement</i>,<i> </i>and an empty arguments List.</p>
      <p>If <i>R</i> is an abrupt completion, return <i>R</i>.</p>
      <p>Let <i>R</i> be a String value produced by concatenating <i>S</i> and <i>R</i>.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Return <i>R</i>.</p>
      <p>NOTE 1<span>	The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.</span></p>
      <p>NOTE 2<span>	The </span><b>toLocaleString</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>toLocaleString</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.4<span>	Array.prototype.concat </span>( [ item1 [ , item2 [ , … ] ] ] )</h2>
      <p>When the <b>concat</b> method is called with zero or more arguments <i>item1</i>, <i>item2</i>, etc., it returns an array containing the array elements of the object followed by the array elements of each argument in order.</p>
      <p>The following steps are taken:</p>
      <p>Let <i>O </i>be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>A</i> be a new array created as if by the expression <b>new Array()</b> where <b>Array</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>n</i> be 0.</p>
      <p>Let <i>items</i> be an internal List whose first element is <i>O</i> and whose subsequent elements are, in left to right order, the arguments that were passed to this function invocation.</p>
      <p>Repeat, while <i>items</i> is not empty</p>
      <p>Remove the first element from <i>items</i> and let <i>E</i> be the value of the element.</p>
      <p>If <i>E</i> has the [[NativeBrand]] internal property with value NativeArray, then</p>
      <p>Let <i>k</i> be 0.</p>
      <p>Let <i>len</i> be the result of calling the [[Get]] internal method of <i>E</i> with argument <b>"length"</b>.</p>
      <p>Repeat, while <i>k</i> &lt; <i>len</i></p>
      <p>Let <i>P</i> be ToString(<i>k</i>).</p>
      <p>Let <i>exists</i> be the result of calling the [[HasProperty]] internal method of <i>E</i> with <i>P</i>.</p>
      <p>If <i>exists</i> is <b>true</b>, then</p>
      <p>Let <i>subElement</i> be the result of calling the [[Get]] internal method of <i>E</i> with argument <i>P</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments ToString(<i>n</i>), Property Descriptor {[[Value]]: <i>subElement</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Increase <i>n</i> by 1.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Else, <i>E</i> is not an Array</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments ToString(<i>n</i>), Property Descriptor {[[Value]]: <i>E</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Increase <i>n</i> by 1.</p>
      <p>Let <i>putStatus</i> be the result of calling the [[Put]] internal method of <i>A</i> with arguments "<b>length</b>", <i>n</i>, and <b>true</b>.</p>
      <p>If <i>putStatus</i> is an abrupt completion, return <i>putStatus</i>.</p>
      <p>Return <i>A</i>.</p>
      <p>The <b>length</b> property of the <b>concat</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>concat</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>concat</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.5<span>	Array.prototype.joi</span>n (separator)</h2>
      <p>The elements of the array are converted to Strings, and these Strings are then concatenated, separated by occurrences of the <i>separator</i>. If no separator is provided, a single comma is used as the separator.</p>
      <p>The <b>join</b> method takes one argument, <i>separator</i>, and performs the following steps:</p>
      <p>Let <i>O </i>be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenVal</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <b>"length"</b>.</p>
      <p>Let <i>len</i> be ToUint32(<i>lenVal</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>If <i>separator</i> is <b>undefined</b>, let <i>separator</i> be the single-character String <b>","</b>.</p>
      <p>Let <i>sep</i> be ToString(<i>separator</i>).</p>
      <p>If <i>len</i> is zero, return the empty String.</p>
      <p>Let <i>element0</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <b>"0"</b>.</p>
      <p>If <i>element0</i> is <b>undefined</b> or <b>null</b>, let <i>R</i> be the empty String; otherwise, Let <i>R</i> be ToString(<i>element0</i>).</p>
      <p>If <i>R</i> is an abrupt completion, return <i>R</i>.</p>
      <p>Let <i>k</i> be <b>1</b>.</p>
      <p>Repeat, while <i>k</i> &lt; <i>len</i></p>
      <p>Let <i>S</i> be the String value produced by concatenating <i>R</i> and <i>sep</i>.</p>
      <p>Let <i>element</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument ToString(<i>k</i>).</p>
      <p>If <i>element</i> is <b>undefined</b> or <b>null</b>, Let <i>next</i> be the empty String; otherwise, let <i>next</i> be ToString(<i>element</i>).</p>
      <p>If <i>next</i> is an abrupt completion, return <i>next</i>.</p>
      <p>Let <i>R</i> be a String value produced by concatenating <i>S</i> and <i>next</i>.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Return <i>R</i>.</p>
      <p>The <b>length</b> property of the <b>join</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>join</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method. Whether the <b>join</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.6<span>	Array.prototype.pop ( )</span></h2>
      <p>The last element of the array is removed from the array and returned.</p>
      <p>Let <i>O </i>be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenVal</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument "<b>length</b>".</p>
      <p>Let <i>len</i> be ToUint32(<i>lenVal</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>If <i>len</i> is zero, </p>
      <p>Let <i>putStatus</i> be the result of calling the [[Put]] internal method of <i>O</i> with arguments "<b>length</b>", 0, and <b>true</b>.</p>
      <p>If <i>putStatus</i> is an abrupt completion, return <i>putStatus</i>.</p>
      <p>Return <b>undefined</b>.</p>
      <p>Else, <i>len</i> &gt; 0</p>
      <p>Let <i>newLen</i> be <i>len</i>–1.</p>
      <p>Let <i>indx</i> be ToString(<i>newLen</i>).</p>
      <p>Let <i>element</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>indx</i>.</p>
      <p>If <i>element</i> is an abrupt completion, return <i>element</i>.</p>
      <p>Let <i>delete</i><i>Status</i> be the result of calling the [[Delete]] internal method of <i>O</i> with arguments <i>indx</i> and <b>true</b>.</p>
      <p>If <i>delete</i><i>Status</i> is an abrupt completion, return <i>delete</i><i>Status</i>.</p>
      <p>Let <i>putStatus</i> be the result of calling the [[Put]] internal method of <i>O</i> with arguments "<b>length</b>", <i>newLen</i>, and <b>true</b>.</p>
      <p>If <i>putStatus</i> is an abrupt completion, return <i>putStatus</i>.</p>
      <p>Return <i>element</i>.</p>
      <p>NOTE<span>	The </span><b>pop</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>pop</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.7<span>	Array.prototype.push ( [ item1 [ , item2 [ , … ] ] ] )</span></h2>
      <p>The arguments are appended to the end of the array, in the order in which they appear. The new length of the array is returned as the result of the call.</p>
      <p>When the <b>push</b> method is called with zero or more arguments <i>item1</i>,<i> item2</i>, etc., the following steps are taken:</p>
      <p>Let <i>O </i>be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenVal</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument "<b>length</b>".</p>
      <p>Let <i>n</i> be ToUint32(<i>lenVal</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>Let <i>items</i> be an internal List whose elements are, in left to right order, the arguments that were passed to this function invocation.</p>
      <p>Repeat, while <i>items</i> is not empty</p>
      <p>Remove the first element from <i>items</i> and let <i>E</i> be the value of the element.</p>
      <p>Let <i>putStatus</i> be the result of calling the [[Put]] internal method of <i>O</i> with arguments ToString(<i>n</i>), <i>E</i>, and <b>true</b>.</p>
      <p>If <i>putStatus</i> is an abrupt completion, return <i>putStatus</i>.</p>
      <p>Increase <i>n</i> by 1.</p>
      <p>Let <i>putStatus</i> be the result of calling the [[Put]] internal method of <i>O</i> with arguments "<b>length</b>", <i>n</i>, and <b>true</b>.</p>
      <p>If <i>putStatus</i> is an abrupt completion, return <i>putStatus</i>.</p>
      <p>Return <i>n</i>.</p>
      <p>The <b>length</b> property of the <b>push</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>push</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>push</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.8<span>	Array.prototype.revers</span>e ( )</h2>
      <p>The elements of the array are rearranged so as to reverse their order. The object is returned as the result of the call.</p>
      <p>Let <i>O </i>be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenVal</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <b>"length"</b>.</p>
      <p>Let <i>len</i> be ToUint32(<i>lenVal</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>Let <i>middle</i> be  floor(<i>len</i>/2).</p>
      <p>Let<i> lower</i> be <b>0</b>.</p>
      <p>Repeat, while <i>lower</i> ≠ <i>middle</i></p>
      <p>Let <i>upper</i> be <i>len</i>−<i> </i><i>lower</i> −1.</p>
      <p>Let <i>upperP</i> be ToString(<i>upper</i>).</p>
      <p>Let <i>lowerP</i> be ToString(<i>lower</i>).</p>
      <p>Let <i>lowerValue</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i> lowerP</i>.</p>
      <p>If <i>lowerValue</i> is an abrupt completion, return <i>lowerValue</i>.</p>
      <p>Let <i>upperValue</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>upperP</i> .</p>
      <p>If <i>upperValue</i> is an abrupt completion, return <i>upperValue</i>.</p>
      <p>Let <i>lowerExists</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>lowerP</i>.</p>
      <p>Let <i>upperExists</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>upperP</i>.</p>
      <p>If <i>lowerExists</i> is <b>true</b> and <i>upperExists</i> is <b>true</b>, then</p>
      <p>Let <i>putStatus</i> be the result of calling the [[Put]] internal method of <i>O</i> with arguments <i>lowerP</i>, <i>upperValue</i>, and <b>true</b> .</p>
      <p>If <i>putStatus</i> is an abrupt completion, return <i>putStatus</i>.</p>
      <p>Let <i>putStatus</i> be the result of calling the [[Put]] internal method of <i>O</i> with arguments <i>upperP</i>, <i>lowerValue</i>, and <b>true</b> .</p>
      <p>If <i>putStatus</i> is an abrupt completion, return <i>putStatus</i>.</p>
      <p>Else if <i>lowerExists</i> is <b>false</b> and <i>upperExists</i> is <b>true</b>, then</p>
      <p>Let <i>putStatus</i> be the result of calling the [[Put]] internal method of <i>O</i> with arguments <i>lowerP</i>, <i>upperValue</i>, and <b>true</b> .</p>
      <p>If <i>putStatus</i> is an abrupt completion, return <i>putStatus</i>.</p>
      <p>Let <i>delete</i><i>Status</i> be the result of calling the [[Delete]] internal method of <i>O</i>, with arguments <i>upperP</i> and <b>true</b>.</p>
      <p>If <i>delete</i><i>Status</i> is an abrupt completion, return <i>delete</i><i>Status</i>.</p>
      <p>Else if <i>lowerExists</i> is <b>true</b> and <i>upperExists</i> is <b>false</b>, then</p>
      <p>Let <i>delete</i><i>Status</i> be the result of calling the [[Delete]] internal method of <i>O</i>, with arguments <i>lowerP</i> and <b>true</b> .</p>
      <p>If <i>delete</i><i>Status</i> is an abrupt completion, return <i>delete</i><i>Status</i>.</p>
      <p>Let <i>putStatus</i> be the result of calling the [[Put]] internal method of <i>O</i> with arguments <i>upperP</i>, <i>lowerValue</i>, and <b>true</b> .</p>
      <p>If <i>putStatus</i> is an abrupt completion, return <i>putStatus</i>.</p>
      <p>Else, both <i>lowerExists</i> and <i>upperExists</i> are <b>false</b></p>
      <p>No action is required.</p>
      <p>Increase <i>lower</i> by 1.</p>
      <p>Return <i>O</i> .</p>
      <p>NOTE<span>	The </span><b>reverse</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method. Whether the <b>reverse</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.9<span>	Array.prototype.shift ( )</span></h2>
      <p>The first element of the array is removed from the array and returned.</p>
      <p>Let <i>O </i>be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenVal</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument "<b>length</b>".</p>
      <p>Let <i>len</i> be ToUint32(<i>lenVal</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>If <i>len</i> is zero, then</p>
      <p>Let <i>putStatus</i> be the result of calling the [[Put]] internal method of <i>O</i> with arguments "<b>length</b>", 0, and <b>true</b>.</p>
      <p>If <i>putStatus</i> is an abrupt completion, return <i>putStatus</i>.</p>
      <p>Return <b>undefined</b>.</p>
      <p>Let <i>first</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument "<b>0</b>".</p>
      <p>If <i>first</i> is an abrupt completion, return <i>first</i>.</p>
      <p>Let <i>k</i> be 1.</p>
      <p>Repeat, while <i>k</i> &lt; <i>len</i></p>
      <p>Let <i>from</i> be ToString(<i>k</i>).</p>
      <p>Let <i>to</i> be ToString(<i>k</i>–1).</p>
      <p>Let <i>fromPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>from</i>.</p>
      <p>If <i>fromPresent</i> is <b>true</b>, then</p>
      <p>Let <i>fromVal</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>from</i>.</p>
      <p>If <i>fromVal</i> is an abrupt completion, return <i>fromVal</i>.</p>
      <p>Let <i>putStatus</i> be the result of calling the [[Put]] internal method of <i>O</i> with arguments <i>to</i>, <i>fromVal</i>, and <b>true</b>.</p>
      <p>If <i>putStatus</i> is an abrupt completion, return <i>putStatus</i>.</p>
      <p>Else, <i>fromPresent</i> is <b>false</b></p>
      <p>Let <i>delete</i><i>Status</i> be the result of calling the [[Delete]] internal method of <i>O</i> with arguments <i>to</i> and <b>true</b>.</p>
      <p>If <i>delete</i><i>Status</i> is an abrupt completion, return <i>delete</i><i>Status</i>.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Let <i>delete</i><i>Status</i> be the result of calling the [[Delete]] internal method of <i>O</i> with arguments ToString(<i>len</i>–1) and <b>true</b>.</p>
      <p>If <i>delete</i><i>Status</i> is an abrupt completion, return <i>delete</i><i>Status</i>.</p>
      <p>Call the [[Put]] internal method of <i>O</i> with arguments "<b>length</b>", (<i>len</i>–1) , and <b>true</b>.</p>
      <p>If <i>putStatus</i> is an abrupt completion, return <i>putStatus</i>.</p>
      <p>Return <i>first</i>.</p>
      <p>NOTE<span>	The </span><b>shift</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>shift</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.10<span>	Array.prototype.slice (start, end)</span></h2>
      <p>The <b>slice</b> method takes two arguments, <i>start</i> and <i>end</i>, and returns an array containing the elements of the array from element <i>start</i> up to, but not including, element <i>end</i> (or through the end of the array if <i>end</i> is <b>undefined</b>). If <i>start</i> is negative, it is treated as <i>length</i>+<i>start</i> where <i>length</i> is the length of the array. If <i>end</i> is negative, it is treated as <i>length</i>+<i>end</i> where <i>length</i> is the length of the array. The following steps are taken:</p>
      <p>Let <i>O </i>be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>A</i> be a new array created as if by the expression <b>new Array() </b>where <b>Array</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>lenVal</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument "<b>length</b>".</p>
      <p>Let <i>len</i> be ToUint32(<i>lenVal</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>Let <i>relativeStart</i> be ToInteger(<i>start</i>).</p>
      <p>If <i>relativeStart</i> is an abrupt completion, return <i>relativeStart</i>.</p>
      <p>If <i>relativeStart</i> is negative, let <i>k</i> be max((<i>len</i> +<i> relativeStart</i>),0); else let <i>k</i> be min(<i>relativeStart</i>,<i> len</i>).</p>
      <p>If <i>end</i> is <b>undefined</b>, let <i>relativeEnd</i> be <i>len</i>; else let <i>relativeEnd</i> be ToInteger(<i>end</i>).</p>
      <p>If <i>relativeEnd</i> is an abrupt completion, return <i>relativeEnd</i>.</p>
      <p>If <i>relativeEnd</i> is negative, let <i>final</i> be max((<i>len</i> +<i> relativeEnd</i>),0); else let <i>final</i> be min(<i>relativeEnd</i>,<i> len</i>).</p>
      <p>Let <i>n</i> be 0.</p>
      <p>Repeat, while <i>k</i> &lt; <i>final</i></p>
      <p>Let <i>Pk</i> be ToString(<i>k</i>).</p>
      <p>Let <i>kPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kPresent</i> is <b>true</b>, then</p>
      <p>Let <i>kValue</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kValue</i> is an abrupt completion, return <i>kValue</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments ToString(<i>n</i>), Property Descriptor {[[Value]]: <i>kValue</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Increase <i>n</i> by 1.</p>
      <p>Return <i>A</i>.</p>
      <p>The <b>length</b> property of the <b>slice</b> method is <b>2</b>.</p>
      <p>NOTE<span>	The </span><b>slice</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>slice</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.11<span>	Array.prototype.sor</span>t (comparefn)</h2>
      <p>The elements of this array are sorted. The sort is not necessarily stable (that is, elements that compare equal do not necessarily remain in their original order). If <i>comparefn</i> is not <b>undefined</b>, it should be a function that accepts two arguments <i>x</i> and <i>y</i> and returns a negative value if <i>x</i> &lt; <i>y</i>, zero if <i>x</i> = <i>y</i>, or a positive value if <i>x</i> &gt; <i>y</i>.</p>
      <p>Let <i>obj </i>be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>len</i> be the result of applying Uint32 to the result of calling the [[Get]] internal method of <i>obj</i> with argument "<b>length</b>".</p>
      <p>If <i>comparefn</i> is not <b>undefined</b> and is not a consistent comparison function for the elements of this array (see below), the behaviour of <b>sort</b> is implementation-defined.</p>
      <p>Let <i>proto</i> be the value of the [[Prototype]] internal property of <i>obj</i>. If <i>proto</i> is not <b>null</b> and there exists an integer  <i>j</i> such that all of the conditions below are satisfied then the behaviour of <b>sort</b> is implementation-defined:</p>
      <p><i>obj</i> is sparse (15.4)</p>
      <p>0 ≤ <i>j</i> &lt; <i>len</i></p>
      <p>The result of calling the [[HasProperty]] internal method of <i>proto</i> with argument ToString(<i>j</i>) is <b>true</b>.</p>
      <p>The behaviour of <b>sort</b> is also implementation defined if <i>obj </i>is sparse and any of the following conditions are true:</p>
      <p>The [[Extensible]] internal property of <i>obj</i> is <b>false</b>.</p>
      <p>Any array index property of <i>obj</i> whose name is a nonnegative integer less than <i>len </i>is a data property whose [[Configurable]] attribute is <b>false</b>.</p>
      <p>The behaviour of <b>sort</b> is also implementation defined if any array index property of <i>obj</i> whose name is a nonnegative integer less than <i>len</i> is an accessor property or is a data property whose [[Writable]] attribute is <b>false</b>.</p>
      <p>Otherwise, the following steps are taken.</p>
      <p>Perform an implementation-dependent sequence of calls to the [[Get]] , [[Put]], and [[Delete]] internal methods of <i>obj</i> and to SortCompare (described below), where the first argument for each call to [[Get]], [[Put]], or [[Delete]] is a nonnegative integer less than <i>len </i>and where the arguments for calls to SortCompare are results of previous calls to the [[Get]] internal method. The throw argument to the [[Put]] and [[Delete]] internal methods will be the value <b>true</b>. If <i>obj</i> is not sparse then [[Delete]] must not be called.</p>
      <p>Return <i>obj</i>.</p>
      <p>The returned object must have the following two properties.</p>
      <p>There must be some mathematical permutation π of the nonnegative integers less than <i>len</i>, such that for every nonnegative integer <i>j</i> less than <i>len</i>, if property old[<i>j</i>]<b> </b>existed, then new[π(<i>j</i>)] is exactly the same value as old[<i>j</i>]<b>,</b>. But if property old[<i>j</i>]<b> </b>did not exist, then new[π(<i>j</i>)] does not exist.</p>
      <p>Then for all nonnegative integers <i>j</i> and <i>k</i>, each less than <i>len</i>, if SortCompare(<i>j</i>,<i>k</i>) &lt; 0<b> </b>(see SortCompare below), then <b>π</b>(<i>j</i>) &lt;<b> </b><b>π</b>(<i>k</i>).</p>
      <p>Here the notation old[<i>j</i>] is used to refer to the hypothetical result of calling the [[Get]] internal method of <i>obj</i> with argument <i>j</i> before this function is executed, and the notation new[<i>j</i>] to refer to the hypothetical result of calling the [[Get]] internal method of <i>obj</i> with argument <i>j</i> after this function has been executed.</p>
      <p>A function <i>comparefn</i> is a consistent comparison function for a set of values <i>S</i> if all of the requirements below are met for all values <i>a</i>, <i>b</i>, and <i>c</i> (possibly the same value) in the set <i>S</i>: The notation <i>a</i> &lt;<sub>CF</sub> <i>b</i> means <i>comparefn</i>(<i>a</i>,<i>b</i>) &lt; 0; <i>a</i> =<sub>CF</sub> <i>b</i> means <i>comparefn</i>(<i>a</i>,<i>b</i>) = 0 (of either sign); and <i>a</i> &gt;<sub>CF</sub> <i>b</i> means <i>comparefn</i>(<i>a</i>,<i>b</i>) &gt; 0.</p>
      <p>Calling <i>comparefn</i>(<i>a</i>,<i>b</i>) always returns the same value <i>v</i> when given a specific pair of values <i>a</i> and <i>b</i> as its two arguments. Furthermore, Type(<i>v</i>) is Number, and <i>v</i> is not NaN. Note that this implies that exactly one of <i>a</i> &lt;<sub>CF</sub> <i>b</i>, <i>a</i> =<sub>CF</sub> <i>b</i>, and <i>a</i> &gt;<sub>CF</sub> <i>b</i> will be true for a given pair of <i>a</i> and <i>b</i>.</p>
      <p>Calling <i>comparefn</i>(<i>a</i>,<i>b</i>) does not modify the <b>this</b> object.</p>
      <p><i>a</i> =<sub>CF</sub> <i>a</i>   (reflexivity)</p>
      <p>If <i>a</i> =<sub>CF</sub> <i>b</i>, then <i>b</i> =<sub>CF</sub> <i>a</i>   (symmetry)</p>
      <p>If <i>a</i> =<sub>CF</sub> <i>b</i> and <i>b</i> =<sub>CF</sub> <i>c</i>, then <i>a</i> =<sub>CF</sub> <i>c</i>   (transitivity of =<sub>CF</sub>)</p>
      <p>If <i>a</i> &lt;<sub>CF</sub> <i>b</i> and <i>b</i> &lt;<sub>CF</sub> <i>c</i>, then <i>a</i> &lt;<sub>CF</sub> <i>c</i>   (transitivity of &lt;<sub>CF</sub>)</p>
      <p>If <i>a</i> &gt;<sub>CF</sub> <i>b</i> and <i>b</i> &gt;<sub>CF</sub> <i>c</i>, then <i>a</i> &gt;<sub>CF</sub> <i>c</i>   (transitivity of &gt;<sub>CF</sub>)</p>
      <p>NOTE<span>	The above conditions are necessary and sufficient to ensure that </span><i>comparefn</i> divides the set <i>S</i> into equivalence classes and that these equivalence classes are totally ordered.</p>
      <p>When the SortCompare abstract operation is called with two arguments <i>j</i> and <i>k</i>, the following steps are taken:</p>
      <p>Let <i>jString</i> be ToString(<i>j</i>).</p>
      <p>Let <i>kString</i> be ToString(<i>k</i>).</p>
      <p>Let <i>hasj</i> be the result of calling the [[HasProperty]] internal method of <i>obj</i> with argument <i>jString</i>.</p>
      <p>Let <i>hask</i> be the result of calling the [[HasProperty]] internal method of <i>obj</i> with argument <i>kString</i>.</p>
      <p>If <i>hasj </i>and<i> hask </i>are both<i> </i><b>false</b>, then return <b>+0</b>.</p>
      <p>If <i>hasj </i>is <b>false</b>, then return 1.</p>
      <p>If <i>hask </i>is <b>false</b>, then return –1.</p>
      <p>Let <i>x</i> be the result of calling the [[Get]] internal method of <i>obj</i> with argument <i>jString</i>.</p>
      <p>Let <i>y</i> be the result of calling the [[Get]] internal method of <i>obj</i> with argument <i>kString</i>.</p>
      <p>If <i>x</i> and <i>y</i> are both <b>undefined</b>, return <b>+0</b>.</p>
      <p>If <i>x</i> is <b>undefined</b>, return 1.</p>
      <p>If <i>y</i> is <b>undefined</b>, return −1.</p>
      <p>If the argument <i>comparefn</i> is not <b>undefined</b>, then</p>
      <p>If IsCallable(<i>comparefn</i>) is <b>false</b>, throw a <b>TypeError</b> exception.</p>
      <p>Return the result of calling the [[Call]] internal method of <i>comparefn</i> passing <b>undefined</b> as the <b>this</b> value and with arguments <i>x</i> and <i>y</i>.</p>
      <p>Let <i>xString</i> be ToString(<i>x</i>).</p>
      <p>Let <i>yString</i> be ToString(<i>y</i>).</p>
      <p>If <i>xString</i> &lt; <i>yString</i>, return −1.</p>
      <p>If <i>xString</i> &gt; <i>yStri</i><i>ng</i>, return 1.</p>
      <p>Return <b>+0</b>.</p>
      <p>NOTE 1<span>	Because non-existent property values always compare greater than </span><b>undefined</b> property values, and <b>undefined</b> always compares greater than any other value, undefined property values always sort to the end of the result, followed by non-existent property values.</p>
      <p>NOTE 2<span>	The </span><b>sort</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method. Whether the <b>sort</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.12<span>	Array.prototype.splice (start, deleteCount [ , item1 [ , item2 [ , … ] ] ] )</span></h2>
      <p>When the <b>splice</b> method is called with two or more arguments <i>start</i>, <i>deleteCount</i> and (optionally) <i>item1</i>, <i>item2</i>, etc., the <i>deleteCount</i> elements of the array starting at array index <i>start</i> are replaced by the arguments <i>item1</i>, <i>item2</i>, etc. An Array object containing the deleted elements (if any) is returned. The following steps are taken:</p>
      <p>Let <i>O </i>be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>A</i> be a new array created as if by the expression <b>new Array()</b>where <b>Array</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>lenVal</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument "<b>length</b>".</p>
      <p>Let <i>len</i> be ToUint32(<i>lenVal</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>Let <i>relativeStart</i> be ToInteger(<i>start</i>).</p>
      <p>If <i>relativeStart</i> is negative, let <i>actualStart</i> be max((<i>len</i> +<i> relativeStart</i>),0); else let <i>actualStart</i> be min(<i>relativeStart</i>,<i> len</i>).</p>
      <p>Let <i>actualDeleteCount</i> be min(max(ToInteger(<i>deleteCount</i>),0),<i> len</i> –<i> actualStart</i>).</p>
      <p>Let <i>k</i> be 0.</p>
      <p>Repeat, while <i>k</i> &lt; <i>actualDeleteCount</i></p>
      <p>Let <i>from</i> be ToString(<i>actualStart</i>+<i>k</i>).</p>
      <p>Let <i>fromPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>from</i>.</p>
      <p>If <i>fromPresent</i> is <b>true</b>, then</p>
      <p>Let <i>fromValue</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>from</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments ToString(<i>k</i>), Property Descriptor {[[Value]]: <i>fromValue</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Increment <i>k</i> by 1.</p>
      <p>Let <i>items</i> be an internal List whose elements are, in left to right order, the portion of the actual argument list starting with <i>item1</i>. The list will be empty if no such items are present.</p>
      <p>Let <i>itemCount</i> be the number of elements in <i>items</i>.</p>
      <p>If <i>itemCount</i> &lt; <i>actualDeleteCount</i>, then</p>
      <p>Let <i>k</i> be <i>actualStart</i>.</p>
      <p>Repeat, while <i>k</i> &lt; (<i>len</i> – <i>actualDeleteCount</i>)</p>
      <p>Let <i>from</i> be ToString(<i>k</i>+<i>actualDeleteCount</i>).</p>
      <p>Let <i>to</i> be ToString(<i>k</i>+<i>itemCount</i>).</p>
      <p>Let <i>fromPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>from</i>.</p>
      <p>If <i>fromPresent</i> is <b>true</b>, then</p>
      <p>Let <i>fromValue</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>from</i>.</p>
      <p>Call the [[Put]] internal method of <i>O</i> with arguments <i>to</i>, <i>fromValue</i>, and <b>true</b>.</p>
      <p>Else, <i>fromPresent</i> is <b>false</b></p>
      <p>Call the [[Delete]] internal method of <i>O</i> with arguments <i>to</i> and <b>true</b>.</p>
      <p>Increase k by 1.</p>
      <p>Let <i>k</i> be <i>len</i>.</p>
      <p>Repeat, while <i>k</i> &gt; (<i>len</i> –<i> actualDeleteCount</i> +<i> itemCount</i>) </p>
      <p>Call the [[Delete]] internal method of <i>O</i> with arguments ToString(<i>k</i>–1) and <b>true</b>.</p>
      <p>Decrease <i>k</i> by 1.</p>
      <p>Else if <i>itemCount</i> &gt; <i>actualDeleteCount</i>, then</p>
      <p>Let <i>k</i> be (<i>len</i> –<i> actualDeleteCount</i>).</p>
      <p>Repeat, while <i>k</i> &gt; <i>actualStart</i></p>
      <p>Let <i>from</i> be ToString(<i>k </i>+<i> actualDeleteCount</i> – 1).</p>
      <p>Let <i>to</i> be ToString(<i>k </i>+<i> itemCount</i> – 1)</p>
      <p>Let <i>fromPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>from</i>.</p>
      <p>If <i>fromPresent</i> is <b>true</b>, then</p>
      <p>Let <i>fromValue</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>from</i>.</p>
      <p>Call the [[Put]] internal method of <i>O</i> with arguments <i>to</i>, <i>fromValue</i>, and <b>true</b>.</p>
      <p>Else, <i>fromPresent</i> is <b>false</b></p>
      <p>Call the [[Delete]] internal method of <i>O</i> with argument <i>to</i> and <b>true</b>.</p>
      <p>Decrease <i>k</i> by 1.</p>
      <p>Let <i>k</i> be <i>actualStart</i>.</p>
      <p>Repeat, while <i>items</i> is not empty</p>
      <p>Remove the first element from <i>items</i> and let <i>E</i> be the value of that element.</p>
      <p>Call the [[Put]] internal method of <i>O</i> with arguments ToString(<i>k</i>), <i>E</i>, and <b>true</b>.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Call the [[Put]] internal method of <i>O</i> with arguments "<b>length</b>", (<i>len </i>–<i> actualDeleteCount</i> +<i> itemCount</i>), and <b>true</b>.</p>
      <p>Return <i>A</i>.</p>
      <p>The <b>length</b> property of the <b>splice</b> method is <b>2</b>.</p>
      <p>NOTE<span>	The </span><b>splice</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>splice</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.13<span>	Array.prototype.unshift ( [ item1 [ , item2 [ , … ] ] ] )</span></h2>
      <p>The arguments are prepended to the start of the array, such that their order within the array is the same as the order in which they appear in the argument list.</p>
      <p>When the <b>unshift</b> method is called with zero or more arguments <i>item1</i>,<i> item2</i>, etc., the following steps are taken:</p>
      <p>Let <i>O </i>be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenVal</i> be the result of calling the  [[Get]] internal method of <i>O</i> with argument "<b>length</b>".</p>
      <p>Let <i>len</i> be ToUint32(<i>lenVal</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>Let <i>argCount</i> be the number of actual arguments.</p>
      <p>Let <i>k</i> be <i>len</i>.</p>
      <p>Repeat, while <i>k</i> &gt; 0, </p>
      <p>Let <i>from</i> be ToString(<i>k</i>–1).</p>
      <p>Let <i>to</i> be ToString(<i>k</i>+<i>argCount</i> –1).</p>
      <p>Let <i>fromPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>from</i>.</p>
      <p>If <i>fromPresent</i> is <b>true</b>, then</p>
      <p>Let <i>fromValue</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>from</i>.</p>
      <p>Call the [[Put]] internal method of <i>O</i> with arguments <i>to</i>, <i>fromValue</i>, and <b>true</b>.</p>
      <p>Else, <i>fromPresent</i> is <b>false</b></p>
      <p>Call the [[Delete]] internal method of <i>O</i> with arguments <i>to</i>, and <b>true</b>.</p>
      <p>Decrease <i>k</i> by 1.</p>
      <p>Let <i>j</i> be 0.</p>
      <p>Let <i>items</i> be an internal List whose elements are, in left to right order, the arguments that were passed to this function invocation.</p>
      <p>Repeat, while <i>items</i> is not empty</p>
      <p>Remove the first element from <i>items</i> and let <i>E</i> be the value of that element.</p>
      <p>Call the [[Put]] internal method of <i>O</i> with arguments ToString(<i>j</i>), <i>E</i>, and <b>true</b>.</p>
      <p>Increase <i>j</i> by 1.</p>
      <p>Call the [[Put]] internal method of <i>O</i> with arguments "<b>length</b>", <i>len</i>+<i>argCount</i>, and <b>true</b>.</p>
      <p>Return <i>len</i>+<i>argCount</i>.</p>
      <p>The <b>length</b> property of the <b>unshift</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>unshift</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>unshift</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.14<span>	Array.prototype.indexOf ( searchElement [ , fromIndex ] )</span></h2>
      <p><b>indexOf</b> compares <i>searchElement</i> to the elements of the array, in ascending order, using the internal Strict Equality Comparison Algorithm (11.9.1), and if found at one or more positions, returns the index of the first such position; otherwise, -1 is returned.</p>
      <p>The optional second argument <i>fromIndex</i> defaults to 0 (i.e. the whole array is searched). If it is greater than or equal to the length of the array, -1 is returned, i.e. the array will not be searched. If it is negative, it is used as the offset from the end of the array to compute <i>fromIndex</i>. If the computed index is less than 0, the whole array will be searched.</p>
      <p>When the <b>indexOf</b> method is called with one or two arguments, the following steps are taken:</p>
      <p>Let <i>O </i>be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenValue</i>  be the result of calling the [[Get]] internal method of <i>O </i>with the argument "<b>length</b>".</p>
      <p>Let <i>len</i> be ToUint32(<i>lenValue</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>If <i>len</i> is 0, return -1.</p>
      <p>If argument <i>fromIndex</i> was passed let <i>n</i> be ToInteger(<i>fromIndex</i>); else let <i>n</i> be 0.</p>
      <p>If <i>n</i> is an abrupt completion, return <i>n</i>.</p>
      <p>If <i>n </i>≥ <i>len</i>, return -1.</p>
      <p>If <i>n </i>≥ 0, then </p>
      <p>Let <i>k </i>be <i>n</i>.</p>
      <p>Else, <i>n</i>&lt;0</p>
      <p>Let <i>k </i>be <i>len</i> - abs(<i>n</i>).</p>
      <p>If <i>k </i>is less than 0, then let <i>k</i> be 0.</p>
      <p>Repeat, while <i>k</i>&lt;<i>len</i></p>
      <p>Let <i>kPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument ToString(<i>k</i>).</p>
      <p>If <i>kPresent</i> is <b>true</b>, then</p>
      <p>Let <i>elementK</i> be the result of calling the [[Get]] internal method of <i>O </i>with the argument ToString(<i>k</i>).</p>
      <p>If <i>elementK</i> is an abrupt completion, return <i>elementK</i>.</p>
      <p>Let <i>same</i> be the result of applying the Strict Equality Comparison Algorithm to<i> searchElement</i> and <i>elementK</i>.</p>
      <p>If <i>same</i> is <b>true,  </b>return <i>k</i>.</p>
      <p>Increase <i>k </i>by 1.</p>
      <p>Return -1.</p>
      <p>The <b>length</b> property of the <b>indexOf</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>indexOf</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>indexOf</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.15<span>	Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )</span></h2>
      <p><b>lastIndexOf</b> compares <i>searchElement</i> to the elements of the array in descending order using the internal Strict Equality Comparison Algorithm (11.9.1), and if found at one or more positions, returns the index of the last such position; otherwise, -1 is returned.</p>
      <p>The optional second argument <i>fromIndex</i> defaults to the array's length minus one (i.e. the whole array is searched). If it is greater than or equal to the length of the array, the whole array will be searched. If it is negative, it is used as the offset from the end of the array to compute <i>fromIndex</i>. If the computed index is less than 0, -1 is returned.</p>
      <p>When the <b>lastIndexOf</b> method is called with one or two arguments, the following steps are taken:</p>
      <p>Let <i>O</i> be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenValue</i>  be the result of calling the [[Get]] internal method of <i>O </i>with the argument "<b>length</b>".</p>
      <p>Let <i>len</i> be ToUint32(<i>lenValue</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>If <i>len</i> is 0, return -1.</p>
      <p>If argument <i>fromIndex</i> was passed let <i>n</i> be ToInteger(<i>fromIndex</i>); else let <i>n</i> be <i>len</i>-1.</p>
      <p>If <i>n</i> is an abrupt completion, return <i>n</i>.</p>
      <p>If <i>n</i> ≥ <i>0</i>, then let <i>k</i> be min(<i>n</i>, <i>len</i> – 1).</p>
      <p>Else,  <i>n</i> &lt; 0</p>
      <p>Let <i>k</i> be <i>len</i> - abs(<i>n</i>).</p>
      <p>Repeat, while <i>k</i>≥ <i>0</i></p>
      <p>Let <i>kPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument ToString(<i>k</i>).</p>
      <p>If <i>kPresent</i> is <b>true</b>, then</p>
      <p>Let <i>elementK</i> be the result of calling the [[Get]] internal method of <i>O </i>with the argument ToString(<i>k</i>).</p>
      <p>If <i>elementK</i> is an abrupt completion, return <i>elementK</i>.</p>
      <p>Let <i>same</i> be the result of applying the Strict Equality Comparison Algorithm to<i> searchElement</i> and <i>elementK</i>.</p>
      <p>If <i>same</i> is <b>true,  </b>return <i>k</i>.</p>
      <p>Decrease <i>k</i> by 1.</p>
      <p>Return -1.</p>
      <p>The <b>length</b> property of the <b>lastIndexOf</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>lastIndexOf</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>lastIndexOf</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.16<span>	Array.prototype.every ( callbackfn [ , thisArg ] )</span></h2>
      <p><i>callbackfn </i>should be a function that accepts three arguments and returns a value that is coercible to the Boolean value <b>true</b> or <b>false</b>. <b>every</b> calls <i>callbackfn</i> once for each element present in the array, in ascending order, until it finds one where <i>callbackfn</i> returns <b>false</b>. If such an element is found, <b>every</b> immediately returns <b>false</b>. Otherwise, if <i>callbackfn</i> returned <b>true</b> for all elements, <b>every</b> will return <b>true</b>. <i>callbackfn</i> is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
      <p>If a <i>thisArg</i> parameter is provided, it will be used as the <b>this </b>value for each invocation of <i>callbackfn</i>. If it is not provided, <b>undefined</b> is used instead.</p>
      <p><i>callbackfn</i> is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
      <p><b>every</b> does not directly mutate the object on which it is called but the object may be mutated by the calls to <i>callbackfn</i>. </p>
      <p>The range of elements processed by <b>every</b> is set before the first call to <i>callbackfn</i>. Elements which are appended to the array after the call to <b>every</b> begins will not be visited by <i>callbackfn</i>. If existing elements of the array are changed, their value as passed to <i>callbackfn</i> will be the value at the time <b>every</b> visits them; elements that are deleted after the call to <b>every</b> begins and before being visited are not visited. <b>every</b> acts like the "for all" quantifier in mathematics. In particular, for an empty array, it returns <b>true</b>.</p>
      <p>When the <b>every</b> method is called with one or two arguments, the following steps are taken:</p>
      <p>Let <i>O</i> be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenValue</i>  be the result of calling the [[Get]] internal method of <i>O</i> with the argument <b>"length"</b>.</p>
      <p>Let <i>len</i> be ToUint32(<i>lenValue</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>If IsCallable(<i>callbackfn</i>) is <b>false</b>, throw a <b>TypeError</b> exception.</p>
      <p>If <i>thisArg</i> was supplied, let <i>T</i> be <i>thisArg</i>; else let <i>T</i> be <b>undefined</b>.</p>
      <p>Let <i>k</i> be 0.</p>
      <p>Repeat, while <i>k </i>&lt; <i>len</i></p>
      <p>Let <i>Pk</i> be ToString(<i>k</i>).</p>
      <p>Let <i>kPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kPresent</i> is <b>true</b>, then</p>
      <p>Let <i>kValue</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kValue</i> is an abrupt completion, return <i>kValue</i>.</p>
      <p>Let <i>testResult</i> be the result of calling the [[Call]] internal method of <i>callbackfn</i> with <i>T</i> as the <b>this</b> value and argument list containing <i>kValue</i>, <i>k</i>, and <i>O</i>.</p>
      <p>If <i>testResult</i> is an abrupt completion, return <i>testResult</i>.</p>
      <p>If ToBoolean(<i>testResult)</i> is <b>false</b>, return <b>false</b>.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Return <b>true</b>.</p>
      <p>The <b>length</b> property of the <b>every</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>every</b> function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>every</b> function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.17<span>	Array.prototype.some ( callbackfn [ , thisArg ] )</span></h2>
      <p><i>callbackfn </i>should be a function that accepts three arguments and returns a value that is coercible to the Boolean value <b>true</b> or <b>false</b>. <b>some</b> calls <i>callbackfn</i> once for each element present in the array, in ascending order, until it finds one where <i>callbackfn</i> returns <b>true</b>. If such an element is found, <b>some</b> immediately returns <b>true</b>. Otherwise, <b>some</b> returns <b>false</b>. <i>callbackfn</i> is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
      <p>If a <i>thisArg</i> parameter is provided, it will be used as the <b>this </b>value for each invocation of <i>callbackfn</i>. If it is not provided, <b>undefined</b> is used instead.</p>
      <p><i>callbackfn</i> is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
      <p><b>some</b> does not directly mutate the object on which it is called but the object may be mutated by the calls to <i>callbackfn</i>.</p>
      <p>The range of elements processed by <b>some</b> is set before the first call to <i>callbackfn</i>. Elements that are appended to the array after the call to <b>some</b> begins will not be visited by <i>callbackfn</i>. If existing elements of the array are changed, their value as passed to <i>callbackfn</i> will be the value at the time that <b>some</b> visits them; elements that are deleted after the call to <b>some</b> begins and before being visited are not visited.<b> some</b> acts like the "exists" quantifier in mathematics. In particular, for an empty array, it returns <b>false</b>.</p>
      <p>When the <b>some</b> method is called with one or two arguments, the following steps are taken:</p>
      <p>Let <i>O</i> be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenValue</i>  be the result of calling the [[Get]] internal method of <i>O</i> with the argument <b>"length"</b>.</p>
      <p>Let <i>len</i> be ToUint32(<i>lenValue</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>If IsCallable(<i>callbackfn</i>) is <b>false</b>, throw a <b>TypeError</b> exception.</p>
      <p>If <i>thisArg</i> was supplied, let <i>T</i> be <i>thisArg</i>; else let <i>T</i> be <b>undefined</b>.</p>
      <p>Let <i>k</i> be 0.</p>
      <p>Repeat, while <i>k </i>&lt; <i>len</i></p>
      <p>Let <i>Pk</i> be ToString(<i>k</i>).</p>
      <p>Let <i>kPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kPresent</i> is <b>true</b>, then</p>
      <p>Let <i>kValue</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kValue</i> is an abrupt completion, return <i>kValue</i>.</p>
      <p>Let <i>testResult</i> be the result of calling the [[Call]] internal method of <i>callbackfn</i> with <i>T</i> as the <b>this</b> value and argument list containing <i>kValue</i>, <i>k</i>, and <i>O</i>.</p>
      <p>If <i>testResult</i> is an abrupt completion, return <i>testResult</i>.</p>
      <p>If ToBoolean(<i>testResult)</i> is <b>true</b>, return <b>true</b>.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Return <b>false</b>.</p>
      <p>The <b>length</b> property of the <b>some</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>some</b><b> </b>function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>some</b><b> </b>function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.18<span>	Array.prototype.forEach ( callbackfn [ , thisArg ] )</span></h2>
      <p><i>callbackfn </i>should be a function that accepts three arguments. <b>forEach</b> calls <i>callbackfn</i> once for each element present in the array, in ascending order. <i>callbackfn</i> is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
      <p>If a <i>thisArg</i> parameter is provided, it will be used as the <b>this </b>value for each invocation of <i>callbackfn</i>. If it is not provided, <b>undefined</b> is used instead.</p>
      <p><i>callbackfn</i> is called with three arguments: the value of the element, the index of the element, and the object being traversed. </p>
      <p><b>forEach</b> does not directly mutate the object on which it is called but the object may be mutated by the calls to <i>callbackfn</i>. </p>
      <p>The range of elements processed by <b>forEach</b> is set before the first call to <i>callbackfn</i>. Elements which are appended to the array after the call to <b>forEach</b> begins will not be visited by <i>callbackfn</i>. If existing elements of the array are changed, their value as passed to callback will be the value at the time <b>forEach</b> visits them; elements that are deleted after the call to <b>forEach</b> begins and before being visited are not visited.</p>
      <p>When the <b>forEach</b> method is called with one or two arguments, the following steps are taken:</p>
      <p>Let <i>O</i> be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenValue</i>  be the result of calling the [[Get]] internal method of <i>O</i> with the argument <b>"length"</b>.</p>
      <p>Let <i>len</i> be ToUint32(<i>lenValue</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>If IsCallable(<i>callbackfn</i>) is <b>false</b>, throw a <b>TypeError</b> exception.</p>
      <p>If <i>thisArg</i> was supplied, let <i>T</i> be <i>thisArg</i>; else let <i>T</i> be <b>undefined</b>.</p>
      <p>Let <i>k</i> be 0.</p>
      <p>Repeat, while <i>k </i>&lt; <i>len</i></p>
      <p>Let <i>Pk</i> be ToString(<i>k</i>).</p>
      <p>Let <i>kPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kPresent</i> is <b>true</b>, then</p>
      <p>Let <i>kValue</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kValue</i> is an abrupt completion, return <i>kValue</i>.</p>
      <p>Let <i>funcResult</i> be  the result of calling [[Call]] internal method of <i>callbackfn</i> with <i>T</i> as the <b>this</b> value and argument list containing <i>kValue</i>, <i>k</i>, and <i>O</i>.</p>
      <p>If <i>func</i><i>Result</i> is an abrupt completion, return <i>func</i><i>Result</i>.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Return <b>undefined</b>.</p>
      <p>The <b>length</b> property of the <b>forEach</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>forEach</b><b> </b>function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>forEach</b><b> </b>function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.19<span>	Array.prototype.map ( callbackfn [ , thisArg ] )</span></h2>
      <p><i>callbackfn </i>should be a function that accepts three arguments. <b>map</b> calls <i>callbackfn</i> once for each element in the array, in ascending order, and constructs a new Array from the results. <i>callbackfn</i> is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
      <p>If a <i>thisArg</i> parameter is provided, it will be used as the <b>this </b>value<b> </b>for each invocation of <i>callbackfn</i>. If it is not provided, <b>undefined</b> is used instead.</p>
      <p><i>callbackfn</i> is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
      <p><b>map</b> does not directly mutate the object on which it is called but the object may be mutated by the calls to <i>callbackfn</i>.</p>
      <p>The range of elements processed by <b>map</b> is set before the first call to <i>callbackfn</i>. Elements which are appended to the array after the call to <b>map</b> begins will not be visited by <i>callbackfn</i>. If existing elements of the array are changed, their value as passed to <i>callbackfn</i> will be the value at the time <b>map</b> visits them; elements that are deleted after the call to <b>map</b> begins and before being visited are not visited.</p>
      <p>When the <b>map</b> method is called with one or two arguments, the following steps are taken: </p>
      <p>Let <i>O</i> be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenValue</i>  be the result of calling the [[Get]] internal method of <i>O</i> with the argument <b>"length"</b>.</p>
      <p>Let <i>len</i> be ToUint32(<i>lenValue</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>If IsCallable(<i>callbackfn</i>) is <b>false</b>, throw a <b>TypeError</b> exception.</p>
      <p>If <i>thisArg</i> was supplied, let <i>T</i> be <i>thisArg</i>; else let <i>T</i> be <b>undefined</b>.</p>
      <p>Let <i>A</i> be a new array created as if by the expression <b>new Array(</b><i>len</i><b>)</b> where <b>Array</b> is the standard built-in constructor with that name and <i>len</i> is the value of <i>len</i>.</p>
      <p>Let <i>k</i> be 0.</p>
      <p>Repeat, while <i>k </i>&lt; <i>len</i></p>
      <p>Let <i>Pk</i> be ToString(<i>k</i>).</p>
      <p>Let <i>kPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kPresent</i> is <b>true</b>, then</p>
      <p>Let <i>kValue</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>ReturnIfAbrupt(<i>kValue</i>).</p>
      <p>Let <i>mappedValue</i> be the result of calling the [[Call]] internal method of <i>callbackfn</i> with <i>T</i> as the <b>this</b> value and argument List containing <i>kValue</i>, <i>k</i>, and <i>O</i>.</p>
      <p>ReturnIfAbrupt(<i>mappedValue</i>).</p>
      <p>Let <i>defineResult</i> be the result of calling the [[DefineOwnProperty]] internal method of <i>A</i> with arguments <i>Pk</i>, Property Descriptor {[[Value]]: <i>mappedValue</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>ReturnIfAbrupt(<i>defineResult</i>).</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Return <i>A</i>.</p>
      <p>The <b>length</b> property of the <b>map</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>map</b><b> </b>function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>map</b><b> </b>function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.20<span>	Array.prototype.filter ( callbackfn [ , thisArg ] )</span></h2>
      <p><i>callbackfn </i>should be a function that accepts three arguments and returns a value that is coercible to the Boolean value <b>true</b> or <b>false</b>. <b>filter</b> calls <i>callbackfn</i> once for each element in the array, in ascending order, and constructs a new array of all the values for which <i>callbackfn</i> returns <b>true</b>. <i>callbackfn</i> is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
      <p>If a <i>thisArg</i> parameter is provided, it will be used as the <b>this </b>value for each invocation of <i>callbackfn</i>. If it is not provided, <b>undefined</b> is used instead.</p>
      <p><i>callbackfn</i> is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
      <p><b>filter</b> does not directly mutate the object on which it is called but the object may be mutated by the calls to <i>callbackfn</i>.</p>
      <p>The range of elements processed by <b>filter</b> is set before the first call to <i>callbackfn</i>. Elements which are appended to the array after the call to <b>filter</b> begins will not be visited by <i>callbackfn</i>. If existing elements of the array are changed their value as passed to <i>callbackfn</i> will be the value at the time <b>filter</b> visits them; elements that are deleted after the call to <b>filter</b> begins and before being visited are not visited.</p>
      <p>When the <b>filter</b> method is called with one or two arguments, the following steps are taken: </p>
      <p>Let <i>O</i> be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenValue</i>  be the result of calling the [[Get]] internal method of <i>O</i> with the argument <b>"length"</b>.</p>
      <p>Let <i>len</i> be ToUint32(<i>lenValue</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>If IsCallable(<i>callbackfn</i>) is <b>false</b>, throw a <b>TypeError</b> exception.</p>
      <p>If <i>thisArg</i> was supplied, let <i>T</i> be <i>thisArg</i>; else let <i>T</i> be <b>undefined</b>.</p>
      <p>Let <i>A</i> be a new array created as if by the expression <b>new Array()</b> where <b>Array</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>k</i> be 0.</p>
      <p>Let <i>to</i> be 0.</p>
      <p>Repeat, while <i>k </i>&lt; <i>len</i></p>
      <p>Let <i>Pk</i> be ToString(<i>k</i>).</p>
      <p>Let <i>kPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kPresent</i> is <b>true</b>, then</p>
      <p>Let <i>kValue</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kValue</i> is an abrupt completion, return <i>kValue</i>.</p>
      <p>Let <i>selected</i> be the result of calling the [[Call]] internal method of <i>callbackfn</i> with <i>T</i> as the <b>this</b> value and argument list containing <i>kValue</i>, <i>k</i>, and <i>O</i>.</p>
      <p>If <i>selected</i> is an abrupt completion, return <i>selected</i>.</p>
      <p>If ToBoolean(<i>selected</i>) is <b>true</b>, then</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments ToString(<i>to</i>), Property Descriptor {[[Value]]: <i>kValue</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Increase <i>to</i> by 1.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Return <i>A</i>.</p>
      <p>The <b>length</b> property of the <b>filter</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>filter</b><b> </b>function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>filter</b><b> </b>function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.21<span>	Array.prototype.reduce ( callbackfn [ , initialValue ] )</span></h2>
      <p><i>callbackfn </i>should be a function that takes four arguments. <b>reduce</b> calls the callback, as a function, once for each element present in the array, in ascending order.</p>
      <p><i>callbackfn </i>is called with four arguments: the <i>previousValue</i> (or value from the previous call to <i>callbackfn</i>), the <i>currentValue</i> (value of the current element), the <i>currentIndex</i>, and the object being traversed. The first time that callback is called, the <i>previousValue</i> and <i>currentValue</i> can be one of two values. If an <i>initialValue </i>was provided in the call to <b>reduce</b>, then <i>previousValue</i> will be equal to <i>initialValue </i>and <i>currentValue</i> will be equal to the first value in the array. If no <i>initialValue </i>was provided, then <i>previousValue</i> will be equal to the first value in the array and <i>currentValue</i> will be equal to the second. It is a <b>TypeError</b> if the array contains no elements and <i>initialValue</i> is not provided.</p>
      <p><b>reduce</b> does not directly mutate the object on which it is called but the object may be mutated by the calls to <i>callbackfn</i>.</p>
      <p>The range of elements processed by <b>reduce</b> is set before the first call to <i>callbackfn</i>. Elements that are appended to the array after the call to <b>reduce</b> begins will not be visited by <i>callbackfn</i>. If existing elements of the array are changed, their value as passed to <i>callbackfn </i>will be the value at the time <b>reduce</b> visits them; elements that are deleted after the call to <b>reduce</b> begins and before being visited are not visited.</p>
      <p>When the <b>reduce</b> method is called with one or two arguments, the following steps are taken: </p>
      <p>Let <i>O</i> be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenValue</i>  be the result of calling the [[Get]] internal method of <i>O</i> with the argument <b>"length"</b>.</p>
      <p>Let <i>len</i> be ToUint32(<i>lenValue</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>If IsCallable(<i>callbackfn</i>) is <b>false</b>, throw a <b>TypeError</b> exception.</p>
      <p>If len is 0 and <i>initialValue</i> is not present, throw a <b>TypeError</b> exception.</p>
      <p>Let <i>k</i> be 0.</p>
      <p>If <i>initialValue</i> is present, then</p>
      <p>Set <i>accumulator</i> to <i>initialValue</i>.</p>
      <p>Else, <i>initialValue</i> is not present</p>
      <p>Let <i>kPresent</i> be <b>false</b>.</p>
      <p>Repeat, while  <i>kPresent</i> is <b>false</b> and  <i>k</i> &lt; <i>len</i></p>
      <p>Let <i>Pk</i> be ToString(<i>k</i>).</p>
      <p>Let <i>kPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kPresent</i> is <b>true</b>, then</p>
      <p>Let <i>accumulator</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>accumulator</i> is an abrupt completion, return <i>accumulator</i>.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>If <i>kPresent</i> is <b>false</b>, throw a <b>TypeError</b> exception.</p>
      <p>Repeat, while <i>k </i>&lt; <i>len</i></p>
      <p>Let <i>Pk</i> be ToString(<i>k</i>).</p>
      <p>Let <i>kPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kPresent</i> is <b>true</b>, then</p>
      <p>Let <i>kValue</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kValue</i> is an abrupt completion, return <i>kValue</i>.</p>
      <p>Let <i>accumulator</i> be the result of calling the [[Call]] internal method of <i>callbackfn</i> with <b>undefined</b> as the <b>this</b> value and argument list containing <i>accumulator</i>, <i>kValue</i>, <i>k</i>, and <i>O</i>.</p>
      <p>If <i>accumulator</i> is an abrupt completion, return <i>accumulator</i>.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Return <i>accumulator</i>.</p>
      <p>The <b>length</b> property of the <b>reduce</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>reduce</b><b> </b>function is intentionally generic; it does not require that its <b>this</b> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>reduce</b><b> </b>function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.4.22<span>	Array.prototype.reduceRight ( callbackfn [ , initialValue ] )</span></h2>
      <p><i>callbackfn </i>should be a function that takes four arguments. <b>reduceRight </b>calls the callback, as a function, once for each element present in the array, in descending order.</p>
      <p><i>callbackfn </i>is called with four arguments: the <i>previousValue</i> (or value from the previous call to <i>callbackfn</i>), the <i>currentValue</i> (value of the current element), the <i>currentIndex</i>, and the object being traversed. The first time the function is called, the <i>previousValue</i> and <i>currentValue</i> can be one of two values. If an <i>initialValue </i>was provided in the call to <b>reduceRight</b>, then <i>previousValue</i> will be equal to <i>initialValue</i> and <i>currentValue</i> will be equal to the last value in the array. If no <i>initialValue </i>was provided, then <i>previousValue</i> will be equal to the last value in the array and <i>currentValue</i> will be equal to the second-to-last value. It is a <b>TypeError</b> if the array contains no elements and <i>initialValue</i> is not provided.</p>
      <p><b>reduceRight </b>does not directly mutate the object on which it is called but the object may be mutated by the calls to <i>callbackfn</i>.</p>
      <p>The range of elements processed by <b>reduceRight </b>is set before the first call to <i>callbackfn</i>. Elements that are appended to the array after the call to <b>reduceRight </b>begins will not be visited by <i>callbackfn</i>. If existing elements of the array are changed by <i>callbackfn</i>, their value as passed to <i>callbackfn </i>will be the value at the time <b>reduceRight </b>visits them; elements that are deleted after the call to <b>reduceRight</b> begins and before being visited are not visited.</p>
      <p>When the <b>reduceRight </b>method is called with one or two arguments, the following steps are taken: </p>
      <p>Let <i>O</i> be the result of calling ToObject passing the <b>this </b>value as the argument.</p>
      <p>Let <i>lenValue</i>  be the result of calling the [[Get]] internal method of <i>O</i> with the argument <b>"length"</b>.</p>
      <p>Let <i>len</i> be ToUint32(<i>lenValue</i>).</p>
      <p>ReturnIfAbrupt(<i>len</i>).</p>
      <p>If IsCallable(<i>callbackfn</i>) is <b>false</b>, throw a <b>TypeError</b> exception.</p>
      <p>If len is 0 and <i>initialValue</i> is not present, throw a <b>TypeError</b> exception.</p>
      <p>Let <i>k</i> be <i>len</i>-1.</p>
      <p>If <i>initialValue</i> is present, then</p>
      <p>Set <i>accumulator</i> to <i>initialValue</i>.</p>
      <p>Else, <i>initialValue</i> is not present</p>
      <p>Let <i>kPresent</i> be <b>false</b>.</p>
      <p>Repeat, while  <i>kPresent</i> is <b>false</b> and  <i>k</i> ≥ 0</p>
      <p>Let <i>Pk</i> be ToString(<i>k</i>).</p>
      <p>Let <i>kPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kPresent</i> is <b>true</b>, then</p>
      <p>Let <i>accumulator</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>accumulator</i> is an abrupt completion, return <i>accumulator</i>.</p>
      <p>Decrease <i>k</i> by 1.</p>
      <p>If <i>kPresent</i> is <b>false</b>, throw a <b>TypeError</b> exception.</p>
      <p>Repeat, while <i>k </i>≥ 0</p>
      <p>Let <i>Pk</i> be ToString(<i>k</i>).</p>
      <p>Let <i>kPresent</i> be the result of calling the [[HasProperty]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kPresent</i> is <b>true</b>, then</p>
      <p>Let <i>kValue</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument <i>Pk</i>.</p>
      <p>If <i>kValue</i> is an abrupt completion, return <i>kValue</i>.</p>
      <p>Let <i>accumulator</i> be the result of calling the [[Call]] internal method of <i>callbackfn</i> with <b>undefined</b> as the <b>this</b> value and argument list containing <i>accumulator</i>, <i>kValue</i>, <i>k</i>, and <i>O</i>.</p>
      <p>If <i>accumulator</i> is an abrupt completion, return <i>accumulator</i>.</p>
      <p>Decrease <i>k</i> by 1.</p>
      <p>Return <i>accumulator</i>.</p>
      <p>The <b>length</b> property of the <b>reduceRight</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>reduceRight </b>function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the <b>reduceRight </b>function can be applied successfully to a host object is implementation-dependent.</p>
      <h2>15.4.5<span>	Properties of Array Instance</span>s</h2>
      <p>Array instances inherit properties from the Array prototype object and have the [[NativeBrand]] internal property with value NativeArray. Array instances also have the following properties.</p>
      <h2>15.4.5.1<span>	[[DefineOwnProperty]</span>] ( P, Desc, Throw )</h2>
      <p>Array objects use a variation of the [[DefineOwnProperty]] internal method used for other native ECMAScript objects (8.12.9).</p>
      <p>Assume <i>A </i>is an Array object, <i>Desc</i> is a Property Descriptor, and <i>Throw </i>is a Boolean flag.</p>
      <p>In the following algorithm, the term “Reject” means “If <i>Throw </i>is <b>true</b>, then throw a <b>TypeError</b> exception, otherwise return <b>false</b>.”</p>
      <p>When the [[DefineOwnProperty]] internal method of <i>A</i> is called with property <i>P</i>, Property Descriptor <i>Desc</i>, and Boolean flag <i>Throw</i>, the following steps are taken:</p>
      <p>ReturnIfAbrupt(<i>A</i>).</p>
      <p>Let <i>oldLenDesc</i> be the result of calling the [[GetOwnProperty]] internal method of <i>A</i> passing <b>"</b><b>length</b><b>"</b> as the argument.  The result will never be <b>undefined </b>or an accessor descriptor because Array objects are created with a length data property that cannot be deleted or reconfigured.</p>
      <p>Let <i>oldLen</i> be <i>oldLenDesc</i>.[[Value]].</p>
      <p>If <i>P</i> is <b>"</b><b>length</b><b>"</b>, then</p>
      <p>If the [[Value]] field of <i>Desc</i> is absent, then</p>
      <p>Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on <i>A</i> passing <b>"</b><b>length</b><b>"</b>, <i>Desc</i>, and <i>Throw</i> as arguments.</p>
      <p>Let <i>newLenDesc</i> be a copy of <i>Desc</i>.</p>
      <p>Let <i>newLen</i> be ToUint32(<i>Desc</i>.[[Value]]).</p>
      <p>If <i>newLen</i> is not equal to ToNumber(<i> Desc</i>.[[Value]]), throw a <b>RangeError</b> exception.</p>
      <p>Set <i>newLenDesc</i>.[[Value]] to <i>newLen</i>.</p>
      <p>If <i>newLen</i> ≥<i>oldLen</i>, then</p>
      <p>Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on <i>A</i> passing <b>"</b><b>length</b><b>"</b>, <i>newLenDesc</i>, and <i>Throw</i> as arguments.</p>
      <p>Reject if <i>oldLenDesc</i>.[[Writable]] is <b>false</b>.</p>
      <p>If <i>newLenDesc</i>.[[Writable]] is absent or has the value <b>true</b>, let <i>newWritable</i> be <b>true</b>.</p>
      <p>Else,</p>
      <p>Need to defer setting the [[Writable]] attribute to <b>false</b> in case any elements cannot be deleted.</p>
      <p>Let <i>newWritable</i> be <b>false</b>.</p>
      <p>Set <i>newLenDesc</i>.[[Writable]] to <b>true</b>.</p>
      <p>Let <i>succeeded</i> be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on <i>A</i> passing <b>"</b><b>length</b><b>"</b>, <i>newLenDesc</i>, and <i>Throw</i> as arguments.</p>
      <p>If <i>succeeded</i> is <b>false</b>, return <b>false</b>.</p>
      <p>While <i>newLen</i> &lt; <i>oldLen</i> repeat,</p>
      <p>Set <i>oldLen</i> to <i>oldLen</i> – 1.</p>
      <p>Let <i>deleteSucceeded</i> be the result of calling the [[Delete]] internal method of <i>A</i> passing ToString(<i>oldLen</i>) and <b>false</b> as arguments.</p>
      <p>If <i>deleteSucceeded</i> is <b>false</b>, then</p>
      <p>Set <i>newLenDesc</i>.[[Value]] to <i>oldLen+1</i>.</p>
      <p>If <i>newWritable</i> is <b>false</b>, set <i>newLenDesc</i>.[[Writable]] to <b>false</b>.</p>
      <p>Call the default [[DefineOwnProperty]] internal method (8.12.9) on <i>A</i> passing <b>"</b><b>length</b><b>"</b>, <i>newLenDesc</i>, and <b>false</b> as arguments. </p>
      <p>Reject.</p>
      <p>If <i>newWritable</i> is <b>false</b>, then</p>
      <p>Call the default [[DefineOwnProperty]] internal method (8.12.9) on <i>A</i> passing <b>"</b><b>length</b><b>"</b>, Property Descriptor{[[Writable]]: <b>false</b>}, and <b>false</b> as arguments. This call will always return <b>true</b>.</p>
      <p>Return <b>true</b>.</p>
      <p>Else if <i>P</i> is an array index (15.4), then</p>
      <p>Let <i>index</i> be ToUint32(<i>P</i>).</p>
      <p>Reject if <i>index</i> ≥ <i>oldLen</i> and <i>oldLenDesc</i>.[[Writable]] is <b>false</b>.</p>
      <p>Let <i>succeeded</i> be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on <i>A</i> passing <i>P</i>, <i>Desc</i>, and <b>false</b> as arguments.</p>
      <p>Reject if <i>succeeded</i> is <b>false</b>.</p>
      <p>If  <i>index</i> ≥ <i>oldLen</i></p>
      <p>Set <i>oldLenDesc</i>.[[Value]] to <i>index</i> + 1.</p>
      <p>Call the default [[DefineOwnProperty]] internal method (8.12.9) on <i>A</i> passing <b>"</b><b>length</b><b>"</b>, <i>oldLenDesc</i>, and <b>false</b> as arguments. This call will always return <b>true</b>.</p>
      <p>Return <b>true</b>.</p>
      <p>Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on <i>A</i> passing <i>P</i>, <i>Desc</i>, and <i>Throw</i> as arguments.</p>
      <h2>15.4.5.2<span>	lengt</span>h</h2>
      <p>The <b>length</b> property of this Array object is a data property whose value is always numerically greater than the name of every deletable property whose name is an array index.</p>
      <p>The <b>length</b> property initially has the attributes { [[Writable]]: <b>true</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <p>NOTE<span>	Attempting to set the length property of an Array object to a value that is numerically less than or equal to the largest numeric property name of an existing array indexed non-deletable property of the array will result in the length being set to a numeric value that is one greater than that largest numeric property name. See 15.4.5.1.</span></p>
      <h2>15.5<span>	String Object</span>s</h2>
      <h2>15.5.1<span>	The String Constructor Called as a Functio</span>n</h2>
      <p>When <b>String</b> is called as a function rather than as a constructor, it performs a type conversion.</p>
      <h2>15.5.1.1<span>	String ( [ value</span> ] )</h2>
      <p>Returns a String value (not a String object) computed by ToString(<i>value</i>). If <i>value</i> is not supplied, the empty String <b>""</b> is returned.</p>
      <h2>15.5.2<span>	The String Constructo</span>r</h2>
      <p>When <b>String</b> is called as part of a <b>new</b> expression, it is a constructor: it initialises the newly created object.</p>
      <h2>15.5.2.1<span>	new String ( [ value</span> ] )</h2>
      <p>The [[Prototype]] internal property of the newly constructed object is set to the standard built-in String prototype object that is the initial value of <b>String.prototype</b> (15.5.3.1).</p>
      <p>The newly constructed object has the [[NativeBrand]] internal property with value StringWrapper.</p>
      <p>The [[Extensible]] internal property of the newly constructed object is set to <b>true</b>.</p>
      <p>The [[PrimitiveValue]] internal property of the newly constructed object is set to ToString(<i>value</i>), or to the empty String if <i>value</i> is not supplied.</p>
      <h2>15.5.3<span>	Properties of the String</span> Constructor</h2>
      <p>The value of the [[Prototype]] internal property of the String constructor is the standard built-in Function prototype object (15.3.4).</p>
      <p>Besides the internal properties and the <b>length</b> property (whose value is <b>1</b>), the String constructor has the following properties:</p>
      <h2>15.5.3.1<span>	String.prototyp</span>e</h2>
      <p>The initial value of <b>String.prototype</b> is the standard built-in String prototype object (15.5.4).</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.5.3.2<span>	String.fromCharCode ( [ char0 [ , char1 [ , </span>… ] ] ] )</h2>
      <p>Returns a String value containing as many characters as the number of arguments. Each argument specifies one character of the resulting String, with the first argument specifying the first character, and so on, from left to right. An argument is converted to a character by applying the operation ToUint16 (9.7) and regarding the resulting 16-bit integer as the code unit value of a character. If no arguments are supplied, the result is the empty String.</p>
      <p>The <b>length</b> property of the <b>fromCharCode</b> function is <b>1</b>.</p>
      <h2>15.5.4<span>	Properties of the String Prototype Objec</span>t</h2>
      <p>The String prototype object is itself a String object whose value is an empty String. The String prototype object has the [[NativeBrand]] internal property with value StringWrapper.</p>
      <p>The value of the [[Prototype]] internal property of the String prototype object is the standard built-in Object prototype object (15.2.4).</p>
      <h2>15.5.4.1<span>	String.prototype.constructo</span>r</h2>
      <p>The initial value of <b>String.prototype.constructor</b> is the built-in <b>String</b> constructor.</p>
      <h2>15.5.4.2<span>	String.prototype.toString</span> ( )</h2>
      <p>Returns this String value. (Note that, for a String object, the <b>toString</b> method happens to return the same thing as the <b>valueOf</b> method.)</p>
      <p>The <b>toString</b> function is not generic; it throws a <b>TypeError</b> exception if its <b>this</b> value is not a String or a String object. Therefore, it cannot be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.3<span>	String.prototype.valueOf</span> ( )</h2>
      <p>Returns this String value.</p>
      <p>The <b>valueOf</b> function is not generic; it throws a <b>TypeError</b> exception if its <b>this</b> value is not a String or String object. Therefore, it cannot be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.4<span>	String.prototype.charA</span>t (pos)</h2>
      <p>Returns a String containing the character at position <i>pos</i> in the String resulting from converting this object to a String. If there is no character at that position, the result is the empty String. The result is a String value, not a String object.</p>
      <p>If <i>pos</i> is a value of Number type that is an integer, then the result of <b>x.charAt(</b><i>pos</i><b>)</b> is equal to the result of <b>x.substring(</b><i>pos</i><b>,</b> <i>pos</i><b>+1)</b>.</p>
      <p>When the <b>charAt</b> method is called with one argument <i>pos</i>, the following steps are taken:</p>
      <p>Call CheckObjectCoercible passing the <b>this</b> value as its argument.</p>
      <p>Let <i>S</i> be the result of calling ToString, giving it the <b>this</b> value as its argument.</p>
      <p>Let <i>position</i> be ToInteger(<i>pos</i>).</p>
      <p>Let <i>size</i> be the number of characters in <i>S</i>.</p>
      <p>If <i>position</i> &lt; 0 or <i>position</i> ≥ <i>size</i>, return the empty String.</p>
      <p>Return a String of length 1, containing one character from <i>S</i>, namely the character at position <i>position</i>, where the first (leftmost) character in <i>S</i> is considered to be at position 0, the next one at position 1, and so on.</p>
      <p>NOTE<span>	The </span><b>charAt</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.5<span>	String.prototype.charCodeAt (pos</span>)</h2>
      <p>Returns a Number (a nonnegative integer less than 2<sup>16</sup>) representing the code unit value of the character at position <i>pos</i> in the String resulting from converting this object to a String. If there is no character at that position, the result is <b>NaN</b>.</p>
      <p>When the <b>charCodeAt</b> method is called with one argument <i>pos</i>, the following steps are taken:</p>
      <p>Call CheckObjectCoercible passing the <b>this</b> value as its argument.</p>
      <p>Let <i>S</i> be the result of calling ToString, giving it the <b>this</b> value as its argument.</p>
      <p>Let <i>position</i> be ToInteger(<i>pos</i>).</p>
      <p>Let <i>size</i> be the number of characters in <i>S</i>.</p>
      <p>If <i>position</i> &lt; 0 or <i>position</i> ≥ <i>size</i>, return <b>NaN</b>.</p>
      <p>Return a value of Number type, whose value is the code unit value of the character at position <i>position</i> in the String <i>S</i>, where the first (leftmost) character in <i>S</i> is considered to be at position 0, the next one at position 1, and so on.</p>
      <p>NOTE<span>	The </span><b>charCodeAt</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.6<span>	String.prototype.concat ( [ string1 [ , string2 [ , … ] ] ] )</span></h2>
      <p>When the <b>concat</b> method is called with zero or more arguments <i>string1</i>, <i>string2</i>, etc., it returns a String consisting of the characters of this object (converted to a String) followed by the characters of each of <i>string1</i>, <i>string2</i>, etc. (where each argument is converted to a String). The result is a String value, not a String object. The following steps are taken:</p>
      <p>Call CheckObjectCoercible passing the <b>this</b> value as its argument.</p>
      <p>Let <i>S</i> be the result of calling ToString, giving it the <b>this</b> value as its argument.</p>
      <p>Let <i>args</i> be an internal list that is a copy of the argument list passed to this function.</p>
      <p>Let <i>R</i> be <i>S</i>.</p>
      <p>Repeat, while <i>args</i> is not empty</p>
      <p>Remove the first element from <i>args</i> and let <i>next</i> be the value of that element.</p>
      <p>Let <i>R</i> be the String value consisting of the characters in the previous value of <i>R</i> followed by the characters of ToString(<i>next</i>).</p>
      <p>Return <i>R</i>.</p>
      <p>The <b>length</b> property of the <b>concat</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>concat</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.7<span>	String.prototype.indexO</span>f (searchString, position)</h2>
      <p>If <i>searchString</i> appears as a substring of the result of converting this object to a String, at one or more positions that are greater than or equal to <i>position</i>, then the index of the smallest such position is returned; otherwise, <b>1</b> is returned. If <i>position</i> is <b>undefined</b>, 0 is assumed, so as to search all of the String.</p>
      <p>The <b>indexOf</b> method takes two arguments, <i>searchString </i>and<i> position</i>, and performs the following steps:</p>
      <p>Call CheckObjectCoercible passing the <b>this</b> value as its argument.</p>
      <p>Let <i>S</i> be the result of calling ToString, giving it the <b>this</b> value as its argument.</p>
      <p>Let <i>searchStr</i> be ToString(<i>searchString</i>).</p>
      <p>Let <i>pos</i> be ToInteger(<i>position</i>). (If <i>position</i> is <b>undefined</b>, this step produces the value <b>0</b>).</p>
      <p>Let <i>len</i> be the number of characters in <i>S</i>.</p>
      <p>Let <i>start</i> be min(max(<i>pos</i>, 0), <i>len</i>).</p>
      <p>Let <i>searchLen</i> be the number of characters in <i>searchStr</i>.</p>
      <p>Return the smallest possible integer <i>k</i> not smaller than <i>start</i> such that <i>k</i>+<i> searchLen</i> is not greater than <i>len</i>, and for all nonnegative integers <i>j</i> less than <i>searchLen</i>, the character at position <i>k</i>+<i>j</i> of <i>S</i> is the same as the character at position <i>j</i> of <i>searchStr</i>; but if there is no such integer <i>k</i>, then return the value <b>-1</b>.</p>
      <p>The <b>length</b> property of the <b>indexOf</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>indexOf</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.8<span>	String.prototype.lastIndexO</span>f (searchString, position)</h2>
      <p>If <i>searchString</i> appears as a substring of the result of converting this object to a String at one or more positions that are smaller than or equal to <i>position</i>, then the index of the greatest such position is returned; otherwise, <b>1</b> is returned. If <i>position</i> is <b>undefined</b>, the length of the String value is assumed, so as to search all of the String.</p>
      <p>The <b>lastIndexOf</b> method takes two arguments, <i>searchString </i>and<i> position</i>, and performs the following steps:</p>
      <p>Call CheckObjectCoercible passing the <b>this</b> value as its argument.</p>
      <p>Let <i>S</i> be the result of calling ToString, giving it the <b>this</b> value as its argument.</p>
      <p>Let <i>searchStr</i> be ToString(<i>searchString</i>).</p>
      <p>Let <i>numPos</i> be ToNumber(<i>position</i>). (If <i>position</i> is <b>undefined</b>, this step produces the value <b>NaN</b>).</p>
      <p>If <i>numPos</i> is <b>NaN</b>, let <i>pos</i> be <b>+</b><b>∞</b>; otherwise, let <i>pos</i> be ToInteger(<i>numPos</i>).</p>
      <p>Let <i>len</i> be the number of characters in <i>S</i>.</p>
      <p>Let <i>start</i> min(max(<i>pos</i>, 0), <i>len</i>).</p>
      <p>Let <i>searchLen</i> be the number of characters in <i>searchStr</i>.</p>
      <p>Return the largest possible nonnegative integer <i>k</i> not larger than <i>start</i> such that <i>k</i>+<i> searchLen</i> is not greater than <i>len</i>, and for all nonnegative integers <i>j</i> less than <i>searchLen</i>, the character at position <i>k</i>+<i>j</i> of <i>S</i> is the same as the character at position <i>j</i> of <i>searchStr</i>; but if there is no such integer <i>k</i>, then return the value <b>-1</b>.</p>
      <p>The <b>length</b> property of the <b>lastIndexOf</b> method is <b>1</b>.</p>
      <p>NOTE<span>	The </span><b>lastIndexOf</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.9<span>	String.prototype.localeCompare (that)</span></h2>
      <p>When the <b>localeCompare</b> method is called with one argument <i>that</i>, it returns a Number other than <b>NaN</b> that represents the result of a locale-sensitive String comparison of the this value (converted to a String) with <i>that</i> (converted to a String). The two Strings are <i>S</i> and <i>That</i>. The two Strings are compared in an implementation-defined fashion. The result is intended to order String values in the sort order specified by the system default locale, and will be negative, zero, or positive, depending on whether <i>S</i> comes before <i>That</i> in the sort order, the Strings are equal, or <i>S</i> comes after <i>That</i> in the sort order, respectively.</p>
      <p>Before perform the comparisons the following steps are performed to prepare the Strings:</p>
      <p>Call CheckObjectCoercible passing the <b>this</b> value as its argument.</p>
      <p>Let <i>S</i> be the result of calling ToString, giving it the <b>this</b> value as its argument.</p>
      <p>Let <i>That</i> be ToString(<i>that</i>).</p>
      <p>The <b>localeCompare</b> method, if considered as a function of two arguments <b>this</b> and <i>that</i>, is a consistent comparison function (as defined in 15.4.4.11) on the set of all Strings. </p>
      <p>The actual return values are implementation-defined to permit implementers to encode additional information in the value, but the function is required to define a total ordering on all Strings and to return <b>0</b> when comparing Strings that are considered canonically equivalent by the Unicode standard.</p>
      <p>If no language-sensitive comparison at all is available from the host environment, this function may perform a bitwise comparison.</p>
      <p>NOTE 1<span>	The </span><b>localeCompare</b> method itself is not directly suitable as an argument to <b>Array.prototype.sort</b> because the latter requires a function of two arguments.</p>
      <p>NOTE 2<span>	This function is intended to rely on whatever language-sensitive comparison functionality is available to the ECMAScript environment from the host environment, and to compare according to the rules of the host environment’s current locale. It is strongly recommended that this function treat Strings that are canonically equivalent according to the Unicode standard as identical (in other words, compare the Strings as if they had both been converted to Normalised Form C or D first). It is also recommended that this function not honour Unicode compatibility equivalences or decompositions.</span></p>
      <p>NOTE 3<span>	The second parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.</span></p>
      <p>NOTE 4<span>	The </span><b>localeCompare</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.10<span>	String.prototype.match (regexp)</span></h2>
      <p>When the <b>match</b> method is called with argument <i>regexp</i>, the following steps are taken:</p>
      <p>Call CheckObjectCoercible passing the <b>this</b> value as its argument.</p>
      <p>Let <i>S</i> be the result of calling ToString, giving it the <b>this</b> value as its argument.</p>
      <p>If Type(<i>regexp</i>) is Object and <i>regexp</i> has a [[NativeBrand]] internal property whose value is NativeRegExp, then let <i>rx</i> be <i>regexp</i>;</p>
      <p>Else, let <i>rx</i> be a new RegExp object created as if by the expression <b>new RegExp(</b><i>regexp</i><b>)</b> where <b>RegExp</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>global</i> be the result of calling the [[Get]] internal method of <i>rx</i> with argument <b>"global"</b>.</p>
      <p>Let <i>exec</i> be the standard built-in function <b>RegExp.prototype.exec</b> (see 15.10.6.2)</p>
      <p>If <i>global</i> is not <b>true</b>, then</p>
      <p>Return the result of calling the [[Call]] internal method of <i>exec</i> with <i>rx</i> as the <b>this</b> value and argument list containing <i>S</i>.</p>
      <p>Else, <i>global</i> is <b>true</b></p>
      <p>Call the [[Put]] internal method of <i>rx</i> with arguments <b>"lastIndex"</b> and 0.</p>
      <p>Let <i>A</i> be a new array created as if by the expression <b>new Array()</b> where <b>Array</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>previousLastIndex</i> be 0.</p>
      <p>Let <i>n</i> be 0.</p>
      <p>Let <i>lastMatch</i> be <b>true</b>.</p>
      <p>Repeat, while <i>lastMatch</i> is <b>true</b></p>
      <p>Let <i>result</i> be the result of calling the [[Call]] internal method of <i>exec</i> with <i>rx</i> as the <b>this</b> value and argument list containing <i>S</i>.</p>
      <p>If <i>result</i> is <b>null</b>, then set <i>lastMatch</i> to <b>false</b>.</p>
      <p>Else, <i>result</i> is not <b>null</b></p>
      <p>Let <i>thisIndex</i>  be the result of calling the [[Get]] internal method of <i>rx</i> with argument <b>"lastIndex"</b>.</p>
      <p>If <i>thisIndex</i> = <i>previousLastIndex</i> then</p>
      <p>Call the [[Put]] internal method of <i>rx</i> with arguments <b>"lastIndex"</b> and <i>thisIndex</i>+1.</p>
      <p>Set <i>previousLastIndex</i> to <i>thisIndex</i>+1.</p>
      <p>Else, set <i>previousLastIndex</i> to <i>thisIndex</i>.</p>
      <p>Let <i>matchStr</i> be the result of calling the [[Get]] internal method of <i>result</i> with argument <b>"0"</b>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments ToString(<i>n</i>), the Property Descriptor {[[Value]]: <i>matchStr</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Increment <i>n</i>.</p>
      <p>If <i>n</i> = 0, then return <b>null</b>.</p>
      <p>Return <i>A</i>.</p>
      <p>NOTE<span>	The </span><b>match</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.11<span>	String.prototype.replace (searchValue, replaceValue)</span></h2>
      <p>First set <i>string</i> according to the following steps:</p>
      <p>Call CheckObjectCoercible passing the <b>this</b> value as its argument.</p>
      <p>Let <i>string</i> be the result of calling ToString, giving it the <b>this</b> value as its argument.</p>
      <p>If <i>searchValue</i> is a regular expression (an object that has a [[NativeBrand]] internal property whose value is NativeRegExp), do the following: If <i>searchValue</i>.global is <b>false</b>, then search <i>string</i> for the first match of the regular expression <i>searchValue</i>. If <i>searchValue</i>.global is <b>true</b>, then search <i>string</i> for all matches of the regular expression <i>searchValue</i>. Do the search in the same manner as in <b>String.prototype.match</b>, including the update of <i>searchValue</i>.<b>lastIndex</b>. Let <i>m</i> be the number of left capturing parentheses in <i>searchValue</i> (using <i>NcapturingParens</i> as specified in 15.10.2.1).</p>
      <p>If <i>searchValue</i> is not a regular expression, let <i>searchString</i> be ToString(<i>searchValue</i>) and search <i>string</i> for the first occurrence of <i>searchString</i>. Let <i>m</i> be 0.</p>
      <p>If <i>replaceValue</i> is a function, then for each matched substring, call the function with the following <i>m</i> + 3 arguments. Argument 1 is the substring that matched. If <i>searchValue</i> is a regular expression, the next <i>m</i> arguments are all of the captures in the MatchResult (see 15.10.2.1). Argument <i>m</i> + 2 is the offset within <i>string</i> where the match occurred, and argument <i>m</i> + 3 is <i>string</i>. The result is a String value derived from the original input by replacing each matched substring with the corresponding return value of the function call, converted to a String if need be.</p>
      <p>Otherwise, let <i>newstring</i> denote the result of converting <i>replaceValue</i> to a String. The result is a String value derived from the original input String by replacing each matched substring with a String derived from <i>newstring</i> by replacing characters in <i>newstring</i> by replacement text as specified in Table 24. These <b>$</b> replacements are done left-to-right, and, once such a replacement is performed, the new replacement text is not subject to further replacements. For example, <b>"$1,$2".replace(/(\$(\d))/g, "$$1-$1$2")</b> returns <b>"$1-$11,$1-$22"</b>. A <b>$</b> in <i>newstring</i> that does not match any of the forms below is left as is.</p>
      <p>Table 24 — Replacement Text Symbol Substitutions</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>Characters</p>
            </td>
            <td>
              <p>Replacement text</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>$$</b>
              </p>
            </td>
            <td>
              <p>
                <b>$</b>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>$&amp;</b>
              </p>
            </td>
            <td>
              <p>The matched substring.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>$‘</b>
              </p>
            </td>
            <td>
              <p>The portion of <i>string</i> that precedes the matched substring.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>$’</b>
              </p>
            </td>
            <td>
              <p>The portion of <i>string</i> that follows the matched substring.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>$n</b>
              </p>
            </td>
            <td>
              <p>The <i>n</i><sup>th</sup> capture, where <i>n</i> is a single digit in the range 1 to 9 and <b>$</b><i>n</i> is not followed by a decimal digit. If <i>n</i>≤<i>m</i> and the <i>n</i>th capture is <b>undefined</b>, use the empty String instead. If <i>n</i>&gt;<i>m</i>, the result is implementation-defined.</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>$nn</b>
              </p>
            </td>
            <td>
              <p>The <i>nn</i><sup>th</sup> capture, where <i>nn</i> is a two-digit decimal number in the range 01 to 99. If <i>nn</i>≤<i>m</i> and the <i>nn</i><sup>th</sup> capture is <b>undefined</b>, use the empty String instead. If <i>nn</i>&gt;<i>m</i>, the result is implementation-defined.</p>
            </td>
          </tr>
        </table>
      </figure>
      <p>NOTE<span>	The </span><b>replace</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.12<span>	String.prototype.search (regexp)</span></h2>
      <p>When the search method is called with argument <i>regexp</i>, the following steps are taken:</p>
      <p>Call CheckObjectCoercible passing the <b>this</b> value as its argument.</p>
      <p>Let <i>string</i> be the result of calling ToString, giving it the <b>this</b> value as its argument.</p>
      <p>If Type(<i>regexp</i>) is Object and <i>regexp</i> has a [[NativeBrand]] internal property whose value is NativeRegExp , then let <i>rx</i> be <i>regexp</i>;</p>
      <p>Else, let <i>rx</i> be a new RegExp object created as if by the expression <b>new RegExp(</b><i>regexp</i><b>)</b> where <b>RegExp</b> is the standard built-in constructor with that name.</p>
      <p>Search the value <i>string</i> from its beginning for an occurrence of the regular expression pattern <i>rx</i>. Let <i>result</i> be a Number indicating the offset within <i>string</i> where the pattern matched, or –1 if there was no match. The<i> </i><b>lastIndex</b> and <b>global</b> properties of <i>regexp</i> are ignored when performing the search. The <b>lastIndex</b> property of <i>regexp</i> is left unchanged.</p>
      <p>Return <i>result</i>.</p>
      <p>NOTE<span>	The </span><b>search</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.13<span>	String.prototype.slice (start, end)</span></h2>
      <p>The <b>slice</b> method takes two arguments, <i>start</i> and <i>end</i>, and returns a substring of the result of converting this object to a String, starting from character position <i>start</i> and running to, but not including, character position <i>end</i> (or through the end of the String if <i>end</i> is <b>undefined</b>). If <i>start</i> is negative, it is treated as <i>sourceLength</i>+<i>start </i>where <i>sourceLength</i> is the length of the String. If <i>end</i> is negative, it is treated as <i>sourceLength</i>+<i>end</i> where <i>sourceLength</i> is the length of the String. The result is a String value, not a String object. The following steps are taken:</p>
      <p>Call CheckObjectCoercible passing the <b>this</b> value as its argument.</p>
      <p>Let <i>S</i> be the result of calling ToString, giving it the <b>this</b> value as its argument.</p>
      <p>Let <i>len</i> be the number of characters in <i>S</i>.</p>
      <p>Let <i>intStart</i> be ToInteger(<i>start</i>).</p>
      <p>If <i>end</i> is <b>undefined</b>, let <i>intEnd</i> be <i>len</i>; else let <i>intEnd</i> be ToInteger(<i>end</i>).</p>
      <p>If <i> intStart </i>is negative, let <i>from</i> be max(<i>len</i> +<i> intStart</i>,0); else let <i>from</i> be min(<i>intStart</i>,<i> len</i>).</p>
      <p>If <i>intEnd</i> is negative, let <i>to</i> be max(<i>len</i> +<i> intEnd</i>,0); else let <i>to</i> be min(<i>intEnd</i>,<i> len</i>).</p>
      <p>Let <i>span</i> be max(<i>to</i> –<i> from</i>,0).</p>
      <p>Return a String containing <i>span</i> consecutive characters from <i>S</i> beginning with the character at position <i>from</i>.</p>
      <p>The <b>length</b> property of the <b>slice</b> method is <b>2</b>.</p>
      <p>NOTE<span>	The </span><b>slice</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.14<span>	String.prototype.spli</span>t (separator, limit)</h2>
      <p>Returns an Array object into which substrings of the result of converting this object to a String have been stored. The substrings are determined by searching from left to right for occurrences of <i>separator</i>; these occurrences are not part of any substring in the returned array, but serve to divide up the String value. The value of <i>separator</i> may be a String of any length or it may be a RegExp object (i.e., an object with a [[NativeBrand]] internal property whose value is NativeRegExp ; see 15.10).</p>
      <p>The value of <i>separator</i> may be an empty String, an empty regular expression, or a regular expression that can match an empty String. In this case, <i>separator</i> does not match the empty substring at the beginning or end of the input String, nor does it match the empty substring at the end of the previous separator match. (For example, if <i>separator</i> is the empty String, the String is split up into individual characters; the length of the result array equals the length of the String, and each substring contains one character.) If <i>separator</i> is a regular expression, only the first match at a given position of the <b>this</b> String is considered, even if backtracking could yield a non-empty-substring match at that position. (For example, <b>"ab".split(/a*?/)</b> evaluates to the array <b>["a","b"]</b>, while <b>"ab".split(/a*/)</b> evaluates to the array<b>["","b"]</b>.)</p>
      <p>If the <b>this</b> object is (or converts to) the empty String, the result depends on whether <i>separator</i> can match the empty String. If it can, the result array contains no elements. Otherwise, the result array contains one element, which is the empty String.</p>
      <p>If <i>separator</i> is a regular expression that contains capturing parentheses, then each time <i>separator</i> is matched the results (including any <b>undefined</b> results) of the capturing parentheses are spliced into the output array. For example,</p>
      <p>
        <b>"A&lt;B&gt;bold&lt;/B&gt;and&lt;CODE&gt;coded&lt;/CODE&gt;".split(/&lt;(\/)?([^&lt;&gt;]+)&gt;/)</b>
      </p>
      <p>evaluates to the array</p>
      <p>
        <b>["A", undefined, "B", "bold", "/", "B", "and", undefined,</b>
        <b><br> "CODE", "coded", "/", "CODE", ""]</b>
      </p>
      <p>If <i>separator</i> is <b>undefined</b>, then the result array contains just one String, which is the <b>this</b> value (converted to a String). If <i>limit</i> is not <b>undefined</b>, then the output array is truncated so that it contains no more than <i>limit</i> elements.</p>
      <p>When the <b>split</b> method is called, the following steps are taken:</p>
      <p>Call CheckObjectCoercible passing the <b>this</b> value as its argument.</p>
      <p>Let <i>S</i> be the result of calling ToString, giving it the <b>this</b> value as its argument.</p>
      <p>Let <i>A</i> be a new array created as if by the expression <b>new Array()</b>where <b>Array</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>lengthA</i> be 0.</p>
      <p>If <i>limit</i> is <b>undefined</b>, let <i>lim</i> = 2<sup>32</sup>–1; else let <i>lim</i> = ToUint32(<i>limit</i>).</p>
      <p>Let <i>s</i> be the number of characters in <i>S</i>.</p>
      <p>Let <i>p</i> = 0.</p>
      <p>If <i>separator</i> has a [[NativeBrand]] internal property whose value is NativeRegExp , let <i>R</i> = <i>separator</i>; otherwise let <i>R</i> = ToString(<i>separator</i>).</p>
      <p>If <i>lim</i> = 0, return <i>A</i>.</p>
      <p>If <i>separator</i> is <b>undefined</b>, then</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments "<b>0</b>", Property Descriptor {[[Value]]: <i>S</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Return <i>A</i>.</p>
      <p>If <i>s</i> = 0, then</p>
      <p>Call <i>SplitMatch</i>(<i>S</i>, 0, <i>R</i>) and let <i>z</i> be its MatchResult result.</p>
      <p>If <i>z</i> is not <b>failure</b>, return <i>A</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments "<b>0</b>", Property Descriptor {[[Value]]: <i>S</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Return <i>A</i>.</p>
      <p>Let <i>q</i> = <i>p</i>.</p>
      <p>Repeat, while <i>q</i> ≠ <i>s</i></p>
      <p>Call <i>SplitMatch</i>(<i>S, q, R</i>) and let <i>z</i> be its MatchResult result.</p>
      <p>If <i>z</i> is <b>failure</b>, then let <i>q</i> = <i>q</i>+1.</p>
      <p>Else,  <i>z</i> is not <b>failure</b></p>
      <p><i>z</i> must be a State. Let <i>e</i> be <i>z</i>'s <i>endIndex</i> and let <i>cap</i> be <i>z</i>'s <i>captures</i> array.</p>
      <p>If <i>e</i> = <i>p</i>, then let <i>q</i> = <i>q</i>+1.</p>
      <p>Else, <i>e</i> ≠ <i>p</i></p>
      <p>Let <i>T</i> be a String value equal to the substring of <i>S</i> consisting of the characters at positions <i>p</i> (inclusive) through <i>q</i> (exclusive).</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments ToString(<i>lengthA</i>), Property Descriptor {[[Value]]: <i>T</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Increment <i>lengthA</i> by 1.</p>
      <p>If <i>lengthA</i> = <i>lim</i>, return <i>A</i>.</p>
      <p>Let p = e.</p>
      <p>Let <i>i</i> = 0.</p>
      <p>Repeat, while <i>i</i> is not equal to the number of elements in <i>cap</i>.</p>
      <p>Let <i>i</i> = <i>i</i>+1.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments ToString(<i>lengthA</i>), Property Descriptor {[[Value]]: <i>cap</i>[<i>i</i>], [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Increment <i>lengthA</i> by 1.</p>
      <p>If <i>lengthA</i><i> </i>= <i>lim</i>, return <i>A</i>.</p>
      <p>Let <i>q</i> = <i>p</i>.</p>
      <p>Let <i>T</i> be a String value equal to the substring of <i>S</i> consisting of the characters at positions <i>p</i> (inclusive) through <i>s</i> (exclusive).</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments ToString(<i>lengthA</i>), Property Descriptor {[[Value]]: <i>T</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Return <i>A</i>.</p>
      <p>The abstract operation <i>SplitMatch</i> takes three parameters, a String <i>S</i>, an integer <i>q</i>, and a String or RegExp <i>R</i>, and performs the following in order to return a MatchResult (see 15.10.2.1):</p>
      <p>If <i>R</i> has a [[NativeBrand]] internal property whose value is NativeRegExp , then</p>
      <p>Call the [[Match]] internal method of <i>R</i> giving it the arguments <i>S</i> and <i>q</i>, and return the MatchResult result.</p>
      <p>Type(<i>R</i>) must be String. Let <i>r</i> be the number of characters in <i>R</i>.</p>
      <p>Let <i>s</i> be the number of characters in <i>S</i>.</p>
      <p>If <i>q</i>+<i>r</i> &gt; <i>s</i> then return the MatchResult <b>failure</b>.</p>
      <p>If there exists an integer <i>i</i> between 0 (inclusive) and <i>r</i> (exclusive) such that the character at position <i>q</i>+<i>i</i> of <i>S</i> is different from the character at position <i>i</i> of <i>R</i>, then return <b>failure</b>.</p>
      <p>Let <i>cap</i> be an empty array of captures (see 15.10.2.1).</p>
      <p>Return the State (<i>q</i>+<i>r</i>, <i>cap</i>). (see 15.10.2.1)</p>
      <p>The <b>length</b> property of the <b>split</b> method is <b>2</b>.</p>
      <p>NOTE 1<span>	The </span><b>split</b> method ignores the value of separator<b>.global</b> for separators that are RegExp objects.</p>
      <p>NOTE 2<span>	The </span><b>split</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.15<span>	String.prototype.substrin</span>g (start, end)</h2>
      <p>The <b>substring</b> method takes two arguments, <i>start</i> and <i>end</i>, and returns a substring of the result of converting this object to a String, starting from character position <i>start</i> and running to, but not including, character position <i>end</i> of the String (or through the end of the String is <i>end</i> is <b>undefined</b>). The result is a String value, not a String object.</p>
      <p>If either argument is <b>NaN</b> or negative, it is replaced with zero; if either argument is larger than the length of the String, it is replaced with the length of the String.</p>
      <p>If <i>start</i> is larger than <i>end</i>, they are swapped.</p>
      <p>The following steps are taken:</p>
      <p>Call CheckObjectCoercible passing the <b>this</b> value as its argument.</p>
      <p>Let <i>S</i> be the result of calling ToString, giving it the <b>this</b> value as its argument.</p>
      <p>Let <i>len</i> be the number of characters in <i>S</i>.</p>
      <p>Let <i>intStart</i> be ToInteger(<i>start</i>).</p>
      <p>If <i>end</i> is <b>undefined</b>, let <i>intEnd</i> be <i>len</i>; else let <i>intEnd</i> be ToInteger(<i>end</i>).</p>
      <p>Let <i>finalStart</i> be min(max(<i>intStart</i>, 0), <i>len</i>).</p>
      <p>Let <i>finalEnd</i> be min(max(<i>intEnd</i>, 0), <i>len</i>).</p>
      <p>Let <i>from</i> be min(<i>finalStart</i>, <i>finalEnd</i>).</p>
      <p>Let <i>to</i> be max(<i>finalStart</i>, <i>finalEnd</i>).</p>
      <p>Return a String whose length is <i>to</i> - <i>from</i>, containing characters from <i>S</i>, namely the characters with indices <i>from</i> through <i>to</i> −1, in ascending order.</p>
      <p>The <b>length</b> property of the <b>substring</b> method is <b>2</b>.</p>
      <p>NOTE<span>	The </span><b>substring</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.16<span>	String.prototype.toLowerCase ( )</span></h2>
      <p>The following steps are taken:</p>
      <p>Call CheckObjectCoercible passing the <b>this</b> value as its argument.</p>
      <p>Let <i>S</i> be the result of calling ToString, giving it the <b>this</b> value as its argument.</p>
      <p>Let <i>L</i> be a String where each character of <i>L</i> is either the Unicode lowercase equivalent of the corresponding character of <i>S</i> or the actual corresponding character of <i>S</i> if no Unicode lowercase equivalent exists.</p>
      <p>Return <i>L</i>.</p>
      <p>For the purposes of this operation, the 16-bit code units of the Strings are treated as code points in the Unicode Basic Multilingual Plane. Surrogate code points are directly transferred from <i>S</i> to <i>L</i> without any mapping.</p>
      <p>The result must be derived according to the case mappings in the Unicode character database (this explicitly includes not only the UnicodeData.txt file, but also the SpecialCasings.txt file that accompanies it in Unicode 2.1.8 and later).</p>
      <p>NOTE 1<span>	The case mapping of some characters may produce multiple characters.  In this case the result String may not be the same length as the source String. Because both </span><b>toUpperCase</b> and <b>toLowerCase</b> have context-sensitive behaviour, the functions are not symmetrical. In other words, <b>s.toUpperCase().toLowerCase()</b> is not necessarily equal to <b>s.toLowerCase()</b>.</p>
      <p>NOTE 2<span>	The </span><b>toLowerCase</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.17<span>	String.prototype.toLocaleLowerCase ( )</span></h2>
      <p>This function works exactly the same as <b>toLowerCase</b> except that its result is intended to yield the correct result for the host environment’s current locale, rather than a locale-independent result. There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.</p>
      <p>NOTE 1<span>	The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.</span></p>
      <p>NOTE 2<span>	The </span><b>toLocaleLowerCase</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.18<span>	String.prototype.toUpperCas</span>e ( )</h2>
      <p>This function behaves in exactly the same way as <b>String.prototype.toLowerCase</b>, except that characters are mapped to their <i>uppercase</i> equivalents as specified in the Unicode Character Database.</p>
      <p>NOTE<span>	The </span><b>toUpperCase</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.19<span>	String.prototype.toLocaleUpperCase ( )</span></h2>
      <p>This function works exactly the same as <b>toUpperCase</b> except that its result is intended to yield the correct result for the host environment’s current locale, rather than a locale-independent result. There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.</p>
      <p>NOTE 1<span>	The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.</span></p>
      <p>NOTE 2<span>	The </span><b>toLocaleUpperCase</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.4.20<span>	String.prototype.trim ( )</span></h2>
      <p>The following steps are taken:</p>
      <p>Call CheckObjectCoercible passing the <b>this</b> value as its argument.</p>
      <p>Let <i>S</i> be the result of calling ToString, giving it the <b>this</b> value as its argument.</p>
      <p>Let <i>T</i> be a String value that is a copy of <i>S</i> with both leading and trailing white space removed. The definition of white space is the union of <i>WhiteSpace </i>and <i>LineTerminator</i>.</p>
      <p>Return <i>T</i>.</p>
      <p>NOTE<span>	The </span><b>trim</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
      <h2>15.5.5<span>	Properties of String Instance</span>s</h2>
      <p>String instances inherit properties from the String prototype object and have a [[NativeBrand]] internal property with value StringWrapper. String instances also have a [[PrimitiveValue]] internal property, a <b>length</b> property, and a set of enumerable properties with array index names.</p>
      <p>The [[PrimitiveValue]] internal property is the String value represented by this String object. The array index named properties correspond to the individual characters of the String value. A special [[GetOwnProperty]] internal method is used to specify the number, values, and attributes of the array index named properties. </p>
      <h2>15.5.5.1<span>	lengt</span>h</h2>
      <p>The number of characters in the String value represented by this String object.</p>
      <p>Once a String object is created, this property is unchanging. It has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.5.5.2<span>	[[GetOwnProperty]] ( P )</span></h2>
      <p>String objects use a variation of the [[GetOwnProperty]] internal method used for other native ECMAScript objects (8.12.1). This special internal method provides access to named properties corresponding to the individual characters of String objects.</p>
      <p>Assume <i>S </i>is a String object and <i>P </i>is a String.</p>
      <p>When the [[GetOwnProperty]] internal method of <i>S </i>is called with property name <i>P</i>, the following steps are taken:</p>
      <p>Let <i>desc</i> be the result of calling the default [[GetOwnProperty]] internal method (8.12.1) on <i>S </i>with argument <i>P</i>.</p>
      <p>If <i>desc</i> is not <b>undefined </b>return <i>desc</i>. </p>
      <p>If ToString(abs(ToInteger(<i>P</i>))) is not the same value as <i>P</i>, return <b>undefined</b>.</p>
      <p>Let <i>str</i> be the String value of the [[PrimitiveValue]] internal property of <i>S</i>.</p>
      <p>Let <i>index</i> be ToInteger(<i>P</i>).</p>
      <p>Let <i>len</i> be the number of characters in <i>str</i>.</p>
      <p>If <i>len</i> ≤ <i>index</i>, return <b>undefined</b>.</p>
      <p>Let <i>resultStr</i> be a String of length 1, containing one character from <i>str</i>, specifically the character at position <i>index</i>, where the first (leftmost) character in <i>str</i> is considered to be at position 0, the next one at position 1, and so on.</p>
      <p>Return a Property Descriptor { [[Value]]: <i>resultStr</i>, [[Enumerable]]: <b>true</b>, [[Writable]]: <b>false</b>, [[Configurable]]: <b>false </b>}</p>
      <h2>15.6<span>	Boolean</span> Objects</h2>
      <h2>15.6.1<span>	The Boolean Constructor Called as a Functio</span>n</h2>
      <p>When <b>Boolean</b> is called as a function rather than as a constructor, it performs a type conversion.</p>
      <h2>15.6.1.1<span>	Boolean (value</span>)</h2>
      <p>Returns a Boolean value (not a Boolean object) computed by ToBoolean(<i>value</i>).</p>
      <h2>15.6.2<span>	The Boolean Constructo</span>r</h2>
      <p>When <b>Boolean</b> is called as part of a <b>new</b> expression it is a constructor: it initialises the newly created object.</p>
      <h2>15.6.2.1<span>	new Boolean (value</span>)</h2>
      <p>The [[Prototype]] internal property of the newly constructed object is set to the original Boolean prototype object, the one that is the initial value of <b>Boolean.prototype</b> (15.6.3.1).</p>
      <p>The newly constructed Boolean object has a [[NativeBrand]] internal property with value BooleanWrapper.</p>
      <p>The [[PrimitiveValue]] internal property of the newly constructed Boolean object is set to ToBoolean(<i>value</i>).</p>
      <p>The [[Extensible]] internal property of the newly constructed object is set to <b>true</b>.</p>
      <h2>15.6.3<span>	Properties of the Boolean Constructo</span>r</h2>
      <p>The value of the [[Prototype]] internal property of the Boolean constructor is the Function prototype object (15.3.4).</p>
      <p>Besides the internal properties and the <b>length</b> property (whose value is <b>1</b>), the Boolean constructor has the following property:</p>
      <h2>15.6.3.1<span>	Boolean.prototyp</span>e</h2>
      <p>The initial value of <b>Boolean.prototype</b> is the Boolean prototype object (15.6.4).</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.6.4<span>	Properties of the Boolean Prototype Objec</span>t</h2>
      <p>The Boolean prototype object is itself a Boolean object  whose value is <b>false</b>. The Boolean prototype object has a [[NativeBrand]] internal property whose value is BooleanWrapper.</p>
      <p>The value of the [[Prototype]] internal property of the Boolean prototype object is the standard built-in Object prototype object (15.2.4).</p>
      <h2>15.6.4.1<span>	Boolean.prototype.constructo</span>r</h2>
      <p>The initial value of <b>Boolean.prototype.constructor</b> is the built-in <b>Boolean</b> constructor.</p>
      <h2>15.6.4.2<span>	Boolean.prototype.toString</span> ( )</h2>
      <p>The following steps are taken:</p>
      <p>Let <i>B</i> be the <b>this</b> value.</p>
      <p>If Type(<i>B</i>) is Boolean, then let <i>b</i> be <i>B</i>.</p>
      <p>Else if Type(<i>B</i>) is Object and <i>B</i> has a [[NativeWrapper]] internal property whose value is BooleanWrapper, then let <i>b</i> be the value of the [[PrimitiveValue]] internal property of <i>B</i>.</p>
      <p>Else throw a <b>TypeError</b> exception.</p>
      <p>If <i>b</i> is <b>true</b>, then return <b>"true"</b>; else return <b>"false"</b>.</p>
      <h2>15.6.4.3<span>	Boolean.prototype.valueOf</span> ( )</h2>
      <p>The following steps are taken:</p>
      <p>Let <i>B</i> be the <b>this</b> value.</p>
      <p>If Type(<i>B</i>) is Boolean, then let <i>b</i> be <i>B</i>.</p>
      <p>Else if Type(<i>B</i>) is Object and <i>B</i> has a [[NativeWrapper]] internal property whose value is BooleanWrapper, then let <i>b</i> be the value of the [[PrimitiveValue]] internal property of <i>B</i>.</p>
      <p>Else throw a <b>TypeError</b> exception.</p>
      <p>Return <i>b</i>.</p>
      <h2>15.6.5<span>	Properties of Boolean Instance</span>s</h2>
      <p>Boolean instances inherit properties from the Boolean prototype object and have a [[NativeBrand]] internal property whose value is BooleanWrapper. Boolean instances also have a [[PrimitiveValue]] internal property.</p>
      <p>The [[PrimitiveValue]] internal property is the Boolean value represented by this Boolean object.</p>
      <h2>15.7<span>	Number</span> Objects</h2>
      <h2>15.7.1<span>	The Number Constructor Called as a Functio</span>n</h2>
      <p>When <b>Number</b> is called as a function rather than as a constructor, it performs a type conversion.</p>
      <h2>15.7.1.1<span>	Number ( [ value</span> ] )</h2>
      <p>Returns a Number value (not a Number object) computed by ToNumber(<i>value</i>) if <i>value</i> was supplied, else returns <b>+0</b>.</p>
      <h2>15.7.2<span>	The Number Constructo</span>r</h2>
      <p>When <b>Number</b> is called as part of a <b>new</b> expression it is a constructor: it initialises the newly created object.</p>
      <h2>15.7.2.1<span>	new Number ( [ value</span> ] )</h2>
      <p>The [[Prototype]] internal property of the newly constructed object is set to the original Number prototype object, the one that is the initial value of <b>Number.prototype</b> (15.7.3.1).</p>
      <p>The newly constructed object is has a [[NativeBrand]] internal property whose value is NumberWrapper.</p>
      <p>The [[PrimitiveValue]] internal property of the newly constructed object is set to ToNumber(<i>value</i>) if <i>value</i> was supplied, else to +0.</p>
      <p>The [[Extensible]] internal property of the newly constructed object is set to <b>true</b>.</p>
      <h2>15.7.3<span>	Properties of the Number</span> Constructor</h2>
      <p>The value of the [[Prototype]] internal property of the Number constructor is the Function prototype object (15.3.4).</p>
      <p>Besides the internal properties and the <b>length</b> property (whose value is <b>1</b>), the Number constructor has the following properties:</p>
      <h2>15.7.3.1<span>	Number.prototyp</span>e</h2>
      <p>The initial value of <b>Number.prototype</b> is the Number prototype object (15.7.4).</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.7.3.2<span>	Number.MAX_VALU</span>E</h2>
      <p>The value of <b>Number.MAX_VALUE</b> is the largest positive finite value of the Number type, which is approximately 1.7976931348623157 × 10<sup>308</sup>.</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.7.3.3<span>	Number.MIN_VALU</span>E</h2>
      <p>The value of <b>Number.MIN_VALUE</b> is the smallest positive value of the Number type, which is approximately 5 × 10<sup>324</sup>.</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.7.3.4<span>	Number.Na</span>N</h2>
      <p>The value of <b>Number.NaN</b> is <b>NaN</b>.</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.7.3.5<span>	Number.NEGATIVE_INFINIT</span>Y</h2>
      <p>The value of Number.NEGATIVE_INFINITY is −∞.</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.7.3.6<span>	Number.POSITIVE_INFINIT</span>Y</h2>
      <p>The value of Number.POSITIVE_INFINITY is +∞.</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.7.4<span>	Properties of the Number Prototype Objec</span>t</h2>
      <p>The Number prototype object is itself a Number object with a [[NativeBrand]] internal property whose value is NumberWrapper. Its value is +0.</p>
      <p>The value of the [[Prototype]] internal property of the Number prototype object is the standard built-in Object prototype object (15.2.4).</p>
      <p>Unless explicitly stated otherwise, the methods of the Number prototype object defined below are not generic and the this value passed to them must be either a Number value or an object that has a [[NativeBrand]] internal property whose value is NumberWrapper.</p>
      <p>In the following descriptions of functions that are properties of the Number prototype object, the phrase “this Number object” refers to either the object that is the <b>this</b> value for the invocation of the function or, if Type(<b>this</b> value) is Number,  an object that is created as if by the expression <b>new Number(</b><b>this</b> value<b>)</b> where <b>Number</b> is the standard built-in constructor with that name.  Also, the phrase “this Number value” refers to either the Number value represented by this Number object, that is, the value of the [[PrimitiveValue]] internal property of this Number object or the <b>this</b> value if its type is Number.  A <b>TypeError</b> exception is thrown if the <b>this</b> value is neither an object that has a [[NativeBrand]] internal property whose value is NumberWrapper or a value whose type is Number.</p>
      <h2>15.7.4.1<span>	Number.prototype.constructo</span>r</h2>
      <p>The initial value of <b>Number.prototype.constructor</b> is the built-in <b>Number</b> constructor.</p>
      <h2>15.7.4.2<span>	Number.prototype.toString ( [ radix</span> ] )</h2>
      <p>The optional <i>radix</i> should be an integer value in the inclusive range 2 to 36. If <i>radix</i> not present or is <b>undefined</b> the Number 10 is used as the value of <i>radix</i>. If ToInteger(<i>radix</i>) is the Number 10 then this Number value is given as an argument to the ToString abstract operation; the resulting String value is returned.</p>
      <p>If ToInteger(<i>radix</i>) is not an integer between 2 and 36 inclusive throw a <b>RangeError</b> exception. If ToInteger(<i>radix</i>) is an integer from 2 to 36, but not 10, the result is a String representation of this Number value using the specified radix. Letters <b>a</b>-<b>z</b> are used for digits with values 10 through 35. The precise algorithm is implementation-dependent if the radix is not 10, however the algorithm should be a generalisation of that specified in 9.8.1.</p>
      <p>The <b>toString</b> function is not generic; it throws a <b>TypeError</b> exception if its <b>this</b> value is not a Number or a Number object. Therefore, it cannot be transferred to other kinds of objects for use as a method.</p>
      <h2>15.7.4.3<span>	Number.prototype.toLocaleString()</span></h2>
      <p>Produces a String value that represents this Number value formatted according to the conventions of the host environment’s current locale. This function is implementation-dependent, and it is permissible, but not encouraged, for it to return the same thing as <b>toString</b>.</p>
      <p>NOTE<span>	The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.</span></p>
      <h2>15.7.4.4<span>	Number.prototype.valueOf</span> ( )</h2>
      <p>Returns this Number value.</p>
      <p>The <b>valueOf</b> function is not generic; it throws a <b>TypeError</b> exception if its <b>this</b> value is not a Number or a Number object. Therefore, it cannot be transferred to other kinds of objects for use as a method.</p>
      <h2>15.7.4.5<span>	Number.prototype.toFixed (fractionDigits)</span></h2>
      <p>Return a String containing this Number value represented in decimal fixed-point notation with <i>fractionDigits</i> digits after the decimal point. If <i>fractionDigits</i> is <b>undefined</b>, 0 is assumed. Specifically, perform the following steps:</p>
      <p>Let <i>f</i> be ToInteger(<i>fractionDigits</i>). (If <i>fractionDigits</i> is <b>undefined</b>, this step produces the value <b>0</b>).</p>
      <p>If <i>f</i> &lt; 0 or <i>f</i> &gt; 20, throw a <b>RangeError</b> exception.</p>
      <p>Let <i>x</i> be this Number value.</p>
      <p>If <i>x</i> is <b>NaN</b>, return the String <b>"NaN"</b>.</p>
      <p>Let <i>s</i> be the empty String.</p>
      <p>If <i>x</i> &lt; 0, then</p>
      <p>Let s be "<b>-</b>".</p>
      <p>Let x = –x.</p>
      <p>If <i>x</i> ≥ 10<sup>21</sup>, then</p>
      <p>Let <i>m</i> = ToString(<i>x</i>).</p>
      <p>Else, <i>x</i> &lt; 10<sup>21</sup></p>
      <p>Let <i>n</i> be an integer for which the exact mathematical value of <i>n</i> ÷ 10<sup>f</sup> – <i>x</i> is as close to zero as possible. If there are two such <i>n</i>, pick the larger <i>n</i>.</p>
      <p>If <i>n</i> = 0, let <i>m</i> be the String <b>"0"</b>. Otherwise, let <i>m</i> be the String consisting of the digits of the decimal representation of <i>n</i> (in order, with no leading zeroes).</p>
      <p>If <i>f</i> ≠ 0, then</p>
      <p>Let <i>k</i> be the number of characters in <i>m</i>.</p>
      <p>If <i>k</i> ≤ <i>f</i>, then</p>
      <p>Let <i>z</i> be the String consisting of <i>f</i>+1–<i>k</i> occurrences of the character ‘0’.</p>
      <p>Let <i>m</i> be the concatenation of Strings <i>z</i> and <i>m</i>.</p>
      <p>Let <i>k</i> = <i>f </i>+ 1.</p>
      <p>Let <i>a</i> be the first <i>k</i>–<i>f</i> characters of <i>m</i>, and let <i>b</i> be the remaining <i>f</i> characters of <i>m</i>.</p>
      <p>Let <i>m</i> be the concatenation of the three Strings <i>a</i>, <b>"."</b>, and <i>b</i>.</p>
      <p>Return the concatenation of the Strings <i>s</i> and <i>m</i>.</p>
      <p>The <b>length</b> property of the <b>toFixed</b> method is <b>1</b>.</p>
      <p>If the <b>toFixed</b> method is called with more than one argument, then the behaviour is undefined (see clause 15).</p>
      <p>An implementation is permitted to extend the behaviour of <b>toFixed</b> for values of <i>fractionDigits</i> less than 0 or greater than 20. In this case <b>toFixed</b> would not necessarily throw <b>RangeError</b> for such values.</p>
      <p>NOTE<span>	The output of </span><b>toFixed</b> may be more precise than <b>toString</b> for some values because toString only prints enough significant digits to distinguish the number from adjacent number values. For example, </p>
      <p>(<b>1000000000000000128).toString()</b> returns <b>"1000000000000000100"</b>,<span><br>while (</span><b>1000000000000000128).toFixed(0)</b> returns <b>"</b><b>1000000000000000128"</b>.</p>
      <h2>15.7.4.6<span>	Number.prototype.toExponential (fractionDigits)</span></h2>
      <p>Return a String containing this Number value represented in decimal exponential notation with one digit before the significand's decimal point and <i>fractionDigits</i> digits after the significand's decimal point. If <i>fractionDigits</i> is <b>undefined</b>, include as many significand digits as necessary to uniquely specify the Number (just like in ToString except that in this case the Number is always output in exponential notation). Specifically, perform the following steps:</p>
      <p>Let <i>x</i> be this Number value.</p>
      <p>Let <i>f</i> be ToInteger(<i>fractionDigits</i>).</p>
      <p>If <i>x</i> is <b>NaN</b>, return the String <b>"NaN"</b>.</p>
      <p>Let <i>s</i> be the empty String.</p>
      <p>If <i>x</i> <i>&lt;</i> 0, then</p>
      <p>Let <i>s</i> be <b>"-"</b>.</p>
      <p>Let <i>x</i> = –<i>x</i>.</p>
      <p>If <i>x</i> = +∞, then</p>
      <p>Return the concatenation of the Strings <i>s</i> and <b>"Infinity"</b>. </p>
      <p>If <i>fractionDigits</i> is not <b>undefined</b> and  (<i>f</i> &lt; 0 or <i>f</i> &gt; 20), throw a <b>RangeError</b> exception.</p>
      <p>If <i>x</i> = 0, then</p>
      <p>Let <i>f</i> = 0.</p>
      <p>Let <i>m</i> be the String consisting of <i>f</i>+1 occurrences of the character ‘0’.</p>
      <p>Let <i>e</i> = 0.</p>
      <p>Else, <i>x</i> ≠ 0</p>
      <p>If fractionDigits is not <b>undef</b><b>ined</b>, then</p>
      <p>Let <i>e</i> and <i>n</i> be integers such that 10<span style="vertical-align: super; font-style: italic">f</span> ≤ <i>n</i> &lt; 10<span style="vertical-align: super; font-style: italic">f</span><sup>+1</sup> and for which the exact mathematical value of <i>n</i> × 10<span style="vertical-align: super; font-style: italic">e</span><sup>–</sup><span style="vertical-align: super; font-style: italic">f</span> – <i>x</i> is as close to zero as possible. If there are two such sets of <i>e</i> and <i>n</i>, pick the <i>e</i> and <i>n</i> for which <i>n</i> × 10<span style="vertical-align: super; font-style: italic">e</span><sup>–</sup><span style="vertical-align: super; font-style: italic">f</span> is larger.</p>
      <p>Else, <i>fractionD</i><i>igits</i> is <b>undefined</b> </p>
      <p>Let <i>e</i>, <i>n</i>, and <i>f</i> be integers such that <i>f</i> ≥ 0, 10<span style="vertical-align: super; font-style: italic">f</span> ≤ <i>n</i> &lt; 10<span style="vertical-align: super; font-style: italic">f</span><sup>+1</sup>, the number value for n × 10<span style="vertical-align: super; font-style: italic">e</span><sup>–</sup><span style="vertical-align: super; font-style: italic">f</span> is <i>x</i>, and <i>f</i> is as small as possible. Note that the decimal representation of <i>n</i> has <i>f</i>+1 digits, <i>n</i> is not divisible by 10, and the least significant digit of <i>n</i> is not necessarily uniquely determined by these criteria.</p>
      <p>Let <i>m</i> be the String consisting of the digits of the decimal representation of <i>n</i> (in order, with no leading zeroes).</p>
      <p>If <i>f</i> ≠ 0, then</p>
      <p>Let <i>a</i> be the first character of <i>m</i>, and let <i>b</i> be the remaining <i>f</i> characters of <i>m</i>.</p>
      <p>Let <i>m</i> be the concatenation of the three Strings <i>a</i>, <b>"."</b>, and <i>b</i>.</p>
      <p>If <i>e</i> = 0, then </p>
      <p>Let <i>c</i> = <b>"+".</b></p>
      <p>Let <i>d</i> = <b>"0".</b></p>
      <p>Else</p>
      <p>If <i>e</i> &gt; 0, then let <i>c</i> = <b>"+".</b></p>
      <p>Else, <i>e</i> ≤ 0</p>
      <p>Let <i>c</i> = <b>"-"</b>.</p>
      <p>Let <i>e</i> = –<i>e</i>.</p>
      <p>Let <i>d</i> be the String consisting of the digits of the decimal representation of <i>e</i> (in order, with no leading zeroes).</p>
      <p>Let <i>m</i> be the concatenation of the four Strings <i>m</i>, <b>"e"</b>, <i>c</i>, and <i>d</i>.</p>
      <p>Return the concatenation of the Strings <i>s</i> and <i>m</i>.</p>
      <p>The <b>length</b> property of the <b>toExponential</b> method is <b>1</b>.</p>
      <p>If the <b>toExponential</b> method is called with more than one argument, then the behaviour is undefined (see clause 15).</p>
      <p>An implementation is permitted to extend the behaviour of <b>toExponential</b> for values of <i>fractionDigits</i> less than 0 or greater than 20. In this case <b>toExponential</b> would not necessarily throw <b>RangeError</b> for such values.</p>
      <p>NOTE<span>	For implementations that provide more accurate conversions than required by the rules above, it is recommended that the following alternative version of step 9.b.i be used as a guideline:</span></p>
      <p>Let <i>e</i>, <i>n</i>, and <i>f </i>be integers such that <i>f</i> ≥ 0, 10<span style="vertical-align: super; font-style: italic">f</span> ≤ n &lt; 10<span style="vertical-align: super; font-style: italic">f</span><sup>+1</sup>, the number value for n × 10<span style="vertical-align: super; font-style: italic">e</span><sup>–</sup><span style="vertical-align: super; font-style: italic">f</span> is x, and <i>f</i> is as small as possible. If there are multiple possibilities for <i>n</i>, choose the value of <i>n</i> for which <i>n</i> × 10<span style="vertical-align: super; font-style: italic">e</span><sup>–</sup><span style="vertical-align: super; font-style: italic">f</span> is closest in value to <i>x</i>. If there are two such possible values of <i>n</i>, choose the one that is even.</p>
      <h2>15.7.4.7<span>	Number.prototype.toPrecision (precision)</span></h2>
      <p>Return a String containing this Number value represented either in decimal exponential notation with one digit before the significand's decimal point and <i>precision</i>–1 digits after the significand's decimal point or in decimal fixed notation with <i>precision</i> significant digits. If <i>precision</i> is <b>undefined</b>, call ToString (9.8.1) instead. Specifically, perform the following steps:</p>
      <p>Let <i>x</i> be this Number value.</p>
      <p>If <i>precision</i> is <b>undefined</b>, return ToString(<i>x</i>).</p>
      <p>Let <i>p</i> be ToInteger(<i>precision</i>).</p>
      <p>If <i>x</i> is <b>NaN</b>, return the String <b>"NaN"</b>.</p>
      <p>Let <i>s</i> be the empty String.</p>
      <p>If <i>x</i> &lt; 0, then</p>
      <p>Let <i>s</i> be <b>"-"</b>.</p>
      <p>Let <i>x</i> = –<i>x</i>.</p>
      <p>If <i>x</i> = +∞, then</p>
      <p>Return the concatenation of the Strings <i>s</i> and <b>"Infinity"</b>.</p>
      <p>If <i>p</i> &lt; 1 or <i>p</i> &gt; 21, throw a <b>RangeError</b> exception.</p>
      <p>If <i>x</i> = 0, then</p>
      <p>Let <i>m</i> be the String consisting of <i>p</i> occurrences of the character ‘0’.</p>
      <p>Let <i>e</i> = 0.</p>
      <p>Else <i>x</i> ≠ 0,</p>
      <p>Let <i>e</i> and <i>n</i> be integers such that 10<span style="vertical-align: super; font-style: italic">p</span><sup>–1</sup> ≤ <i>n</i> &lt; 10<span style="vertical-align: super; font-style: italic">p</span> and for which the exact mathematical value of <i>n</i> × 10<span style="vertical-align: super; font-style: italic">e</span><sup>–</sup><span style="vertical-align: super; font-style: italic">p</span><sup>+1</sup> – <i>x</i> is as close to zero as possible. If there are two such sets of <i>e</i> and <i>n</i>, pick the <i>e</i> and <i>n</i> for which <i>n</i> × 10<span style="vertical-align: super; font-style: italic">e</span><sup>–</sup><span style="vertical-align: super; font-style: italic">p</span><sup>+1</sup> is larger.</p>
      <p>Let <i>m</i> be the String consisting of the digits of the decimal representation of <i>n</i> (in order, with no leading zeroes).</p>
      <p>If <i>e</i> &lt; –6 or <i>e</i> ≥ <i>p</i>, then</p>
      <p>Let <i>a</i> be the first character of <i>m</i>, and let <i>b</i> be the remaining <i>p</i>–1 characters of <i>m</i>.</p>
      <p>Let <i>m</i> be the concatenation of the three Strings <i>a</i>, <b>"."</b>, and <i>b</i>.</p>
      <p>If <i>e</i> = 0, then</p>
      <p>Let <i>c</i> = <b>"+"</b> and <i>d</i> = <b>"0"</b>.</p>
      <p>Else <i>e</i> ≠ 0,</p>
      <p>If <i>e</i> &gt; 0,  then </p>
      <p>Let <i>c</i> = <b>"+"</b>.</p>
      <p>Else <i>e</i> &lt; 0,</p>
      <p>Let <i>c</i> = <b>"-"</b>.</p>
      <p>Let <i>e</i> = –<i>e</i>.</p>
      <p>Let <i>d</i> be the String consisting of the digits of the decimal representation of <i>e</i> (in order, with no leading zeroes).</p>
      <p>Let <i>m</i> be the concatenation of the five Strings <i>s</i>, <i>m</i>, <b>"e"</b>, <i>c</i>, and <i>d</i>.</p>
      <p>If <i>e</i> = <i>p</i>–1, then return the concatenation of the Strings <i>s</i> and <i>m</i>.</p>
      <p>If <i>e</i> ≥ 0, then</p>
      <p>Let <i>m</i> be the concatenation of the first <i>e</i>+1 characters of <i>m</i>, the character ‘.’, and the remaining <i>p</i>– (<i>e</i>+1) characters of <i>m</i>.</p>
      <p>Else <i>e</i> &lt; 0,</p>
      <p>Let <i>m</i> be the concatenation of the String <b>"0."</b>, –(<i>e</i>+1) occurrences of the character ‘<b>0</b>’, and the String <i>m</i>.</p>
      <p>Return the concatenation of the Strings <i>s</i> and <i>m</i>.</p>
      <p>The <b>length</b> property of the <b>toPrecision</b> method is <b>1</b>.</p>
      <p>If the <b>toPrecision</b> method is called with more than one argument, then the behaviour is undefined (see clause 15).</p>
      <p>An implementation is permitted to extend the behaviour of <b>toPrecision</b> for values of <i>precision</i> less than 1 or greater than 21. In this case <b>toPrecision</b> would not necessarily throw <b>RangeError</b> for such values.</p>
      <h2>15.7.5<span>	Properties of Number Instance</span>s</h2>
      <p>Number instances inherit properties from the Number prototype object and have a [[NativeBrand]] internal property whose value is NumberWrapper. Number instances also have a [[PrimitiveValue]] internal property.</p>
      <p>The [[PrimitiveValue]] internal property is the Number value represented by this Number object.</p>
      <h2>15.8<span>	The Math Objec</span>t</h2>
      <p>The Math object is a single object that has some named properties, some of which are functions.</p>
      <p>The value of the [[Prototype]] internal property of the Math object is the standard built-in Object prototype object (15.2.4). The Math object has a [[NativeBrand]] internal property whose value is NativeMath.</p>
      <p>The Math object does not have a [[Construct]] internal property; it is not possible to use the Math object as a constructor with the <b>new</b> operator.</p>
      <p>The Math object does not have a [[Call]] internal property; it is not possible to invoke the Math object as a function.</p>
      <p>NOTE<span>	In this specification, the phrase “the Number value for </span><i>x</i>” has a technical meaning defined in 8.5.</p>
      <h2>15.8.1<span>	Value Properties of the Math Objec</span>t</h2>
      <h2>15.8.1.1<span>	E</span></h2>
      <p>The Number value for <i>e</i>, the base of the natural logarithms, which is approximately 2.7182818284590452354.</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.8.1.2<span>	LN1</span>0</h2>
      <p>The Number value for the natural logarithm of 10, which is approximately 2.302585092994046.</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.8.1.3<span>	LN</span>2</h2>
      <p>The Number value for the natural logarithm of 2, which is approximately 0.6931471805599453.</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.8.1.4<span>	LOG2</span>E</h2>
      <p>The Number value for the base-2 logarithm of <i>e</i>, the base of the natural logarithms; this value is approximately 1.4426950408889634.</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <p>NOTE<span>	The value of </span><b>Math.LOG2E</b> is approximately the reciprocal of the value of <b>Math.LN2</b>.</p>
      <h2>15.8.1.5<span>	LOG10</span>E</h2>
      <p>The Number value for the base-10 logarithm of <i>e</i>, the base of the natural logarithms; this value is approximately 0.4342944819032518.</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <p>NOTE<span>	The value of </span><b>Math.LOG10E</b> is approximately the reciprocal of the value of <b>Math.LN10</b>.</p>
      <h2>15.8.1.6<span>	P</span>I</h2>
      <p>The Number value for π, the ratio of the circumference of a circle to its diameter, which is approximately 3.1415926535897932.</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.8.1.7<span>	SQRT1_</span>2</h2>
      <p>The Number value for the square root of ½, which is approximately 0.7071067811865476.</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <p>NOTE<span>	The value of </span><b>Math.SQRT1_2</b> is approximately the reciprocal of the value of <b>Math.SQRT2</b>.</p>
      <h2>15.8.1.8<span>	SQRT</span>2</h2>
      <p>The Number value for the square root of 2, which is approximately 1.4142135623730951.</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.8.2<span>	Function Properties of the Math Objec</span>t</h2>
      <p>Each of the following <b>Math</b> object functions applies the ToNumber abstract operator to each of its arguments (in left-to-right order if there is more than one) and then performs a computation on the resulting Number value(s).</p>
      <p>In the function descriptions below, the symbols NaN, −0, +0, −∞ and +∞ refer to the Number values described in 8.5.</p>
      <p>NOTE<span>	The behaviour of the functions </span><b>acos</b>, <b>asin</b>, <b>atan</b>, <b>atan2</b>, <b>cos</b>, <b>exp</b>, <b>log</b>, <b>pow</b>, <b>sin</b>, <b>sqrt</b>, and <b>tan</b> is not precisely specified here except to require specific results for certain argument values that represent boundary cases of interest. For other argument values, these functions are intended to compute approximations to the results of familiar mathematical functions, but some latitude is allowed in the choice of approximation algorithms. The general intent is that an implementer should be able to use the same mathematical library for ECMAScript on a given hardware platform that is available to C programmers on that platform.</p>
      <p>Although the choice of algorithms is left to the implementation, it is recommended (but not specified by this standard) that implementations use the approximation algorithms for IEEE 754 arithmetic contained in <b>fdlibm</b>, the freely distributable mathematical library from Sun Microsystems (http://www.netlib.org/fdlibm). </p>
      <h2>15.8.2.1<span>	abs (x</span>)</h2>
      <p>Returns the absolute value of <i>x</i>; the result has the same magnitude as <i>x</i> but has positive sign.</p>
      <p>If <i>x</i> is NaN, the result is NaN.</p>
      <p>If <i>x</i> is −0, the result is +0.</p>
      <p>If <i>x</i> is −∞, the result is +∞.</p>
      <h2>15.8.2.2<span>	acos (x</span>)</h2>
      <p>Returns an implementation-dependent approximation to the arc cosine of <i>x</i>. The result is expressed in radians and ranges from +0 to +π.</p>
      <p>If <i>x</i> is NaN, the result is NaN.</p>
      <p>If <i>x</i> is greater than 1, the result is NaN.</p>
      <p>If <i>x</i> is less than <b>−</b>1, the result is NaN.</p>
      <p>If <i>x</i> is exactly 1, the result is +0.</p>
      <h2>15.8.2.3<span>	asin (x</span>)</h2>
      <p>Returns an implementation-dependent approximation to the arc sine of <i>x</i>. The result is expressed in radians and ranges from −π/2 to +π/2.</p>
      <p>If <i>x</i> is NaN, the result is NaN.</p>
      <p>If <i>x</i> is greater than 1, the result is NaN.</p>
      <p>If <i>x</i> is less than –1, the result is NaN.</p>
      <p>If <i>x</i> is +0, the result is +0.</p>
      <p>If <i>x</i> is −0, the result is −0.</p>
      <h2>15.8.2.4<span>	atan (x</span>)</h2>
      <p>Returns an implementation-dependent approximation to the arc tangent of <i>x</i>. The result is expressed in radians and ranges from −π/2 to +π/2.</p>
      <p>If <i>x</i> is NaN, the result is NaN.</p>
      <p>If <i>x</i> is +0, the result is +0.</p>
      <p>If <i>x</i> is −0, the result is −0.</p>
      <p>If <i>x</i> is +∞, the result is an implementation-dependent approximation to +π/2.</p>
      <p>If <i>x</i> is −∞, the result is an implementation-dependent approximation to −π/2.</p>
      <h2>15.8.2.5<span>	atan2 (y, x</span>)</h2>
      <p>Returns an implementation-dependent approximation to the arc tangent of the quotient <i>y</i><b>/</b><i>x</i> of the arguments <i>y</i> and <i>x</i>, where the signs of <i>y</i> and <i>x</i> are used to determine the quadrant of the result. Note that it is intentional and traditional for the two-argument arc tangent function that the argument named <i>y</i> be first and the argument named <i>x</i> be second. The result is expressed in radians and ranges from −π to +π.</p>
      <p>If either <i>x</i> or <i>y</i> is NaN, the result is NaN.</p>
      <p>If <i>y</i>&gt;0 and <i>x</i> is +0, the result is an implementation-dependent approximation to  +π/2.</p>
      <p>If <i>y</i>&gt;0 and <i>x</i> is −0, the result is an implementation-dependent approximation to  +π/2.</p>
      <p>If <i>y</i> is +0 and <i>x</i>&gt;0, the result is +0.</p>
      <p>If <i>y</i> is +0 and <i>x</i> is +0, the result is +0.</p>
      <p>If <i>y</i> is +0 and <i>x</i> is −0, the result is an implementation-dependent approximation to  +π.</p>
      <p>If <i>y</i> is +0 and <i>x</i>&lt;0, the result is an implementation-dependent approximation to  +π.</p>
      <p>If <i>y</i> is −0 and <i>x</i>&gt;0, the result is −0.</p>
      <p>If <i>y</i> is −0 and <i>x</i> is +0, the result is −0.</p>
      <p>If <i>y</i> is −0 and <i>x</i> is −0, the result is an implementation-dependent approximation to  −π.</p>
      <p>If <i>y</i> is −0 and <i>x</i>&lt;0, the result is an implementation-dependent approximation to  −π.</p>
      <p>If <i>y</i>&lt;0 and <i>x</i> is +0, the result is an implementation-dependent approximation to  −π/2.</p>
      <p>If <i>y</i>&lt;0 and <i>x</i> is −0, the result is an implementation-dependent approximation to  −π/2.</p>
      <p>If <i>y</i>&gt;0 and <i>y</i> is finite and <i>x</i> is +∞, the result is +0.</p>
      <p>If <i>y</i>&gt;0 and <i>y</i> is finite and <i>x</i> is −∞, the result if an implementation-dependent approximation to  +π.</p>
      <p>If <i>y</i>&lt;0 and <i>y</i> is finite and <i>x</i> is +∞, the result is −0.</p>
      <p>If <i>y</i>&lt;0 and <i>y</i> is finite and <i>x</i> is −∞, the result is an implementation-dependent approximation to −π.</p>
      <p>If <i>y</i> is +∞ and <i>x</i> is finite, the result is an implementation-dependent approximation to  +π/2.</p>
      <p>If <i>y</i> is −∞ and <i>x</i> is finite, the result is an implementation-dependent approximation to  −π/2.</p>
      <p>If <i>y</i> is +∞ and <i>x</i> is +∞, the result is an implementation-dependent approximation to  +π/4.</p>
      <p>If <i>y</i> is +∞ and <i>x</i> is −∞, the result is an implementation-dependent approximation to  +3π/4.</p>
      <p>If <i>y</i> is −∞ and <i>x</i> is +∞, the result is an implementation-dependent approximation to  −π/4.</p>
      <p>If <i>y</i> is −∞ and <i>x</i> is −∞, the result is an implementation-dependent approximation to  −3π/4.</p>
      <h2>15.8.2.6<span>	ceil (x</span>)</h2>
      <p>Returns the smallest (closest to <b>−</b><b>∞</b>) Number value that is not less than <i>x</i> and is equal to a mathematical integer. If <i>x</i> is already an integer, the result is <i>x</i>.</p>
      <p>If <i>x</i> is NaN, the result is NaN.</p>
      <p>If <i>x</i> is +0, the result is +0.</p>
      <p>If <i>x</i> is −0, the result is −0.</p>
      <p>If <i>x</i> is +∞, the result is +∞.</p>
      <p>If <i>x</i> is −∞, the result is −∞.</p>
      <p>If <i>x</i> is less than 0 but greater than -1, the result is −0.</p>
      <p>The value of <b>Math.ceil(x)</b> is the same as the value of <b>-Math.floor(-x)</b>.</p>
      <h2>15.8.2.7<span>	cos (x</span>)</h2>
      <p>Returns an implementation-dependent approximation to the cosine of <i>x</i>. The argument is expressed in radians.</p>
      <p>If <i>x</i> is NaN, the result is NaN.</p>
      <p>If <i>x</i> is +0, the result is 1.</p>
      <p>If <i>x</i> is −0, the result is 1.</p>
      <p>If <i>x</i> is +∞, the result is NaN.</p>
      <p>If <i>x</i> is −∞, the result is NaN.</p>
      <h2>15.8.2.8<span>	exp (x</span>)</h2>
      <p>Returns an implementation-dependent approximation to the exponential function of <i>x</i> (<i>e</i> raised to the power of <i>x</i>, where <i>e</i> is the base of the natural logarithms).</p>
      <p>If <i>x</i> is NaN, the result is NaN.</p>
      <p>If <i>x</i> is +0, the result is 1.</p>
      <p>If <i>x</i> is −0, the result is 1.</p>
      <p>If <i>x</i> is +∞, the result is +∞.</p>
      <p>If <i>x</i> is −∞, the result is +0.</p>
      <h2>15.8.2.9<span>	floor (x</span>)</h2>
      <p>Returns the greatest (closest to <b>+</b><b>∞</b>) Number value that is not greater than <i>x</i> and is equal to a mathematical integer. If <i>x</i> is already an integer, the result is <i>x</i>.</p>
      <p>If <i>x</i> is NaN, the result is NaN.</p>
      <p>If <i>x</i> is +0, the result is +0.</p>
      <p>If <i>x</i> is −0, the result is −0.</p>
      <p>If <i>x</i> is +∞, the result is +∞.</p>
      <p>If <i>x</i> is −∞, the result is −∞.</p>
      <p>If <i>x</i> is greater than 0 but less than 1, the result is +0.</p>
      <p>NOTE<span>	The value of </span><b>Math.floor(x)</b> is the same as the value of <b>-Math.ceil(-x)</b>.</p>
      <h2>15.8.2.10<span>	log (x</span>)</h2>
      <p>Returns an implementation-dependent approximation to the natural logarithm of <i>x</i>.</p>
      <p>If <i>x</i> is NaN, the result is NaN.</p>
      <p>If <i>x</i> is less than 0, the result is NaN.</p>
      <p>If <i>x</i> is +0 or −0, the result is −∞.</p>
      <p>If <i>x</i> is 1, the result is +0.</p>
      <p>If <i>x</i> is +∞, the result is +∞.</p>
      <h2>15.8.2.11<span>	max (</span> [ value1 [ , value2 [ , … ] ] ] )</h2>
      <p>Given zero or more arguments, calls ToNumber on each of the arguments and returns the largest of the resulting values.</p>
      <p>If no arguments are given, the result is −∞.</p>
      <p>If any value is NaN, the result is NaN.</p>
      <p>The comparison of values to determine the largest value is done using the Abstract Relational Comparision Alogrithm ( 11.8.1) except that +0 is considered to be larger than −0.</p>
      <p>The <b>length</b> property of the <b>max</b> method is <b>2</b>.</p>
      <h2>15.8.2.12<span>	min (</span> [ value1 [ , value2 [ , … ] ] ] )</h2>
      <p>Given zero or more arguments, calls ToNumber on each of the arguments and returns the smallest of the resulting values.</p>
      <p>If no arguments are given, the result is +∞.</p>
      <p>If any value is NaN, the result is NaN.</p>
      <p>The comparison of values to determine the smallest value is done using the Abstract Relational Comparision Alogrithm (11.8.1) except that +0 is considered to be larger than −0.</p>
      <p>The <b>length</b> property of the <b>min</b> method is <b>2</b>.</p>
      <h2>15.8.2.13<span>	pow (x, y</span>)</h2>
      <p>Returns an implementation-dependent approximation to the result of raising <i>x</i> to the power <i>y</i>.</p>
      <p>If <i>y</i> is NaN, the result is NaN.</p>
      <p>If <i>y</i> is +0, the result is 1, even if <i>x</i> is NaN.</p>
      <p>If <i>y</i> is −0, the result is 1, even if <i>x</i> is NaN.</p>
      <p>If <i>x</i> is NaN and <i>y</i> is nonzero, the result is NaN.</p>
      <p>If abs(<i>x</i>)&gt;1 and <i>y</i> is +∞, the result is +∞.</p>
      <p>If abs(<i>x</i>)&gt;1 and <i>y</i> is −∞, the result is +0.</p>
      <p>If abs(<i>x</i>)==1 and <i>y</i> is +∞, the result is NaN.</p>
      <p>If abs(<i>x</i>)==1 and <i>y</i> is −∞, the result is NaN.</p>
      <p>If abs(<i>x</i>)&lt;1 and <i>y</i> is +∞, the result is +0.</p>
      <p>If abs(<i>x</i>)&lt;1 and <i>y</i> is −∞, the result is +∞.</p>
      <p>If <i>x</i> is +∞ and <i>y</i>&gt;0, the result is +∞.</p>
      <p>If <i>x</i> is +∞ and <i>y</i>&lt;0, the result is +0.</p>
      <p>If <i>x</i> is −∞ and <i>y</i>&gt;0 and <i>y</i> is an odd integer, the result is −∞.</p>
      <p>If <i>x</i> is −∞ and <i>y</i>&gt;0 and <i>y</i> is not an odd integer, the result is +∞.</p>
      <p>If <i>x</i> is −∞ and <i>y</i>&lt;0 and <i>y</i> is an odd integer, the result is −0.</p>
      <p>If <i>x</i> is −∞ and <i>y</i>&lt;0 and <i>y</i> is not an odd integer, the result is +0.</p>
      <p>If <i>x</i> is +0 and <i>y</i>&gt;0, the result is +0.</p>
      <p>If <i>x</i> is +0 and <i>y</i>&lt;0, the result is +∞.</p>
      <p>If <i>x</i> is −0 and <i>y</i>&gt;0 and <i>y</i> is an odd integer, the result is −0.</p>
      <p>If <i>x</i> is −0 and <i>y</i>&gt;0 and <i>y</i> is not an odd integer, the result is +0.</p>
      <p>If <i>x</i> is −0 and <i>y</i>&lt;0 and <i>y</i> is an odd integer, the result is −∞.</p>
      <p>If <i>x</i> is −0 and <i>y</i>&lt;0 and <i>y</i> is not an odd integer, the result is +∞.</p>
      <p>If <i>x</i>&lt;0 and <i>x</i> is finite and <i>y</i> is finite and <i>y</i> is not an integer, the result is NaN.</p>
      <h2>15.8.2.14<span>	random</span> ( )</h2>
      <p>Returns a Number value with positive sign, greater than or equal to 0 but less than 1, chosen randomly or pseudo randomly with approximately uniform distribution over that range, using an implementation-dependent algorithm or strategy. This function takes no arguments.</p>
      <h2>15.8.2.15<span>	round (x</span>)</h2>
      <p>Returns the Number value that is closest to <i>x</i> and is equal to a mathematical integer. If two integer Number values are equally close to <i>x</i>, then the result is the Number value that is closer to +∞. If <i>x</i> is already an integer, the result is <i>x</i>.</p>
      <p>If <i>x</i> is NaN, the result is NaN.</p>
      <p>If <i>x</i> is +0, the result is +0.</p>
      <p>If <i>x</i> is −0, the result is −0.</p>
      <p>If <i>x</i> is +∞, the result is +∞.</p>
      <p>If <i>x</i> is −∞, the result is −∞.</p>
      <p>If <i>x</i> is greater than 0 but less than 0.5, the result is +0.</p>
      <p>If <i>x</i> is less than 0 but greater than or equal to -0.5, the result is −0.</p>
      <p>NOTE 1	<b>Math.round(3.5)</b> returns 4, but <b>Math.round(–3.5)</b> returns –3.</p>
      <p>NOTE 2<span>	The value of </span><b>Math.round(x)</b> is the same as the value of <b>Math.floor(x+0.5)</b>, except when <b>x</b> is −0<b> </b>or<b> </b>is less than 0 but greater than or equal to -0.5; for these cases <b>Math.round(x)</b> returns −0, but <b>Math.floor(x+0.5)</b> returns +0.</p>
      <h2>15.8.2.16<span>	sin (x</span>)</h2>
      <p>Returns an implementation-dependent approximation to the sine of <i>x</i>. The argument is expressed in radians.</p>
      <p>If <i>x</i> is NaN, the result is NaN.</p>
      <p>If <i>x</i> is +0, the result is +0.</p>
      <p>If <i>x</i> is −0, the result is −0.</p>
      <p>If <i>x</i> is +∞ or −∞, the result is NaN.</p>
      <h2>15.8.2.17<span>	sqrt (x</span>)</h2>
      <p>Returns an implementation-dependent approximation to the square root of <i>x</i>.</p>
      <p>If <i>x</i> is NaN, the result is NaN.</p>
      <p>If <i>x</i> is less than 0, the result is NaN.</p>
      <p>If <i>x</i> is +0, the result is +0.</p>
      <p>If <i>x</i> is −0, the result is −0.</p>
      <p>If <i>x</i> is +∞, the result is +∞.</p>
      <h2>15.8.2.18<span>	tan (x</span>)</h2>
      <p>Returns an implementation-dependent approximation to the tangent of <i>x</i>. The argument is expressed in radians.</p>
      <p>If <i>x</i> is NaN, the result is NaN.</p>
      <p>If <i>x</i> is +0, the result is +0.</p>
      <p>If <i>x</i> is −0, the result is −0.</p>
      <p>If <i>x</i> is +∞ or −∞, the result is NaN.</p>
      <h2>15.9<span>	Date Object</span>s</h2>
      <h2>15.9.1<span>	Overview of Date Object</span>s and Definitions of Abstract Operators</h2>
      <p>The following functions are abstract operations that operate on time values (defined in 15.9.1.1). Note that, in every case, if any argument to one of these functions is <b>NaN</b>, the result will be <b>NaN</b>.</p>
      <h2>15.9.1.1<span>	Time Values and Time Rang</span>e</h2>
      <p>A Date object contains a Number indicating a particular instant in time to within a millisecond. Such a Number is called a <i>time value</i>. A time value may also be <b>NaN</b>, indicating that the Date object does not represent a specific instant of time.</p>
      <p>Time is measured in ECMAScript in milliseconds since 01 January, 1970 UTC. In time values leap seconds are ignored. It is assumed that there are exactly 86,400,000 milliseconds per day. ECMAScript Number values can represent all integers from –9,007,199,254,740,992 to 9,007,199,254,740,992; this range suffices to measure times to millisecond precision for any instant that is within approximately 285,616 years, either forward or backward, from 01 January, 1970 UTC.</p>
      <p>The actual range of times supported by ECMAScript Date objects is slightly smaller: exactly –100,000,000 days to 100,000,000 days measured relative to midnight at the beginning of 01 January, 1970 UTC. This gives a range of 8,640,000,000,000,000 milliseconds to either side of 01 January, 1970 UTC.</p>
      <p>The exact moment of midnight at the beginning of 01 January, 1970 UTC is represented by the value <b>+0</b>.</p>
      <h2>15.9.1.2<span>	Day Number and Time within Da</span>y</h2>
      <p>A given time value <i>t</i> belongs to day number</p>
      <p>Day(<i>t</i>) = floor(<i>t</i> / msPerDay)</p>
      <p>where the number of milliseconds per day is</p>
      <p>msPerDay = 86400000</p>
      <p>The remainder is called the time within the day:</p>
      <p>TimeWithinDay(<i>t</i>) = <i>t </i>modulo msPerDay</p>
      <h2>15.9.1.3<span>	Year Numbe</span>r</h2>
      <p>ECMAScript uses an extrapolated Gregorian system to map a day number to a year number and to determine the month and date within that year. In this system, leap years are precisely those which are (divisible by 4) and ((not divisible by 100) or (divisible by 400)). The number of days in year number <i>y</i> is therefore defined by</p>
      <p>DaysInYear(<i>y</i>) <span>	= 365  if (</span><i>y</i> modulo 4) ≠ 0<span><br>= 366  if (</span><i>y</i> modulo 4) = 0 and (y modulo 100) ≠ 0<span><br>= 365  if (</span><i>y</i> modulo 100) = 0 and (y modulo 400) ≠ 0<span><br>= 366  if (</span><i>y</i> modulo 400) = 0</p>
      <p>All non-leap years have 365 days with the usual number of days per month and leap years have an extra day in February. The day number of the first day of year <i>y</i> is given by:</p>
      <p>DayFromYear(<i>y</i>)<span>	= 365 </span>× (<i>y</i>−1970) + floor((<i>y</i>−1969)/4) − floor((<i>y</i>−1901)/100) + floor((<i>y</i>−1601)/400)</p>
      <p>The time value of the start of a year is:</p>
      <p>TimeFromYear(<i>y</i>)<span>	= msPerDay </span>× DayFromYear(<i>y</i>)</p>
      <p>A time value determines a year by:</p>
      <p>YearFromTime(<i>t</i>)<span>	=  the largest integer </span><i>y</i> (closest to positive infinity) such that TimeFromYear(<i>y</i>) ≤ <i>t</i></p>
      <p>The leap-year function is 1 for a time within a leap year and otherwise is zero:</p>
      <p>InLeapYear(<i>t</i>)<span>	= 0  if DaysInYear(YearFromTime(</span><i>t</i>)) = 365<span><br>= 1  if DaysInYear(YearFromTime</span><i>(t</i>)) = 366</p>
      <h2>15.9.1.4<span>	Month Numbe</span>r</h2>
      <p>Months are identified by an integer in the range 0 to 11, inclusive. The mapping MonthFromTime(<i>t</i>) from a time value <i>t</i> to a month number is defined by:</p>
      <p><span>	MonthFromTime(</span><i>t</i>)<span>	= 0</span><span>	if</span><span>	0</span>	≤ DayWithinYear(<i>t</i>) &lt; 31<br>		<span>	= 1</span><span>	if</span><span>	31</span>	≤ DayWithinYear (<i>t</i>) &lt; 59+InLeapYear(<i>t</i>)<br>		<span>	= 2</span><span>	if</span><span>	59+InLeapYear(</span><i>t</i>) 	≤ DayWithinYear (<i>t</i>) &lt; 90+InLeapYear(<i>t</i>)<br>		<span>	= 3</span><span>	if</span><span>	90+InLeapYear(</span><i>t</i>) 	≤ DayWithinYear (<i>t</i>) &lt; 120+InLeapYear(<i>t</i>)<br>		<span>	= 4</span><span>	if</span><span>	120+InLeapYear(</span><i>t</i>) 	≤ DayWithinYear (<i>t</i>) &lt; 151+InLeapYear(<i>t</i>)<br>		<span>	= 5</span><span>	if</span><span>	151+InLeapYear(</span><i>t</i>) 	≤ DayWithinYear (<i>t</i>) &lt; 181+InLeapYear(<i>t</i>)<br>		<span>	= 6</span><span>	if</span><span>	181+InLeapYear(</span><i>t</i>) 	≤ DayWithinYear (<i>t</i>) &lt; 212+InLeapYear(<i>t</i>)<br>		<span>	= 7</span><span>	if</span><span>	212+InLeapYear(</span><i>t</i>) 	≤ DayWithinYear (<i>t</i>) &lt; 243+InLeapYear(<i>t</i>)<br>		<span>	= 8</span><span>	if</span><span>	243+InLeapYear(</span><i>t</i>) 	≤ DayWithinYear (<i>t</i>) &lt; 273+InLeapYear(<i>t</i>)<br>		<span>	= 9</span><span>	if</span><span>	273+InLeapYear(</span><i>t</i>) 	≤ DayWithinYear (<i>t</i>) &lt; 304+InLeapYear(<i>t</i>)<br>		<span>	= 10</span><span>	if</span><span>	304+InLeapYear(</span><i>t</i>) 	≤ DayWithinYear (<i>t</i>) &lt; 334+InLeapYear(<i>t</i>)<br>		<span>	= 11</span><span>	if</span><span>	334+InLeapYear(</span><i>t</i>) 	≤ DayWithinYear (<i>t</i>) &lt; 365+InLeapYear(<i>t</i>)</p>
      <p>where</p>
      <p>DayWithinYear(<i>t</i>)<span>	= Day(</span><i>t</i>)−DayFromYear(YearFromTime(<i>t)</i>)</p>
      <p>A month value of 0 specifies January; 1 specifies February; 2 specifies March; 3 specifies April; 4 specifies May; 5 specifies June; 6 specifies July; 7 specifies August; 8 specifies September; 9 specifies October; 10 specifies November; and 11 specifies December. Note that MonthFromTime(0) = 0, corresponding to Thursday, 01 January, 1970.</p>
      <h2>15.9.1.5<span>	Date Numbe</span>r</h2>
      <p>A date number is identified by an integer in the range 1 through 31, inclusive. The mapping DateFromTime(<i>t</i>) from a time value <i>t</i> to a month number is defined by:</p>
      <p>DateFromTime(<i>t</i>)<span>	= DayWithinYear(</span><i>t</i>)+1<span>	if MonthFromTime(</span><i>t</i>)=0<br><span>	= DayWithinYear(</span><i>t</i>)−30<span>	if MonthFromTime(</span><i>t</i>)=1<br><span>	= DayWithinYear(</span><i>t</i>)−58−InLeapYear(<i>t</i>)<span>	if MonthFromTime(</span><i>t</i>)=2<br><span>	= DayWithinYear(</span><i>t</i>)−89−InLeapYear(<i>t</i>)<span>	if MonthFromTime(</span><i>t</i>)=3<br><span>	= DayWithinYear(</span><i>t</i>)−119−InLeapYear(<i>t</i>)<span>	if MonthFromTime(</span><i>t</i>)=4<br><span>	= DayWithinYear(</span><i>t</i>)−150−InLeapYear(<i>t</i>)<span>	if MonthFromTime(</span><i>t</i>)=5<br><span>	= DayWithinYear(</span><i>t</i>)−180−InLeapYear(<i>t</i>)<span>	if MonthFromTime(</span><i>t</i>)=6<br><span>	= DayWithinYear(</span><i>t</i>)−211−InLeapYear(<i>t</i>)<span>	if MonthFromTime(</span><i>t</i>)=7<br><span>	= DayWithinYear(</span><i>t</i>)−242−InLeapYear(<i>t</i>)<span>	if MonthFromTime(</span><i>t</i>)=8<br><span>	= DayWithinYear(</span><i>t</i>)−272−InLeapYear(<i>t</i>)<span>	if MonthFromTime(</span><i>t</i>)=9<br><span>	= DayWithinYear(</span><i>t</i>)−303−InLeapYear(<i>t</i>)<span>	if MonthFromTime(</span><i>t</i>)=10<br><span>	= DayWithinYear(</span><i>t</i>)−333−InLeapYear(<i>t</i>)<span>	if MonthFromTime(</span><i>t</i>)=11</p>
      <h2>15.9.1.6<span>	Week Da</span>y</h2>
      <p>The weekday for a particular time value <i>t</i> is defined as</p>
      <p>WeekDay(<i>t</i>)<span>	 = (Day(</span><i>t</i>) + 4) modulo 7</p>
      <p>A weekday value of 0 specifies Sunday; 1 specifies Monday; 2 specifies Tuesday; 3 specifies Wednesday; 4 specifies Thursday; 5 specifies Friday; and 6 specifies Saturday. Note that WeekDay(0) = 4, corresponding to Thursday, 01 January, 1970.</p>
      <h2>15.9.1.7<span>	Local Time Zone Adjustmen</span>t</h2>
      <p>An implementation of ECMAScript is expected to determine the local time zone adjustment. The local time zone adjustment is a value LocalTZA measured in milliseconds which when added to UTC represents the local <i>standard</i> time. Daylight saving time is <i>not</i> reflected by LocalTZA. The value LocalTZA does not vary with time but depends only on the geographic location.</p>
      <h2>15.9.1.8<span>	Daylight Saving Time Adjustmen</span>t</h2>
      <p>An implementation of ECMAScript is expected to determine the daylight saving time algorithm. The algorithm to determine the daylight saving time adjustment DaylightSavingTA(<i>t</i>), measured in milliseconds, must depend only on four things:</p>
      <p>(1) the time since the beginning of the year</p>
      <p><i>t</i> – TimeFromYear(YearFromTime(<i>t</i>))</p>
      <p>(2) whether <i>t</i> is in a leap year</p>
      <p>InLeapYear(<i>t</i>)</p>
      <p>(3) the week day of the beginning of the year</p>
      <p>WeekDay(TimeFromYear(YearFromTime(<i>t</i>)))</p>
      <p>and (4) the geographic location.</p>
      <p>The implementation of ECMAScript should not try to determine whether the exact time was subject to daylight saving time, but just whether daylight saving time would have been in effect if the current daylight saving time algorithm had been used at the time. This avoids complications such as taking into account the years that the locale observed daylight saving time year round.</p>
      <p>If the host environment provides functionality for determining daylight saving time, the implementation of ECMAScript is free to map the year in question to an equivalent year (same leap-year-ness and same starting week day for the year) for which the host environment provides daylight saving time information. The only restriction is that all equivalent years should produce the same result.</p>
      <h2>15.9.1.9<span>	Local Tim</span>e</h2>
      <p>Conversion from UTC to local time is defined by</p>
      <p>LocalTime(<i>t</i>) = <i>t</i> + LocalTZA + DaylightSavingTA(<i>t</i>)</p>
      <p>Conversion from local time to UTC is defined by</p>
      <p>UTC(<i>t</i>) = <i>t</i> – LocalTZA – DaylightSavingTA(<i>t</i> – LocalTZA)</p>
      <p>Note that UTC(LocalTime(<i>t</i>)) is not necessarily always equal to <i>t</i>.</p>
      <h2>15.9.1.10<span>	Hours, Minutes, Second, and Millisecond</span>s</h2>
      <p>The following functions are useful in decomposing time values:</p>
      <p>HourFromTime(<i>t</i>)<span>	= floor(</span><i>t</i> / msPerHour) modulo HoursPerDay</p>
      <p>MinFromTime(<i>t</i>)<span>	= floor(</span><i>t</i> / msPerMinute) modulo MinutesPerHour</p>
      <p>SecFromTime(<i>t</i>)<span>	= floor(</span><i>t</i> / msPerSecond) modulo SecondsPerMinute</p>
      <p>msFromTime(<i>t</i>)<span>	= t modulo msPerSecond</span></p>
      <p>where</p>
      <p>HoursPerDay<span>	= 24</span></p>
      <p>MinutesPerHour<span>	= 60</span></p>
      <p>SecondsPerMinute<span>	= 60</span></p>
      <p>msPerSecond<span>	= 1000</span></p>
      <p>msPerMinute<span>	= 60000</span><span>	= msPerSecond </span>× SecondsPerMinute</p>
      <p>msPerHour<span>	= 3600000</span><span>	= msPerMinute </span>× MinutesPerHour</p>
      <h2>15.9.1.11<span>	MakeTime (hour, min, sec, ms</span>)</h2>
      <p>The operator MakeTime calculates a number of milliseconds from its four arguments, which must be ECMAScript Number values. This operator functions as follows:</p>
      <p>If <i>hour</i> is not finite or <i>min</i> is not finite or <i>sec</i> is not finite or <i>ms</i> is not finite, return <b>NaN</b>.</p>
      <p>Let <i>h</i> be ToInteger(<i>hour</i>).</p>
      <p>Let <i>m</i> be ToInteger(<i>min</i>).</p>
      <p>Let <i>s</i> be ToInteger(<i>sec</i>).</p>
      <p>Let <i>milli</i> be ToInteger(<i>ms</i>).</p>
      <p>Let <i>t</i> be <i>h</i> <b>*</b> msPerHour <b>+</b> <i>m</i> <b>*</b> msPerMinute <b>+</b> <i>s</i> <b>*</b> msPerSecond <b>+</b> <i>milli</i>, performing the arithmetic according to IEEE 754 rules (that is, as if using the ECMAScript operators <b>*</b> and <b>+</b>).</p>
      <p>Return <i>t</i>.</p>
      <h2>15.9.1.12<span>	MakeDay (year, month, date</span>)</h2>
      <p>The operator MakeDay calculates a number of days from its three arguments, which must be ECMAScript Number values. This operator functions as follows:</p>
      <p>If <i>year</i> is not finite or <i>month</i> is not finite or <i>date</i> is not finite, return <b>NaN</b>.</p>
      <p>Let <i>y</i> be ToInteger(<i>year</i>).</p>
      <p>Let <i>m</i> be ToInteger(<i>month</i>).</p>
      <p>Let <i>dt</i> be ToInteger(<i>date</i>).</p>
      <p>Let <i>ym</i> be <i>y</i> + floor(<i>m</i> /12).</p>
      <p>Let <i>mn</i> be <i>m</i> modulo 12.</p>
      <p>Find a value <i>t</i> such that YearFromTime(<i>t</i>) <b>==</b> <i>ym</i> and MonthFromTime(<i>t</i>) <b>==</b> <i>mn</i> and DateFromTime(<i>t</i>) <b>==</b> 1; but if this is not possible (because some argument is out of range), return <b>NaN</b>.</p>
      <p>Return Day(<i>t</i>) + <i>dt</i> − 1.</p>
      <h2>15.9.1.13<span>	MakeDate (day, time</span>)</h2>
      <p>The operator MakeDate calculates a number of milliseconds from its two arguments, which must be ECMAScript Number values. This operator functions as follows:</p>
      <p>If <i>day</i> is not finite or <i>time</i> is not finite, return <b>NaN</b>.</p>
      <p>Return <i>day</i> × msPerDay + <i>time</i>.</p>
      <h2>15.9.1.14<span>	TimeClip (time</span>)</h2>
      <p>The operator TimeClip calculates a number of milliseconds from its argument, which must be an ECMAScript Number value. This operator functions as follows:</p>
      <p>If <i>time</i> is not finite, return <b>NaN</b>.</p>
      <p>If abs(<i>time</i>) &gt; 8.64 x 10<sup>15</sup>, return <b>NaN</b>.</p>
      <p>Return an implementation-dependent choice of either ToInteger(<i>time</i>) or ToInteger(<i>time</i>) + (<b>+0</b>). (Adding a positive zero converts <b>−</b><b>0</b> to <b>+0</b>.)</p>
      <p>NOTE<span>	The point of s</span>tep 3 is that an implementation is permitted a choice of internal representations of time values, for example as a 64-bit signed integer or as a 64-bit floating-point value. Depending on the implementation, this internal representation may or may not distinguish <b>−</b><b>0</b> and <b>+0</b>.</p>
      <h2>15.9.1.15<span>	Date Time String Format</span></h2>
      <p>ECMAScript defines a string interchange format for date-times based upon a simplification of the ISO 8601 Extended Format.  The format is as follows: <b>YYYY-MM-DDTHH:mm:ss.sss</b><span style="font-weight: bold; font-style: italic">Z</span></p>
      <p>Where the fields are as follows:</p>
      <p>
        <b>YYYY</b>
        <span>	is the decimal digits of the year 0000 to 9999 in the Gregorian calendar.</span>
      </p>
      <p><b>-</b>		“<b>-</b>” (hyphen) appears literally twice in the string.</p>
      <p><b>MM</b>	<span>	is the month of the year from 01 (January) to 12 (December).</span></p>
      <p><b>DD</b>	<span>	is the day of the month from 01 to 31.</span></p>
      <p><b>T</b><b>	</b><span>	“</span><b>T</b>” appears literally in the string, to indicate the beginning of the time element.</p>
      <p><b>HH</b><b>	</b>is the number of complete hours that have passed since midnight as two decimal digits from 00 to 24.</p>
      <p><b>:</b>		“<b>:</b>” (colon) appears literally twice in the string.</p>
      <p><b>m</b><b>m</b><b>	</b>is the number of complete minutes since the start of the hour as two decimal digits from 00 to 59.</p>
      <p>
        <b>s</b>
        <b>s</b>
        <span>	is the number of complete seconds since the start of the minute as two decimal digits from 00 to 59.</span>
      </p>
      <p><b>.</b>		“<b>.</b>” (dot) appears literally in the string.</p>
      <p>
        <b>s</b>
        <b>ss</b>
        <span>	is the number of complete milliseconds since the start of the second as three decimal digits.</span>
      </p>
      <p><b>Z</b><span>	is the time zone offset specified as “</span><b>Z</b>” (for UTC) or either “<b>+</b>” or “<b>-</b>” followed by a time expression <b>HH:mm</b></p>
      <p>This format includes date-only forms:</p>
      <p>
        <b>YYYY</b>
        <b><br>YYYY-MM</b>
        <b><br>YYYY-MM-DD</b>
      </p>
      <p>It also includes “date-time” forms that consist of one of the above date-only forms immediately followed by one of the following time forms with an optional time zone offset appended: </p>
      <p>
        <b>THH:mm</b>
        <b><br>THH:mm:ss</b>
        <b><br>THH:mm:ss.sss</b>
      </p>
      <p>All numbers must be base 10. If the <b>MM</b> or <b>DD</b> fields are absent “<b>01</b>” is used as the value. If the <b>HH</b>, <b>mm</b>, or <b>ss</b> fields are absent “<b>00</b>” is used as the value and the value of an absent <b>sss</b> field is “<b>000</b>”. If the time zone offset is absent, the date-time is in interpreted as a local time.</p>
      <p>Illegal values (out-of-bounds as well as syntax errors) in a format string means that the format string is not a valid instance of this format.</p>
      <p>NOTE 1	As every day both starts and ends with midnight, the two notations 00:00 and 24:00 are available to distinguish the two midnights that can be associated with one date. This means that the following two notations refer to exactly the same point in time: 1995-02-04T24:00 and 1995-02-05T00:00</p>
      <p>NOTE 2	There exists no international standard that specifies abbreviations for civil time zones like CET, EST, etc. and sometimes the same abbreviation is even used for two very different time zones. For this reason, ISO 8601 and this format specifies numeric representations of date and time.</p>
      <p>15.9.1.15.1	Extended years</p>
      <p>ECMAScript requires the ability to specify 6 digit years (extended years); approximately 285,426 years, either forward or backward, from 01 January, 1970 UTC. To represent years before 0 or after 9999, ISO 8601 permits the expansion of the year representation, but only by prior agreement between the sender and the receiver. In the simplified ECMAScript format such an expanded year representation shall have 2 extra year digits and is always prefixed with a + or – sign. The year 0 is considered positive and hence prefixed with a + sign.</p>
      <p>NOTE	Examples of extended years:</p>
      <p>-283457-03-21T15:00:59.008Z   283458 B.C.<br>-000001-01-01T00:00:00Z          2 B.C.<br>+000000-01-01T00:00:00Z         1 B.C.<br>+000001-01-01T00:00:00Z         1 A.D.<br>+001970-01-01T00:00:00Z         1970 A.D.<br>+002009-12-15T00:00:00Z         2009 A.D.<br>+287396-10-12T08:59:00.992Z  287396 A.D.</p>
      <h2>15.9.2<span>	The Date Constructor Called as a Functio</span>n</h2>
      <p>When <b>Date</b> is called as a function rather than as a constructor, it returns a String representing the current time (UTC).</p>
      <p>NOTE<span>	The function call </span><b>Date(</b>…<b>)</b> is not equivalent to the object creation expression <b>new Date(</b>…<b>)</b> with the same arguments.</p>
      <h2>15.9.2.1<span>	Date ( [ year [, month [, date [, hours [, minutes [, seconds [, ms</span> ] ] ] ] ] ] ] )</h2>
      <p>All of the arguments are optional; any arguments supplied are accepted but are completely ignored. A String is created and returned as if by the expression <b>(new Date()).toString()</b> where <b>Date</b> is the standard built-in constructor with that name and <b>toString</b> is the standard built-in method <b>Date.prototype.toString</b>.</p>
      <h2>15.9.3<span>	The Date Constructo</span>r</h2>
      <p>When <b>Date</b> is called as part of a <b>new</b> expression, it is a constructor: it initialises the newly created object.</p>
      <h2>15.9.3.1<span>	new Date (year, month [, date [, hours [, minutes [, seconds [, ms</span> ] ] ] ] ] )</h2>
      <p>When <b>Date</b> is called with two to seven arguments, it computes the date from <i>year</i>, <i>month</i>, and (optionally) <i>date</i>, <i>hours</i>, <i>minutes</i>, <i>seconds</i> and <i>ms</i>.</p>
      <p>The [[Prototype]] internal property of the newly constructed object is set to the original Date prototype object, the one that is the initial value of <b>Date.prototype</b> (15.9.4.1).</p>
      <p>The newly constructed object has a [[NativeBrand]] internal property whose value is NativeDate.</p>
      <p>The [[Extensible]] internal property of the newly constructed object is set to <b>true</b>.</p>
      <p>The [[PrimitiveValue]] internal property of the newly constructed object is set as follows:</p>
      <p>Let <i>y</i> be ToNumber(<i>year</i>).</p>
      <p>Let <i>m</i> be ToNumber(<i>month</i>).</p>
      <p>If <i>date</i> is supplied then let <i>dt</i> be ToNumber(<i>date</i>); else let <i>dt</i> be <b>1</b>.</p>
      <p>If <i>hours</i> is supplied then let <i>h</i> be ToNumber(<i>hours</i>); else let <i>h</i> be <b>0</b>.</p>
      <p>If <i>minutes</i> is supplied then let <i>min</i> be ToNumber(<i>minutes</i>); else let <i>min</i> be <b>0</b>.</p>
      <p>If <i>seconds</i> is supplied then let <i>s</i> be ToNumber(<i>seconds</i>); else let <i>s</i> be <b>0</b>.</p>
      <p>If <i>ms</i> is supplied then let <i>milli</i> be ToNumber(<i>ms</i>); else let <i>milli</i> be <b>0</b>.</p>
      <p>If <i>y</i> is not <b>NaN</b> and 0 ≤ ToInteger(<i>y</i>) ≤ 99, then let <i>yr</i> be 1900+ToInteger(<i>y</i>); otherwise, let <i>yr</i> be <i>y</i>.</p>
      <p>Let <i>finalDate</i> be  MakeDate(MakeDay(<i>yr</i>, <i>m</i>, <i>dt</i>), MakeTime(<i>h</i>, <i>min</i>, <i>s</i>, <i>milli</i>)).</p>
      <p>Set the [[PrimitiveValue]] internal property of the newly constructed object to TimeClip(UTC(<i>finalDate</i>)).</p>
      <h2>15.9.3.2<span>	new Date (value</span>)</h2>
      <p>The [[Prototype]] internal property of the newly constructed object is set to the original Date prototype object, the one that is the initial value of <b>Date.prototype</b> (15.9.4.1).</p>
      <p>The newly constructed object has a [[NativeBrand]] internal property whose value is NativeDate.</p>
      <p>The [[Extensible]] internal property of the newly constructed object is set to <b>true</b>.</p>
      <p>The [[PrimitiveValue]] internal property of the newly constructed object is set as follows:</p>
      <p>Let <i>v</i> be ToPrimitive(<i>value</i>).</p>
      <p>If Type(<i>v</i>) is String, then </p>
      <p>Parse <i>v</i> as a date, in exactly the same manner as for the <b>parse</b> method (15.9.4.2); let <i>V</i> be the time value for this date.</p>
      <p>Else, let <i>V</i> be ToNumber(<i>v</i>).</p>
      <p>Set the [[PrimitiveValue]] internal property of the newly constructed object to TimeClip(<i>V</i>) and return.</p>
      <h2>15.9.3.3<span>	new Date (</span> )</h2>
      <p>The [[Prototype]] internal property of the newly constructed object is set to the original Date prototype object, the one that is the initial value of <b>Date.prototype</b> (15.9.4.1).</p>
      <p>The newly constructed object has a [[NativeBrand]] internal property whose value is NativeDate.</p>
      <p>The [[Extensible]] internal property of the newly constructed object is set to <b>true</b>.</p>
      <p>The [[PrimitiveValue]] internal property of the newly constructed object is set to the time value (UTC) identifying the current time.</p>
      <h2>15.9.4<span>	Properties of the Date Constructo</span>r</h2>
      <p>The value of the [[Prototype]] internal property of the Date constructor is the Function prototype object (15.3.4).</p>
      <p>Besides the internal properties and the <b>length</b> property (whose value is <b>7</b>), the Date constructor has the following properties:</p>
      <h2>15.9.4.1<span>	Date.prototyp</span>e</h2>
      <p>The initial value of <b>Date.prototype</b> is the built-in Date prototype object (15.9.5).</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.9.4.2<span>	Date.parse (string</span>)</h2>
      <p>The <b>parse</b> function applies the ToString operator to its argument and interprets the resulting String as a date and time; it returns a Number, the UTC time value corresponding to the date and time. The String may be interpreted as a local time, a UTC time, or a time in some other time zone, depending on the contents of the String. The function first attempts to parse the format of the String according to the rules called out in Date Time String Format (15.9.1.15). If the String does not conform to that format the function may fall back to any implementation-specific heuristics or implementation-specific date formats. Unrecognisable Strings or dates containing illegal element values in the format String shall cause <b>Date.parse</b> to return <b>NaN</b>.</p>
      <p>If <i>x</i> is any Date object whose milliseconds amount is zero within a particular implementation of ECMAScript, then all of the following expressions should produce the same numeric value in that implementation, if all the properties referenced have their initial values:</p>
      <p>
        <span style="font-weight: bold; font-style: italic">x</span>
        <b>.valueOf()</b>
      </p>
      <p>
        <b>Date.parse(</b>
        <span style="font-weight: bold; font-style: italic">x</span>
        <b>.toString())</b>
      </p>
      <p>
        <b>Date.parse(</b>
        <span style="font-weight: bold; font-style: italic">x</span>
        <b>.toUTCString())</b>
      </p>
      <p>
        <b>Date.parse(</b>
        <span style="font-weight: bold; font-style: italic">x</span>
        <b>.toISOString())</b>
      </p>
      <p>However, the expression</p>
      <p>
        <b>Date.parse(</b>
        <i>x</i>
        <b>.toLocaleString())</b>
      </p>
      <p>is not required to produce the same Number value as the preceding three expressions and, in general, the value produced by <b>Date.parse</b> is implementation-dependent when given any String value that does not conform to the Date Time String Format (15.9.1.15) and that could not be produced in that implementation by the <b>toString</b> or <b>toUTCString</b> method.</p>
      <h2>15.9.4.3<span>	Date.UTC (year, month [, date [, hours [, minutes [, seconds [, ms</span> ] ] ] ] ] )</h2>
      <p>When the <b>UTC</b> function is called with fewer than two arguments, the behaviour is implementation-dependent. When the <b>UTC</b> function is called with two to seven arguments, it computes the date from <i>year</i>, <i>month</i> and (optionally) <i>date</i>, <i>hours</i>, <i>minutes</i>, <i>seconds</i> and <i>ms</i>. The following steps are taken:</p>
      <p>Let <i>y</i> be ToNumber(<i>year</i>).</p>
      <p>Let <i>m</i> be ToNumber(<i>month</i>).</p>
      <p>If <i>date</i> is supplied then let <i>dt</i> be ToNumber(<i>date</i>); else let <i>dt</i> be <b>1</b>.</p>
      <p>If <i>hours</i> is supplied then let <i>h</i> be ToNumber(<i>hours</i>); else let <i>h</i> be <b>0</b>.</p>
      <p>If <i>minutes</i> is supplied then let <i>min</i> be ToNumber(<i>minutes</i>); else let <i>min</i> be <b>0</b>.</p>
      <p>If <i>seconds</i> is supplied then let <i>s</i> be ToNumber(<i>seconds</i>); else let <i>s</i> be <b>0</b>.</p>
      <p>If <i>ms</i> is supplied then let <i>milli</i> be ToNumber(<i>ms</i>); else let <i>milli</i> be <b>0</b>.</p>
      <p>If <i>y</i> is not <b>NaN</b> and 0 ≤ ToInteger(<i>y</i>) ≤ 99, then let <i>yr</i> be 1900+ToInteger(<i>y</i>); otherwise, let <i>yr</i> be <i>y</i>.</p>
      <p>Return TimeClip(MakeDate(MakeDay(<i>yr</i>, <i>m</i>, <i>dt</i>), MakeTime(<i>h</i>, <i>min</i>, <i>s</i>, <i>milli</i>))).</p>
      <p>The <b>length</b> property of the <b>UTC</b> function is <b>7</b>.</p>
      <p>NOTE<span>	The </span>UTC function differs from the Date constructor in two ways: it returns a time value as a Number, rather than creating a Date object, and it interprets the arguments in UTC rather than as local time.</p>
      <h2>15.9.4.4<span>	Date.now ( )</span></h2>
      <p>The <b>now</b> function return a Number value that is the time value designating the UTC date and time of the occurrence of the call to <b>now</b>.</p>
      <h2>15.9.5<span>	Properties of the Date Prototype Objec</span>t</h2>
      <p>The Date prototype object is itself a Date object and has a [[NativeBrand]] internal property whose value is NativeDate. Its [[PrimitiveValue]] is <b>NaN</b>.</p>
      <p>The value of the [[Prototype]] internal property of the Date prototype object is the standard built-in Object prototype object (15.2.4).</p>
      <p>In following descriptions of functions that are properties of the Date prototype object, the phrase “this Date object” refers to the object that is the <b>this</b> value for the invocation of the function. Unless explicitly noted otherwise, none of these functions are generic; a <b>TypeError</b> exception is thrown if the <b>this</b> value is not an object with a [[NativeBrand]] internal property whose value is NativeDate. Also, the phrase “this time value” refers to the Number value for the time represented by this Date object, that is, the value of the [[PrimitiveValue]] internal property of this Date object.</p>
      <h2>15.9.5.1<span>	Date.prototype.constructo</span>r</h2>
      <p>The initial value of <b>Date.prototype.constructor</b> is the built-in <b>Date</b> constructor.</p>
      <h2>15.9.5.2<span>	Date.prototype.toString</span> ( )</h2>
      <p>This function returns a String value. If this time value is NaN, the String value is <b>″Invalid Date"</b>, otherwise the contents of the String are implementation-dependent, but are intended to represent the Date in the current time zone in a convenient, human-readable form.</p>
      <p>NOTE<span>	For any Date value </span><i>d</i> whose milliseconds amount is zero, the result of Date.parse(<i>d</i>.toString()) is equal to <i>d</i>.valueOf(). See 15.9.4.2.</p>
      <h2>15.9.5.3<span>	Date.prototype.toDateString ( )</span></h2>
      <p>This function returns a String value. The contents of the String are implementation-dependent, but are intended to represent the “date” portion of the Date in the current time zone in a convenient, human-readable form.</p>
      <h2>15.9.5.4<span>	Date.prototype.toTimeString ( )</span></h2>
      <p>This function returns a String value. The contents of the String are implementation-dependent, but are intended to represent the “time” portion of the Date in the current time zone in a convenient, human-readable form.</p>
      <h2>15.9.5.5<span>	Date.prototype.toLocaleString</span> ( )</h2>
      <p>This function returns a String value. The contents of the String are implementation-dependent, but are intended to represent the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the host environment’s current locale.</p>
      <p>NOTE<span>	The first parameter to this function is likely to be used in a future version of this standard; it is recommended tha</span>t implementations do not use this parameter position for anything else.</p>
      <h2>15.9.5.6<span>	Date.prototype.toLocaleDateString ( )</span></h2>
      <p>This function returns a String value. The contents of the String are implementation-dependent, but are intended to represent the “date” portion of the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the host environment’s current locale.</p>
      <p>NOTE<span>	The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.</span></p>
      <h2>15.9.5.7<span>	Date.prototype.toLocaleTimeString ( )</span></h2>
      <p>This function returns a String value. The contents of the String are implementation-dependent, but are intended to represent the “time” portion of the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the host environment’s current locale.</p>
      <p>NOTE<span>	The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.</span></p>
      <h2>15.9.5.8<span>	Date.prototype.valueOf</span> ( )</h2>
      <p>The <b>valueOf</b> function returns a Number, which is this time value.</p>
      <h2>15.9.5.9<span>	Date.prototype.getTime</span> ( )</h2>
      <p>Return this time value.</p>
      <h2>15.9.5.10<span>	Date.prototype.getFullYear</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return YearFromTime(LocalTime(<i>t</i>)).</p>
      <h2>15.9.5.11<span>	Date.prototype.getUTCFullYear</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return YearFromTime(<i>t</i>).</p>
      <h2>15.9.5.12<span>	Date.prototype.getMonth</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return MonthFromTime(LocalTime(<i>t</i>)).</p>
      <h2>15.9.5.13<span>	Date.prototype.getUTCMonth</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return MonthFromTime(<i>t</i>).</p>
      <h2>15.9.5.14<span>	Date.prototype.getDate</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return DateFromTime(LocalTime(<i>t</i>)).</p>
      <h2>15.9.5.15<span>	Date.prototype.getUTCDate</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return DateFromTime(<i>t</i>).</p>
      <h2>15.9.5.16<span>	Date.prototype.getDay</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return WeekDay(LocalTime(<i>t</i>)).</p>
      <h2>15.9.5.17<span>	Date.prototype.getUTCDay</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return WeekDay(<i>t</i>).</p>
      <h2>15.9.5.18<span>	Date.prototype.getHours</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return HourFromTime(LocalTime(<i>t</i>)).</p>
      <h2>15.9.5.19<span>	Date.prototype.getUTCHours</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return HourFromTime(<i>t</i>).</p>
      <h2>15.9.5.20<span>	Date.prototype.getMinutes</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return MinFromTime(LocalTime(<i>t</i>)).</p>
      <h2>15.9.5.21<span>	Date.prototype.getUTCMinutes</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return MinFromTime(<i>t</i>).</p>
      <h2>15.9.5.22<span>	Date.prototype.getSeconds</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return SecFromTime(LocalTime(<i>t</i>)).</p>
      <h2>15.9.5.23<span>	Date.prototype.getUTCSeconds</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return SecFromTime(<i>t</i>).</p>
      <h2>15.9.5.24<span>	Date.prototype.getMilliseconds</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return msFromTime(LocalTime(<i>t</i>)).</p>
      <h2>15.9.5.25<span>	Date.prototype.getUTCMilliseconds</span> ( )</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return msFromTime(<i>t</i>).</p>
      <h2>15.9.5.26<span>	Date.prototype.getTimezoneOffset</span> ( )</h2>
      <p>Returns the difference between local time and UTC time in minutes.</p>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return (<i>t</i> − LocalTime(<i>t</i>)) / msPerMinute.</p>
      <h2>15.9.5.27<span>	Date.prototype.setTime (time</span>)</h2>
      <p>Let <i>v</i> be TimeClip(ToNumber(<i>time</i>)).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>v</i>.</p>
      <p>Return <i>v</i>.</p>
      <h2>15.9.5.28<span>	Date.prototype.setMilliseconds (ms</span>)</h2>
      <p>Let <i>t</i> be the result of LocalTime(this time value).</p>
      <p>Let <i>time</i> be MakeTime(HourFromTime(<i>t</i>), MinFromTime(<i>t</i>), SecFromTime(<i>t</i>), ToNumber(<i>ms</i>)).</p>
      <p>Let <i>u</i> be TimeClip(UTC(MakeDate(Day(<i>t</i>), <i>time</i>))).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>u</i>.</p>
      <p>Return <i>u</i>.</p>
      <h2>15.9.5.29<span>	Date.prototype.setUTCMilliseconds (ms</span>)</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>Let <i>time</i> be MakeTime(HourFromTime(<i>t</i>), MinFromTime(<i>t</i>), SecFromTime(<i>t</i>), ToNumber(<i>ms</i>)).</p>
      <p>Let <i>v</i> be TimeClip(MakeDate(Day(<i>t</i>), <i>time</i>)).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>v</i>.</p>
      <p>Return <i>v</i>.</p>
      <h2>15.9.5.30<span>	Date.prototype.setSeconds (sec [, ms ] </span>)</h2>
      <p>If <i>ms</i> is not specified, this behaves as if <i>ms</i> were specified with the value <b>getMilliseconds()</b>.</p>
      <p>Let <i>t</i> be the result of LocalTime(this time value).</p>
      <p>Let <i>s</i> be ToNumber(<i>sec</i>).</p>
      <p>If <i>ms</i> is not specified, then let <i>milli</i> be msFromTime(<i>t</i>); otherwise, let <i>milli</i> be ToNumber(<i>ms</i>).</p>
      <p>Let <i>date</i> be MakeDate(Day(<i>t</i>), MakeTime(HourFromTime(<i>t</i>), MinFromTime(<i>t</i>), <i>s</i>, <i>milli</i>)).</p>
      <p>Let <i>u</i> be TimeClip(UTC(<i>date</i>)).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>u</i>.</p>
      <p>Return <i>u</i>.</p>
      <p>The <b>length</b> property of the <b>setSeconds</b> method is <b>2</b>.</p>
      <h2>15.9.5.31<span>	Date.prototype.setUTCSeconds (sec [, ms ] </span>)</h2>
      <p>If <i>ms</i> is not specified, this behaves as if <i>ms</i> were specified with the value <b>getUTCMilliseconds()</b>.</p>
      <p>Let <i>t</i> be this time value.</p>
      <p>Let <i>s</i> be ToNumber(<i>sec</i>).</p>
      <p>If <i>ms</i> is not specified, then let <i>milli</i> be msFromTime(<i>t</i>); otherwise, let <i>milli</i> be ToNumber(<i>ms</i>).</p>
      <p>Let <i>date</i> be MakeDate(Day(<i>t</i>), MakeTime(HourFromTime(<i>t</i>), MinFromTime(<i>t</i>), <i>s</i>, <i>milli</i>)).</p>
      <p>Let <i>v</i> be TimeClip(<i>date</i>).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>v</i>.</p>
      <p>Return <i>v</i>.</p>
      <p>The <b>length</b> property of the <b>setUTCSeconds</b> method is <b>2</b>.</p>
      <h2>15.9.5.32<span>	Date.prototype.setMinutes (min [, sec [, ms ] ] </span>)</h2>
      <p>If <i>sec</i> is not specified, this behaves as if <i>sec</i> were specified with the value <b>getSeconds()</b>.</p>
      <p>If <i>ms</i> is not specified, this behaves as if <i>ms</i> were specified with the value <b>getMilliseconds()</b>.</p>
      <p>Let <i>t</i> be the result of LocalTime(this time value).</p>
      <p>Let <i>m</i> be ToNumber(<i>min</i>).</p>
      <p>If <i>sec</i> is not specified, then let <i>s</i> be SecFromTime(<i>t</i>); otherwise, let <i>s</i> be ToNumber(<i>sec</i>).</p>
      <p>If <i>ms</i> is not specified, then let <i>milli</i> be msFromTime(<i>t</i>); otherwise, let <i>milli</i> be ToNumber(<i>ms</i>).</p>
      <p>Let <i>date</i> be MakeDate(Day(<i>t</i>), MakeTime(HourFromTime(<i>t</i>), <i>m</i>, <i>s</i>, <i>milli</i>)).</p>
      <p>Let <i>u</i> be TimeClip(UTC(<i>date</i>)).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>u</i>.</p>
      <p>Return <i>u</i>.</p>
      <p>The <b>length</b> property of the <b>setMinutes</b> method is <b>3</b>.</p>
      <h2>15.9.5.33<span>	Date.prototype.setUTCMinutes (min [, sec [, ms ] ] </span>)</h2>
      <p>If <i>sec</i> is not specified, this behaves as if <i>sec</i> were specified with the value <b>getUTCSeconds()</b>.</p>
      <p>If <i>ms</i> is not specified, this function behaves as if <i>ms</i> were specified with the value return by <b>getUTCMilliseconds()</b>.</p>
      <p>Let <i>t</i> be this time value.</p>
      <p>Let <i>m</i> be ToNumber(<i>min</i>).</p>
      <p>If <i>sec</i> is not specified, then let <i>s</i> be SecFromTime(<i>t</i>); otherwise, let <i>s</i> be ToNumber(<i>sec</i>).</p>
      <p>If <i>ms</i> is not specified, then let <i>milli</i> be msFromTime(<i>t</i>); otherwise, let <i>milli</i> be ToNumber(<i>ms</i>).</p>
      <p>Let <i>date</i> be MakeDate(Day(<i>t</i>), MakeTime(HourFromTime(<i>t</i>), <i>m</i>, <i>s</i>, <i>milli</i>)).</p>
      <p>Let <i>v</i> be TimeClip(<i>date</i>).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>v</i>.</p>
      <p>Return <i>v</i>.</p>
      <p>The <b>length</b> property of the <b>setUTCMinutes</b> method is <b>3</b>.</p>
      <h2>15.9.5.34<span>	Date.prototype.setHours (hour [, min [, sec [, ms ] ] ] </span>)</h2>
      <p>If <i>min</i> is not specified, this behaves as if <i>min</i> were specified with the value <b>getMinutes()</b>.</p>
      <p>If <i>sec</i> is not specified, this behaves as if <i>sec</i> were specified with the value <b>getSeconds()</b>.</p>
      <p>If <i>ms</i> is not specified, this behaves as if <i>ms</i> were specified with the value <b>getMilliseconds()</b>.</p>
      <p>Let <i>t</i> be the result of LocalTime(this time value).</p>
      <p>Let <i>h</i> be ToNumber(<i>hour</i>).</p>
      <p>If <i>min</i> is not specified, then let <i>m</i> be MinFromTime(<i>t</i>); otherwise, let <i>m</i> be ToNumber(<i>min</i>).</p>
      <p>If If <i>sec</i> is not specified, then let <i>s</i> be SecFromTime(<i>t</i>); otherwise, let <i>s</i> be ToNumber(<i>sec</i>).</p>
      <p>If <i>ms</i> is not specified, then let <i>milli</i> be msFromTime(<i>t</i>); otherwise, let <i>milli</i> be ToNumber(<i>ms</i>).</p>
      <p>Let <i>date</i> be MakeDate(Day(<i>t</i>), MakeTime(<i>h</i>, <i>m</i>, <i>s</i>, <i>milli</i>)).</p>
      <p>Let <i>u</i> be TimeClip(UTC(<i>date</i>)).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>u</i>.</p>
      <p>Return <i>u</i>.</p>
      <p>The <b>length</b> property of the <b>setHours</b> method is <b>4</b>.</p>
      <h2>15.9.5.35<span>	Date.prototype.setUTCHours (hour [, min [, sec [, ms ] ] ] </span>)</h2>
      <p>If <i>min</i> is not specified, this behaves as if <i>min</i> were specified with the value <b>getUTCMinutes()</b>.</p>
      <p>If <i>sec</i> is not specified, this behaves as if <i>sec</i> were specified with the value <b>getUTCSeconds()</b>.</p>
      <p>If <i>ms</i> is not specified, this behaves as if <i>ms</i> were specified with the value <b>getUTCMilliseconds()</b>.</p>
      <p>Let <i>t</i> be this time value.</p>
      <p>Let <i>h</i> be ToNumber(<i>hour</i>).</p>
      <p>If <i>min</i> is not specified, then let <i>m</i> be MinFromTime(<i>t</i>); otherwise, let <i>m</i> be ToNumber(<i>min</i>).</p>
      <p>If <i>sec</i> is not specified, then let <i>s</i> be SecFromTime(<i>t</i>); otherwise, let <i>s</i> be ToNumber(<i>sec</i>).</p>
      <p>If <i>ms</i> is not specified, then let <i>milli</i> be msFromTime(<i>t</i>); otherwise, let <i>milli</i> be ToNumber(<i>ms</i>).</p>
      <p>Let <i>newDate</i> be MakeDate(Day(<i>t</i>), MakeTime(<i>h</i>, <i>m</i>, <i>s</i>, <i>milli</i>)).</p>
      <p>Let <i>v</i> be TimeClip(<i>newDate</i>).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>v</i>.</p>
      <p>Return <i>v</i>.</p>
      <p>The <b>length</b> property of the <b>setUTCHours</b> method is <b>4</b>.</p>
      <h2>15.9.5.36<span>	Date.prototype.setDate (date</span>)</h2>
      <p>Let <i>t</i> be the result of LocalTime(this time value).</p>
      <p>Let <i>dt</i> be ToNumber(<i>date</i>).</p>
      <p>Let <i>newDate</i> be MakeDate(MakeDay(YearFromTime(<i>t</i>), MonthFromTime(<i>t</i>), <i>dt</i>), TimeWithinDay(<i>t</i>)).</p>
      <p>Let <i>u</i> be TimeClip(UTC(<i>newDate</i>)).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>u</i>.</p>
      <p>Return <i>u</i>.</p>
      <h2>15.9.5.37<span>	Date.prototype.setUTCDate (date</span>)</h2>
      <p>Let <i>t</i> be this time value.</p>
      <p>Let <i>dt</i> be ToNumber(<i>date</i>).</p>
      <p>Let <i>newDate</i> be MakeDate(MakeDay(YearFromTime(<i>t</i>), MonthFromTime(<i>t</i>), <i>dt</i>), TimeWithinDay(<i>t</i>)).</p>
      <p>Let <i>v</i> be TimeClip(<i>newDate</i>).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>v</i>.</p>
      <p>Return <i>v</i>.</p>
      <h2>15.9.5.38<span>	Date.prototype.setMonth (month [, date ] </span>)</h2>
      <p>If <i>date</i> is not specified, this behaves as if <i>date</i> were specified with the value <b>getDate()</b>.</p>
      <p>Let <i>t</i> be the result of LocalTime(this time value).</p>
      <p>Let <i>m</i> be ToNumber(<i>month</i>).</p>
      <p>If <i>date</i> is not specified, then let <i>dt</i> be DateFromTime(<i>t</i>); otherwise, let <i>dt</i> be ToNumber(<i>date</i>).</p>
      <p>Let <i>newDate</i> be MakeDate(MakeDay(YearFromTime(<i>t</i>), <i>m</i>, <i>dt</i>), TimeWithinDay(<i>t</i>)).</p>
      <p>Let <i>u</i> be TimeClip(UTC(<i>newDate</i>)).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>u</i>.</p>
      <p>Return <i>u</i>.</p>
      <p>The <b>length</b> property of the <b>setMonth</b> method is <b>2</b>.</p>
      <h2>15.9.5.39<span>	Date.prototype.setUTCMonth (month [, date ] </span>)</h2>
      <p>If <i>date</i> is not specified, this behaves as if <i>date</i> were specified with the value <b>getUTCDate()</b>.</p>
      <p>Let <i>t</i> be this time value.</p>
      <p>Let <i>m</i> be ToNumber(<i>month</i>).</p>
      <p>If <i>date</i> is not specified, then let <i>dt</i> be DateFromTime(<i>t</i>); otherwise, let <i>dt</i> be ToNumber(<i>date</i>).</p>
      <p>Let <i>newDate</i> be MakeDate(MakeDay(YearFromTime(<i>t</i>), <i>m</i>, <i>dt</i>), TimeWithinDay(<i>t</i>)).</p>
      <p>Let <i>v</i> be TimeClip(<i>newDate</i>).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>v</i>.</p>
      <p>Return <i>v</i>.</p>
      <p>The <b>length</b> property of the <b>setUTCMonth</b> method is <b>2</b>.</p>
      <h2>15.9.5.40<span>	Date.prototype.setFullYear (year [, month [, date ] ] </span>)</h2>
      <p>If <i>month</i> is not specified, this behaves as if <i>month</i> were specified with the value <b>getMonth()</b>.</p>
      <p>If <i>date</i> is not specified, this behaves as if <i>date</i> were specified with the value <b>getDate()</b>.</p>
      <p>Let <i>t</i> be the result of LocalTime(this time value); but if this time value is <b>NaN</b>, let <i>t</i> be <b>+0</b>.</p>
      <p>Let <i>y</i> be ToNumber(<i>year</i>).</p>
      <p>If <i>month</i> is not specified, then let <i>m</i> be MonthFromTime(<i>t</i>); otherwise, let <i>m</i> be ToNumber(<i>month</i>).</p>
      <p>If <i>date</i> is not specified, then let <i>dt</i> be DateFromTime(<i>t</i>); otherwise, let <i>dt</i> be ToNumber(<i>date</i>).</p>
      <p>Let <i>newDate</i> be MakeDate(MakeDay(<i>y</i>, <i>m</i>, <i>dt</i>), TimeWithinDay(<i>t</i>)).</p>
      <p>Let <i>u</i> be TimeClip(UTC(<i>newDate</i>)).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>u</i>.</p>
      <p>Return <i>u</i>.</p>
      <p>The <b>length</b> property of the <b>setFullYear</b> method is <b>3</b>.</p>
      <h2>15.9.5.41<span>	Date.prototype.setUTCFullYear (year [, month [, date ] ] </span>)</h2>
      <p>If <i>month</i> is not specified, this behaves as if <i>month</i> were specified with the value <b>getUTCMonth()</b>.</p>
      <p>If <i>date</i> is not specified, this behaves as if <i>date</i> were specified with the value <b>getUTCDate()</b>.</p>
      <p>Let <i>t</i> be this time value; but if this time value is <b>NaN</b>, let <i>t</i> be <b>+0</b>.</p>
      <p>Let <i>y</i> be ToNumber(<i>year</i>).</p>
      <p>If <i>month</i> is not specified, then let <i>m</i> be MonthFromTime(<i>t</i>); otherwise, let <i>m</i> be ToNumber(<i>month</i>).</p>
      <p>If <i>date</i> is not specified, then let <i>dt</i> be DateFromTime(<i>t</i>); otherwise, let <i>dt</i> be ToNumber(<i>date</i>).</p>
      <p>Let <i>newDate</i> be MakeDate(MakeDay(<i>y</i>, <i>m</i>, <i>dt</i>), TimeWithinDay(<i>t</i>)).</p>
      <p>Let <i>v</i> be TimeClip(<i>newDate</i>).</p>
      <p>Set the [[PrimitiveValue]] internal property of this Date object to <i>v</i>.</p>
      <p>Return <i>v</i>.</p>
      <p>The <b>length</b> property of the <b>setUTCFullYear</b> method is <b>3</b>.</p>
      <h2>15.9.5.42<span>	Date.prototype.toUTCString</span> ( )</h2>
      <p>This function returns a String value. The contents of the String are implementation-dependent, but are intended to represent the Date in a convenient, human-readable form in UTC.</p>
      <p>NOTE<span>	The intent is to produce a String representation of a date that is more readable than the format specified in 15.9.1.15. It is not essential that the chosen format be unambiguous or easily machine parsable. If an implementation does not have a preferred human-readable format it is recommended to use the format defined in 15.9.1.15 but with a space rather than a “</span>T” used to separate the date and time elements.</p>
      <h2>15.9.5.43<span>	Date.prototype.toISOString ( )</span></h2>
      <p>This function returns a String value represent the instance in time represented by this Date object. The format of the String is the Date Time string format defined in 15.9.1.15. All fields are present in the String. The time zone is always UTC, denoted by the suffix Z. If the time value of this object is not a finite Number a <b>RangeError</b> exception is thrown.</p>
      <h2>15.9.5.44<span>	Date.prototype.toJSON ( key )</span></h2>
      <p>This function provides a String representation of a Date object for use by <b>JSON.stringify</b> (15.12.3).</p>
      <p>When the <b>toJSON</b> method is called with argument <i>key</i>, the following steps are taken:</p>
      <p>Let <i>O</i> be the result of calling ToObject, giving it the <b>this</b> value as its argument.</p>
      <p>Let <i>tv</i> be ToPrimitive(<i>O</i>, hint Number).</p>
      <p>If <i>tv</i> is a Number and is not finite, return <b>null</b>.</p>
      <p>Let <i>toISO</i> be the result of calling the [[Get]] internal method of <i>O </i>with argument "<b>toISOString</b>".</p>
      <p>If IsCallable(<i>toISO</i>) is <b>false</b>, throw a <b>TypeError </b>exception.</p>
      <p>Return the result of calling the [[Call]] internal method of <i>toISO</i> with <i>O </i>as the <b>this </b>value and an empty argument list.</p>
      <p>NOTE 1<span>	The argument is ignored.</span></p>
      <p>NOTE 2<span>	The </span><b>toJSON</b> function is intentionally generic; it does not require that its <b>this</b> value be a Date object. Therefore, it can be transferred to other kinds of objects for use as a method. However, it does require that any such object have a <b>toISOString</b> method. An object is free to use the argument <i>key</i> to filter its stringification. </p>
      <h2>15.9.6<span>	Properties of Date Instance</span>s</h2>
      <p>Date instances inherit properties from the Date prototype object and have a [[NativeBrand]] internal whose value is NativeDate. Date instances also have a [[PrimitiveValue]] internal property.</p>
      <p>The [[PrimitiveValue]] internal property is time value represented by this Date object.</p>
      <h2>15.10<span>	RegExp (Regular Expression) Objects</span></h2>
      <p>A RegExp object contains a regular expression and the associated flags.</p>
      <p>NOTE<span>	The form and functionality of regular expressions is modelled after the regular expression facility in the Perl 5 programming language.</span></p>
      <h2>15.10.1<span>	Patterns</span></h2>
      <p>The <b>RegExp</b> constructor applies the following grammar to the input pattern String. An error occurs if the grammar cannot interpret the String as an expansion of <i>Pattern</i>.</p>
      <p>Syntax</p>
      <p>Pattern <b>::</b></p>
      <p>Disjunction</p>
      <p>Disjunction <b>::</b></p>
      <p>Alternative<span><br> Alternative </span><b>|</b> Disjunction</p>
      <p>Alternative <b>::</b></p>
      <p>[empty]<span><br>Alternative Term</span></p>
      <p>Term <b>::</b></p>
      <p>Assertion<span><br>Atom</span><span><br>Atom Quantifier</span></p>
      <p>Assertion <b>::</b></p>
      <p><b>^</b><br><b>$</b><br><b>\ b</b><br><b>\ B</b><b><br>(</b><b> </b><b>?</b><b> </b><b>=</b><b> </b>Disjunction <b>)</b><br><b>(</b><b> </b><b>?</b><b> </b><b>!</b><b> </b>Disjunction <b>)</b></p>
      <p>Quantifier <b>::</b></p>
      <p>QuantifierPrefix<span><br>QuantifierPrefix</span><b> ?</b></p>
      <p>QuantifierPrefix <b>::</b></p>
      <p><b>*</b><b><br>+</b><br><b>?</b><br><b>{</b> DecimalDigits <b>}</b><br><b>{</b> DecimalDigits<b> </b><b>,</b><b> </b><b>}</b><br><b>{</b> DecimalDigits<b> </b><b>,</b> DecimalDigits <b>}</b></p>
      <p>Atom <b>::</b></p>
      <p>PatternCharacter<br>.<br><b>\ </b>AtomEscape<span><br>CharacterClass</span><b><br>(</b><b> </b>Disjunction <b>)</b><br><b>(</b><b> </b><b>?</b><b> </b><b>:</b><b> </b>Disjunction <b>)</b></p>
      <p>PatternCharacter <b>::</b> </p>
      <p>SourceCharacter <b>but not</b> <b>one of</b><br><b>   ^  </b><b>$  \  .  *  +  ?  (  )  [  ]  {  }  |</b></p>
      <p>AtomEscape <b>::</b></p>
      <p>DecimalEscape<span><br>CharacterEscape</span><span><br>CharacterClassEscape</span></p>
      <p>CharacterEscape <b>::</b></p>
      <p>ControlEscape<br><b>c </b>ControlLetter<span><br>HexEscapeSequence</span><span><br>UnicodeEscapeSequence</span><span><br>IdentityEscape</span></p>
      <p>ControlEscape <b>::</b><b>  </b><b>one of</b></p>
      <p>
        <b>f  n  r  t  v</b>
      </p>
      <p>ControlLetter <b>::</b><b> </b><b>one of</b></p>
      <p>
        <b>a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z</b>
        <b><br>A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z</b>
      </p>
      <p>IdentityEscape <b>::</b></p>
      <p>SourceCharacter <b>but not</b><b> </b>IdentifierPart<br>&lt;ZWJ&gt;<span><br>&lt;ZWNJ&gt;</span></p>
      <p>DecimalEscape <b>::</b></p>
      <p>DecimalIntegerLiteral  [lookahead ∈ DecimalDigit]</p>
      <p>CharacterClassEscape <b>::</b><b>  </b><b>one of</b></p>
      <p>
        <b>d  D  s  S  w  W</b>
      </p>
      <p>CharacterClass  <b>::</b></p>
      <p><b>[ </b>[lookahead ∈ {<b>^</b>}]<b> </b>ClassRanges<b> ]</b><br><b>[ ^ </b>ClassRanges<b> ]</b></p>
      <p>ClassRanges <b>::</b></p>
      <p>[empty]<span><br>NonemptyClassRanges</span></p>
      <p>NonemptyClassRanges <b>::</b></p>
      <p>ClassAtom<span><br>ClassAtom NonemptyClassRangesNoDash</span><span><br>ClassAtom</span><b> - </b>ClassAtom ClassRanges</p>
      <p>NonemptyClassRangesNoDash <b>::</b></p>
      <p>ClassAtom<span><br>ClassAtomNoDash NonemptyClassRangesNoDash</span><span><br>ClassAtomNoDash</span><b> - </b>ClassAtom ClassRanges</p>
      <p>ClassAtom <b>::</b></p>
      <p>
        <b>-</b>
        <span><br>ClassAtomNoDash</span>
      </p>
      <p>ClassAtomNoDash <b>::</b></p>
      <p>SourceCharacter  <b>but not</b> <b>one of</b> <b>\</b> <b>or</b> <b>]</b> <b>or</b> <b>-</b><br><b>\</b> ClassEscape</p>
      <p>ClassEscape <b>::</b></p>
      <p>DecimalEscape<br><b>b</b><span><br>CharacterEscape</span><b><br></b>CharacterClassEscape</p>
      <h2>15.10.2<span>	Pattern Semantics</span></h2>
      <p>A regular expression pattern is converted into an internal procedure using the process described below. An implementation is encouraged to use more efficient algorithms than the ones listed below, as long as the results are the same. The internal procedure is used as the value of a RegExp object’s [[Match]] internal property.</p>
      <h2>15.10.2.1<span>	Notation</span></h2>
      <p>The descriptions below use the following variables:</p>
      <p><i>Input</i> is the String being matched by the regular expression pattern. The notation <i>input</i>[<i>n</i>] means the <i>n</i><span style="vertical-align: super; font-style: italic">th</span> character of <i>input</i>, where <i>n</i> can range between 0 (inclusive) and <i>InputLength</i> (exclusive).</p>
      <p><i>InputLength</i> is the number of characters in the <i>Input</i> String.</p>
      <p><i>NcapturingParens</i> is the total number of left capturing parentheses (i.e. the total number of times the <i>Atom</i> <b>::</b> <b>(</b><b> </b><i>Disjunction</i> <b>)</b> production is expanded) in the pattern. A left capturing parenthesis is any <b>(</b> pattern character that is matched by the <b>(</b> terminal of the <i>Atom</i> <b>::</b> <b>(</b><b> </b><i>Disjunction</i> <b>)</b> production.</p>
      <p><i>IgnoreCase</i> is the setting of the RegExp object's <b>ignoreCase</b> property.</p>
      <p><i>Multiline</i> is the setting of the RegExp object’s <b>multiline</b> property.</p>
      <p>Furthermore, the descriptions below use the following internal data structures:</p>
      <p>A <i>CharSet</i> is a mathematical set of characters.</p>
      <p>A <i>State</i> is an ordered pair (<i>endIndex</i>, <i>captures</i>) where <i>endIndex</i> is an integer and <i>captures</i> is an internal array of <i>NcapturingParens</i> values. <i>States</i> are used to represent partial match states in the regular expression matching algorithms. The <i>endIndex</i> is one plus the index of the last input character matched so far by the pattern, while <i>captures</i> holds the results of capturing parentheses. The <i>n</i><span style="vertical-align: super; font-style: italic">th</span> element of <i>captures</i> is either a String that represents the value obtained by the <i>n</i><span style="vertical-align: super; font-style: italic">th</span> set of capturing parentheses or <b>undefined</b> if the <i>n</i><span style="vertical-align: super; font-style: italic">th</span> set of capturing parentheses hasn’t been reached yet. Due to backtracking, many <i>States</i> may be in use at any time during the matching process.</p>
      <p>A <i>MatchResult</i> is either a <i>State</i> or the special token <b>failure</b> that indicates that the match failed.</p>
      <p>A <i>Continuation</i> procedure is an internal closure (i.e. an internal procedure with some arguments already bound to values) that takes one <i>State</i> argument and returns a <i>MatchResult</i> result. If an internal closure references variables bound in the function that creates the closure, the closure uses the values that these variables had at the time the closure was created. The <i>Continuation</i> attempts to match the remaining portion (specified by the closure's already-bound arguments) of the pattern against the input String, starting at the intermediate state given by its <i>State</i> argument. If the match succeeds, the <i>Continuation</i> returns the final <i>State</i> that it reached; if the match fails, the <i>Continuation</i> returns <b>failure</b>.</p>
      <p>A <i>Matcher</i> procedure is an internal closure that takes two arguments -- a <i>State</i> and a <i>Continuation</i> -- and returns a <i>MatchResult</i> result. A <i>Matcher</i> attempts to match a middle subpattern (specified by the closure's already-bound arguments) of the pattern against the input String, starting at the intermediate state given by its <i>State</i> argument. The <i>Continuation</i> argument should be a closure that matches the rest of the pattern. After matching the subpattern of a pattern to obtain a new <i>State</i>, the <i>Matcher</i> then calls <i>Continuation</i> on that new <i>State</i> to test if the rest of the pattern can match as well. If it can, the <i>Matcher</i> returns the <i>State</i> returned by <i>Continuation</i>; if not, the <i>Matcher</i> may try different choices at its choice points, repeatedly calling <i>Continuation</i> until it either succeeds or all possibilities have been exhausted.</p>
      <p>An <i>AssertionTester</i> procedure is an internal closure that takes a <i>State</i> argument and returns a Boolean result. The assertion tester tests a specific condition (specified by the closure's already-bound arguments) against the current place in the input String and returns <b>true</b> if the condition matched or <b>false</b> if not.</p>
      <p>An <i>EscapeValue</i> is either a character or an integer. An <i>EscapeValue</i> is used to denote the interpretation of a <i>DecimalEscape</i> escape sequence: a character <i>ch</i> means that the escape sequence is interpreted as the character <i>ch</i>, while an integer <i>n</i> means that the escape sequence is interpreted as a backreference to the <i>n</i><sup>th</sup> set of capturing parentheses.</p>
      <h2>15.10.2.2<span>	Pattern</span></h2>
      <p>The production <i>Pattern</i><b> :: </b><i>Disjunction</i><b> </b>evaluates as follows:</p>
      <p>Evaluate <i>Disjunction</i> to obtain a Matcher <i>m</i>.</p>
      <p>Return an internal closure that takes two arguments, a String <i>str</i> and an integer <i>index</i>, and performs the following:</p>
      <p>Let <i>Input</i> be the given String <i>str</i>. This variable will be used throughout the algorithms in 15.10.2.</p>
      <p>Let <i>InputLength</i> be the length of <i>Input</i>. This variable will be used throughout the algorithms in 15.10.2.</p>
      <p>Let <i>c</i> be a Continuation that always returns its State argument as a successful MatchResult.</p>
      <p>Let <i>cap</i> be an internal array of <i>NcapturingParens</i> <b>undefined</b> values, indexed 1 through <i>NcapturingParens</i>.</p>
      <p>Let <i>x</i> be the State (<i>index</i>, <i>cap</i>).</p>
      <p>Call <i>m</i>(<i>x</i>, <i>c</i>) and return its result.</p>
      <p>NOTE<span>	A Pattern evaluates ("compiles") to an internal procedure value. </span><b>RegExp.prototype.exec</b> can then apply this procedure to a String and an offset within the String to determine whether the pattern would match starting at exactly that offset within the String, and, if it does match, what the values of the capturing parentheses would be. The algorithms in 15.10.2 are designed so that compiling a pattern may throw a <b>SyntaxError</b> exception; on the other hand, once the pattern is successfully compiled, applying its result internal procedure to find a match in a String cannot throw an exception (except for any host-defined exceptions that can occur anywhere such as out-of-memory).</p>
      <h2>15.10.2.3<span>	Disjunction</span></h2>
      <p>The production <i>Disjunction</i> <b>:: </b><i>Alternative</i> evaluates by evaluating <i>Alternative</i> to obtain a <i>Matcher</i> and returning that <i>Matcher</i>.</p>
      <p>The production <i>Disjunction</i> <b>:: </b><i>Alternative</i> <b>|</b> <i>Disjunction</i> evaluates as follows:</p>
      <p>Evaluate <i>Alternative</i> to obtain a Matcher <i>m1</i>.</p>
      <p>Evaluate <i>Disjunction</i> to obtain a Matcher <i>m2</i>.</p>
      <p>Return an internal Matcher closure that takes two arguments, a State <i>x</i> and a Continuation <i>c</i>, and performs the following:</p>
      <p>Call <i>m1</i>(<i>x</i>, <i>c</i>) and let <i>r</i> be its result.</p>
      <p>If <i>r</i> isn't <b>failure</b>, return <i>r</i>.</p>
      <p>Call <i>m2</i>(<i>x</i>, <i>c</i>) and return its result.</p>
      <p>NOTE<span>	The </span><b>|</b> regular expression operator separates two alternatives. The pattern first tries to match the left <i>Alternative</i> (followed by the sequel of the regular expression); if it fails, it tries to match the right <i>Disjunction</i> (followed by the sequel of the regular expression). If the left <i>Alternative</i>, the right <i>Disjunction</i>, and the sequel all have choice points, all choices in the sequel are tried before moving on to the next choice in the left <i>Alternative</i>. If choices in the left <i>Alternative</i> are exhausted, the right <i>Disjunction</i> is tried instead of the left <i>Alternative</i>. Any capturing parentheses inside a portion of the pattern skipped by <b>|</b> produce <b>undefined</b> values instead of Strings. Thus, for example,</p>
      <p>/a|ab/.exec("abc")</p>
      <p>returns the result <b>"a"</b> and not <b>"ab"</b>. Moreover,</p>
      <p>/((a)|(ab))((c)|(bc))/.exec("abc")</p>
      <p>returns the array</p>
      <p>["abc", "a", "a", undefined, "bc", undefined, "bc"]</p>
      <p>and not</p>
      <p>["abc", "ab", undefined, "ab", "c", "c", undefined]</p>
      <h2>15.10.2.4<span>	Alternative</span></h2>
      <p>The production <i>Alternative</i> <b>:: </b>[empty] evaluates by returning a Matcher that takes two arguments, a State <i>x</i> and a Continuation <i>c</i>, and returns the result of calling <i>c</i>(<i>x</i>).</p>
      <p>The production <i>Alternative</i> <b>:: </b><i>Alternative</i> <i>Term</i> evaluates as follows:</p>
      <p>Evaluate <i>Alternative</i> to obtain a Matcher <i>m1</i>.</p>
      <p>Evaluate <i>Term</i> to obtain a Matcher <i>m2</i>.</p>
      <p>Return an internal Matcher closure that takes two arguments, a State <i>x</i> and a Continuation <i>c</i>, and performs the following:</p>
      <p>Create a Continuation <i>d</i> that takes a State argument <i>y</i> and returns the result of calling <i>m2</i>(<i>y</i>, <i>c</i>).</p>
      <p>Call <i>m1</i>(<i>x</i>, <i>d</i>) and return its result.</p>
      <p>NOTE<span>	Consecutive </span><i>Terms</i> try to simultaneously match consecutive portions of the input String. If the left <i>Alternative</i>, the right <i>Term</i>, and the sequel of the regular expression all have choice points, all choices in the sequel are tried before moving on to the next choice in the right <i>Term</i>, and all choices in the right <i>Term</i> are tried before moving on to the next choice in the left <i>Alternative</i>.</p>
      <h2>15.10.2.5<span>	Term</span></h2>
      <p>The production <i>Term</i> <b>:: </b><i>Assertion</i> evaluates by returning an internal Matcher closure that takes two arguments, a State <i>x</i> and a Continuation <i>c</i>, and performs the following:</p>
      <p>Evaluate <i>Assertion</i> to obtain an AssertionTester <i>t</i>.</p>
      <p>Call <i>t</i>(<i>x</i>) and let <i>r</i> be the resulting Boolean value.</p>
      <p>If <i>r</i> is <b>false</b>, return <b>failure</b>.</p>
      <p>Call <i>c</i>(<i>x</i>) and return its result.</p>
      <p>The production <i>Term</i> <b>:: </b><i>Atom</i> evaluates by evaluating <i>Atom</i> to obtain a Matcher and returning that Matcher.</p>
      <p>The production <i>Term</i> <b>:: </b><i>Atom</i> <i>Quantifier</i> evaluates as follows:</p>
      <p>Evaluate <i>Atom</i> to obtain a Matcher <i>m</i>.</p>
      <p>Evaluate <i>Quantifier</i> to obtain the three results: an integer <i>min</i>, an integer (or ∞) <i>max</i>, and Boolean <i>greedy</i>.</p>
      <p>If <i>max</i> is finite and less than <i>min</i>, then throw a <b>SyntaxError</b> exception.</p>
      <p>Let <i>parenIndex</i> be the number of left capturing parentheses in the entire regular expression that occur to the left of this production expansion's <i>Term</i>. This is the total number of times the <i>Atom</i> :: <b>(</b><b> </b><i>Disjunction</i> <b>)</b> production is expanded prior to this production's <i>Term</i> plus the total number of <i>Atom</i> :: <b>(</b><b> </b><i>Disjunction</i> <b>)</b> productions enclosing this <i>Term</i>.</p>
      <p>Let <i>parenCount</i> be the number of left capturing parentheses in the expansion of this production's <i>Atom</i>. This is the total number of <i>Atom</i> :: <b>(</b><b> </b><i>Disjunction</i> <b>)</b> productions enclosed by this production's <i>Atom</i>.</p>
      <p>Return an internal Matcher closure that takes two arguments, a State <i>x</i> and a Continuation <i>c</i>, and performs the following:</p>
      <p>Call RepeatMatcher(<i>m</i>, <i>min</i>, <i>max</i>, <i>greedy</i>, <i>x</i>, <i>c</i>, <i>parenIndex</i>, <i>parenCount</i>) and return its result.</p>
      <p>The abstract operation <i>RepeatMatcher</i> takes eight parameters, a Matcher <i>m</i>, an integer <i>min</i>, an integer (or ∞) <i>max</i>, a Boolean <i>greedy</i>, a State <i>x</i>, a Continuation <i>c</i>, an integer <i>parenIndex</i>, and an integer <i>parenCount</i>, and performs the following:</p>
      <p>If <i>max</i> is zero, then call <i>c</i>(<i>x</i>) and return its result.</p>
      <p>Create an internal Continuation closure <i>d</i> that takes one State argument <i>y</i> and performs the following:</p>
      <p>If <i>min</i> is zero and <i>y</i>'s <i>endIndex</i> is equal to <i>x</i>'s <i>endIndex</i>, then return <b>failure</b>.</p>
      <p>If <i>min</i> is zero then let <i>min2</i> be zero; otherwise let <i>min2</i> be <i>min</i>–1.</p>
      <p>If <i>max</i> is ∞, then let <i>max2</i> be ∞; otherwise let <i>max2</i> be <i>max</i>–1.</p>
      <p>Call RepeatMatcher(<i>m</i>, <i>min2</i>, <i>max2</i>, <i>greedy</i>, <i>y</i>, <i>c</i>, <i>parenIndex</i>, <i>parenCount</i>) and return its result.</p>
      <p>Let <i>cap</i> be a fresh copy of <i>x</i>'s <i>captures</i> internal array.</p>
      <p>For every integer <i>k</i> that satisfies <i>parenIndex</i> &lt; <i>k</i> and <i>k</i> ≤ <i>parenIndex</i>+<i>parenCount</i>, set <i>cap</i>[<i>k</i>] to <b>undefined</b>.</p>
      <p>Let <i>e</i> be <i>x</i>'s <i>endIndex</i>.</p>
      <p>Let <i>xr</i> be the State (<i>e</i>, <i>cap</i>).</p>
      <p>If <i>min</i> is not zero, then call <i>m</i>(<i>xr</i>, <i>d</i>) and return its result.</p>
      <p>If <i>greedy</i> is <b>false</b>, then</p>
      <p>Call <i>c</i>(<i>x</i>) and let <i>z</i> be its result.</p>
      <p>If <i>z</i> is not <b>failure</b>, return <i>z</i>.</p>
      <p>Call <i>m</i>(<i>xr</i>, <i>d</i>) and return its result.</p>
      <p>Call <i>m</i>(<i>xr</i>, <i>d</i>) and let <i>z</i> be its result.</p>
      <p>If <i>z</i> is not <b>failure</b>, return <i>z</i>.</p>
      <p>Call <i>c</i>(<i>x</i>) and return its result.</p>
      <p>NOTE 1<span>	An </span>Atom followed by a Quantifier is repeated the number of times specified by the Quantifier. A Quantifier can be non-greedy, in which case the Atom pattern is repeated as few times as possible while still matching the sequel, or it can be greedy, in which case the Atom pattern is repeated as many times as possible while still matching the sequel. The Atom pattern is repeated rather than the input String that it matches, so different repetitions of the Atom can match different input substrings.</p>
      <p>NOTE 2<span>	If the </span>Atom and the sequel of the regular expression all have choice points, the Atom is first matched as many (or as few, if non-greedy) times as possible. All choices in the sequel are tried before moving on to the next choice in the last repetition of Atom. All choices in the last (n<sup>th</sup>) repetition of Atom are tried before moving on to the next choice in the next-to-last (n–1)<sup>st</sup> repetition of Atom; at which point it may turn out that more or fewer repetitions of Atom are now possible; these are exhausted (again, starting with either as few or as many as possible) before moving on to the next choice in the (n-1)<sup>st</sup> repetition of Atom and so on.</p>
      <p>Compare</p>
      <p>/a[a-z]{2,4}/.exec("abcdefghi")</p>
      <p>which returns <b>"abcde"</b> with</p>
      <p>/a[a-z]{2,4}?/.exec("abcdefghi")</p>
      <p>which returns <b>"abc"</b>.</p>
      <p>Consider also</p>
      <p>/(aa|aabaac|ba|b|c)*/.exec("aabaac")</p>
      <p>which, by the choice point ordering above, returns the array</p>
      <p>["aaba", "ba"]</p>
      <p>and not any of:</p>
      <p>["aabaac", "aabaac"]</p>
      <p>["aabaac", "c"]</p>
      <p>The above ordering of choice points can be used to write a regular expression that calculates the greatest common divisor of two numbers (represented in unary notation). The following example calculates the gcd of 10 and 15:</p>
      <p>"aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/,"$1")</p>
      <p>which returns the gcd in unary notation <b>"aaaaa"</b>.</p>
      <p>NOTE 3<span>	Step 4 of the RepeatMatcher clears </span>Atom's captures each time Atom is repeated. We can see its behaviour in the regular expression</p>
      <p>/(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")</p>
      <p>which returns the array</p>
      <p>["zaacbbbcac", "z", "ac", "a", undefined, "c"]</p>
      <p>and not</p>
      <p>["zaacbbbcac", "z", "ac", "a", "bbb", "c"]</p>
      <p>because each iteration of the outermost <b>*</b> clears all captured Strings contained in the quantified Atom, which in this case includes capture Strings numbered 2, 3, 4, and 5.</p>
      <p>NOTE 4<span>	Step 1 of the RepeatMatcher's </span><i>d</i> closure states that, once the minimum number of repetitions has been satisfied, any more expansions of Atom that match the empty String are not considered for further repetitions. This prevents the regular expression engine from falling into an infinite loop on patterns such as:</p>
      <p>/(a*)*/.exec("b")</p>
      <p>or the slightly more complicated:</p>
      <p>/(a*)b\1+/.exec("baaaac")</p>
      <p>which returns the array</p>
      <p>["b", ""]</p>
      <h2>15.10.2.6<span>	Assertion</span></h2>
      <p>The production <i>Assertion</i> <b>:: </b><b>^</b> evaluates by returning an internal AssertionTester closure that takes a State argument <i>x</i> and performs the following:</p>
      <p>Let <i>e</i> be <i>x</i>'s <i>endIndex</i>.</p>
      <p>If <i>e</i> is zero, return <b>true</b>.</p>
      <p>If <i>Multiline</i> is <b>false</b>, return <b>false</b>.</p>
      <p>If the character <i>Input</i>[<i>e</i>–1] is one of <i>LineTerminator</i>, return <b>true</b>.</p>
      <p>Return <b>false</b>.</p>
      <p>The production <i>Assertion</i> <b>:: </b><b>$</b> evaluates by returning an internal AssertionTester closure that takes a State argument <i>x</i> and performs the following:</p>
      <p>Let <i>e</i> be <i>x</i>'s <i>endIndex</i>.</p>
      <p>If <i>e</i> is equal to <i>InputLength</i>, return <b>true</b>.</p>
      <p>If <i>multiline</i> is <b>false</b>, return <b>false</b>.</p>
      <p>If the character <i>Input</i>[<i>e</i>] is one of <i>LineTerminator</i>, return <b>true</b>.</p>
      <p>Return <b>false</b>.</p>
      <p>The production <i>Assertion</i> <b>:: </b><b>\ b</b> evaluates by returning an internal AssertionTester closure that takes a State argument <i>x</i> and performs the following:</p>
      <p>Let <i>e</i> be <i>x</i>'s <i>endIndex</i>.</p>
      <p>Call <i>IsWordChar</i>(<i>e</i>–1) and let <i>a</i> be the Boolean result.</p>
      <p>Call <i>IsWordChar</i>(<i>e</i>) and let <i>b</i> be the Boolean result.</p>
      <p>If <i>a</i> is <b>true</b> and <i>b</i> is <b>false</b>, return <b>true</b>.</p>
      <p>If <i>a</i> is <b>false</b> and <i>b</i> is <b>true</b>, return <b>true</b>.</p>
      <p>Return <b>false</b>.</p>
      <p>The production <i>Assertion</i> <b>:: </b><b>\ B</b> evaluates by returning an internal AssertionTester closure that takes a State argument <i>x</i> and performs the following:</p>
      <p>Let <i>e</i> be <i>x</i>'s <i>endIndex</i>.</p>
      <p>Call <i>IsWordChar</i>(<i>e</i>–1) and let <i>a</i> be the Boolean result.</p>
      <p>Call <i>IsWordChar</i>(<i>e</i>) and let b be the Boolean result.</p>
      <p>If a is <b>true</b> and b is <b>false</b>, return <b>false</b>.</p>
      <p>If a is <b>false</b> and b is <b>true</b>, return <b>false</b>.</p>
      <p>Return <b>true</b>.</p>
      <p>The production <i>Assertion</i> <b>:: </b><b>( ? = </b><i>Disjunction</i><b> )</b> evaluates as follows:</p>
      <p>Evaluate <i>Disjunction</i> to obtain a Matcher <i>m</i>.</p>
      <p>Return an internal Matcher closure that takes two arguments, a State <i>x</i> and a Continuation <i>c</i>, and performs the following steps:</p>
      <p>Let <i>d</i> be a Continuation that always returns its State argument as a successful MatchResult.</p>
      <p>Call <i>m</i>(<i>x</i>, <i>d</i>) and let <i>r</i> be its result.</p>
      <p>If <i>r</i> is <b>failure</b>, return <b>failure</b>.</p>
      <p>Let <i>y</i> be <i>r</i>'s State.</p>
      <p>Let <i>cap</i> be <i>y</i>'s <i>captures</i> internal array.</p>
      <p>Let <i>xe</i> be <i>x</i>'s <i>endIndex</i>.</p>
      <p>Let <i>z</i> be the State (<i>xe</i>, <i>cap</i>).</p>
      <p>Call <i>c</i>(<i>z</i>) and return its result.</p>
      <p>The production <i>Assertion </i><b>:: </b><b>( ? ! </b><i>Disjunction</i><b> )</b> evaluates as follows:</p>
      <p>Evaluate <i>Disjunction</i> to obtain a Matcher <i>m</i>.</p>
      <p>Return an internal Matcher closure that takes two arguments, a State <i>x</i> and a Continuation <i>c</i>, and performs the following steps:</p>
      <p>Let <i>d</i> be a Continuation that always returns its State argument as a successful MatchResult.</p>
      <p>Call <i>m</i>(<i>x</i>, <i>d</i>) and let <i>r</i> be its result.</p>
      <p>If <i>r</i> isn't <b>failure</b>, return <b>failure</b>.</p>
      <p>Call <i>c</i>(<i>x</i>) and return its result.</p>
      <p>The abstract operation <i>IsWordChar</i> takes an integer parameter <i>e</i> and performs the following:</p>
      <p>If <i>e</i> == –1 or <i>e</i> == <i>InputLength</i>, return <b>false</b>.</p>
      <p>Let <i>c</i> be the character <i>Input</i>[<i>e</i>].</p>
      <p>If <i>c</i> is one of the sixty-three characters below, return <b>true</b>.</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>a</p>
            </td>
            <td>
              <p>b</p>
            </td>
            <td>
              <p>c</p>
            </td>
            <td>
              <p>d</p>
            </td>
            <td>
              <p>e</p>
            </td>
            <td>
              <p>f</p>
            </td>
            <td>
              <p>g</p>
            </td>
            <td>
              <p>h</p>
            </td>
            <td>
              <p>i</p>
            </td>
            <td>
              <p>j</p>
            </td>
            <td>
              <p>k</p>
            </td>
            <td>
              <p>l</p>
            </td>
            <td>
              <p>m</p>
            </td>
            <td>
              <p>n</p>
            </td>
            <td>
              <p>o</p>
            </td>
            <td>
              <p>p</p>
            </td>
            <td>
              <p>q</p>
            </td>
            <td>
              <p>r</p>
            </td>
            <td>
              <p>s</p>
            </td>
            <td>
              <p>t</p>
            </td>
            <td>
              <p>u</p>
            </td>
            <td>
              <p>v</p>
            </td>
            <td>
              <p>w</p>
            </td>
            <td>
              <p>x</p>
            </td>
            <td>
              <p>y</p>
            </td>
            <td>
              <p>z</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>A</p>
            </td>
            <td>
              <p>B</p>
            </td>
            <td>
              <p>C</p>
            </td>
            <td>
              <p>D</p>
            </td>
            <td>
              <p>E</p>
            </td>
            <td>
              <p>F</p>
            </td>
            <td>
              <p>G</p>
            </td>
            <td>
              <p>H</p>
            </td>
            <td>
              <p>I</p>
            </td>
            <td>
              <p>J</p>
            </td>
            <td>
              <p>K</p>
            </td>
            <td>
              <p>L</p>
            </td>
            <td>
              <p>M</p>
            </td>
            <td>
              <p>N</p>
            </td>
            <td>
              <p>O</p>
            </td>
            <td>
              <p>P</p>
            </td>
            <td>
              <p>Q</p>
            </td>
            <td>
              <p>R</p>
            </td>
            <td>
              <p>S</p>
            </td>
            <td>
              <p>T</p>
            </td>
            <td>
              <p>U</p>
            </td>
            <td>
              <p>V</p>
            </td>
            <td>
              <p>W</p>
            </td>
            <td>
              <p>X</p>
            </td>
            <td>
              <p>Y</p>
            </td>
            <td>
              <p>Z</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>0</p>
            </td>
            <td>
              <p>1</p>
            </td>
            <td>
              <p>2</p>
            </td>
            <td>
              <p>3</p>
            </td>
            <td>
              <p>4</p>
            </td>
            <td>
              <p>5</p>
            </td>
            <td>
              <p>6</p>
            </td>
            <td>
              <p>7</p>
            </td>
            <td>
              <p>8</p>
            </td>
            <td>
              <p>9</p>
            </td>
            <td>
              <p>_</p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>Return <b>false</b>.</p>
      <h2>15.10.2.7<span>	Quantifier</span></h2>
      <p>The production <i>Quantifier</i> :: <i>QuantifierPrefix</i> evaluates as follows:</p>
      <p>Evaluate <i>QuantifierPrefix</i> to obtain the two results: an integer <i>min</i> and an integer (or ∞) <i>max</i>.</p>
      <p>Return the three results <i>min</i>, <i>max</i>, and <b>true</b>.</p>
      <p>The production <i>Quantifier</i> <b>:: </b><i>QuantifierPrefix</i><b> ?</b> evaluates as follows:</p>
      <p>Evaluate <i>QuantifierPrefix</i> to obtain the two results: an integer <i>min</i> and an integer (or ∞) <i>max</i>.</p>
      <p>Return the three results <i>min</i>, <i>max</i>, and <b>false</b>.</p>
      <p>The production <i>QuantifierPrefix</i> <b>:: </b><b>*</b> evaluates by returning the two results 0 and ∞.</p>
      <p>The production <i>QuantifierPrefix</i> <b>:: </b><b>+</b> evaluates by returning the two results 1 and ∞.</p>
      <p>The production <i>QuantifierPrefix</i> <b>:: </b><b>?</b> evaluates by returning the two results 0 and 1.</p>
      <p>The production <i>QuantifierPrefix</i> <b>:: </b><b>{ </b><i>DecimalDigits</i><b> }</b> evaluates as follows:</p>
      <p>Let <i>i</i> be the MV of <i>DecimalDigits</i> (see 7.8.3).</p>
      <p>Return the two results <i>i</i> and <i>i</i>.</p>
      <p>The production <i>QuantifierPrefix</i> <b>:: </b><b>{ </b><i>DecimalDigits</i><b> , }</b> evaluates as follows:</p>
      <p>Let <i>i</i> be the MV of <i>DecimalDigits</i>.</p>
      <p>Return the two results <i>i</i> and ∞.</p>
      <p>The production <i>QuantifierPrefix</i> <b>:: </b><b>{ </b><i>DecimalDigits</i><b> , </b><i>DecimalDigits</i><b> }</b> evaluates as follows:</p>
      <p>Let <i>i</i> be the MV of the first <i>DecimalDigits</i>.</p>
      <p>Let <i>j</i> be the MV of the second <i>DecimalDigits</i>.</p>
      <p>Return the two results <i>i</i> and <i>j</i>.</p>
      <h2>15.10.2.8<span>	Atom</span></h2>
      <p>The production <i>Atom</i> <b>:: </b><i>PatternCharacter</i> evaluates as follows:</p>
      <p>Let <i>ch</i> be the character represented by <i>PatternCharacter</i>.</p>
      <p>Let <i>A</i> be a one-element CharSet containing the character <i>ch</i>.</p>
      <p>Call <i>CharacterSetMatcher</i>(<i>A</i>, <b>false</b>) and return its Matcher result.</p>
      <p>The production <i>Atom</i> <b>:: </b><b>.</b> evaluates as follows:</p>
      <p>Let <i>A</i> be the set of all characters except <i>LineTerminator</i>.</p>
      <p>Call <i>CharacterSetMatcher</i>(<i>A</i>, <b>false</b>) and return its Matcher result.</p>
      <p>The production <i>Atom</i> <b>:: </b><b>\ </b><i>AtomEscape</i> evaluates by evaluating <i>AtomEscape</i> to obtain a Matcher and returning that Matcher.</p>
      <p>The production <i>Atom</i> <b>:: </b><i>CharacterClass</i> evaluates as follows:</p>
      <p>Evaluate <i>CharacterClass</i> to obtain a CharSet <i>A</i> and a Boolean <i>invert</i>.</p>
      <p>Call <i>CharacterSetMatcher</i>(<i>A</i>, <i>invert</i>) and return its Matcher result.</p>
      <p>The production <i>Atom</i> <b>:: </b><b>( </b><i>Disjunction</i><b> )</b> evaluates as follows:</p>
      <p>Evaluate <i>Disjunction</i> to obtain a Matcher <i>m</i>.</p>
      <p>Let <i>parenIndex</i> be the number of left capturing parentheses in the entire regular expression that occur to the left of this production expansion's initial left parenthesis. This is the total number of times the <i>Atom</i> :: <b>(</b><b> </b><i>Disjunction </i><b>)</b> production is expanded prior to this production's <i>Atom</i> plus the total number of <i>Atom</i> :: <b>(</b><b> </b><i>Disjunction</i> <b>)</b> productions enclosing this <i>Atom</i>.</p>
      <p>Return an internal Matcher closure that takes two arguments, a State <i>x</i> and a Continuation <i>c</i>, and performs the following steps:</p>
      <p>Create an internal Continuation closure <i>d</i> that takes one State argument <i>y</i> and performs the following steps:</p>
      <p>Let <i>cap</i> be a fresh copy of <i>y</i>'s <i>captures</i> internal array.</p>
      <p>Let <i>xe</i> be <i>x</i>'s <i>endIndex</i>.</p>
      <p>Let <i>ye</i> be <i>y</i>'s <i>endIndex</i>.</p>
      <p>Let <i>s</i> be a fresh String whose characters are the characters of <i>Input</i> at positions <i>xe</i> (inclusive) through <i>ye</i> (exclusive).</p>
      <p>Set <i>cap</i>[<i>parenIndex</i>+1] to <i>s</i>.</p>
      <p>Let <i>z</i> be the State (<i>ye</i>, <i>cap</i>).</p>
      <p>Call <i>c</i>(<i>z</i>) and return its result.</p>
      <p>Call <i>m</i>(<i>x</i>, <i>d</i>) and return its result.</p>
      <p>The production <i>Atom</i> <b>:: </b><b>( ? : </b><i>Disjunction</i><b> )</b> evaluates by evaluating <i>Disjunction</i> to obtain a Matcher and returning that Matcher.</p>
      <p>The abstract operation <i>CharacterSetMatcher </i>takes two arguments, a CharSet <i>A</i> and a Boolean flag <i>invert</i>, and performs the following:</p>
      <p>Return an internal Matcher closure that takes two arguments, a State <i>x</i> and a Continuation <i>c</i>, and performs the following steps:</p>
      <p>Let <i>e</i> be <i>x</i>'s <i>endIndex</i>.</p>
      <p>If <i>e</i> == <i>InputLength</i>, return <b>failure</b>.</p>
      <p>Let <i>ch</i> be the character <i>Input</i>[<i>e</i>].</p>
      <p>Let <i>cc</i> be the result of <i>Canonicalize</i>(<i>ch</i>).</p>
      <p>If <i>invert</i> is <b>false</b>, then</p>
      <p>If there does not exist a member <i>a</i> of set <i>A</i> such that <i>Canonicalize</i>(<i>a</i>) == <i>cc</i>, return <b>failure</b>.</p>
      <p>Else <i>invert</i> is <b>true</b>,</p>
      <p>If there exists a member <i>a</i> of set <i>A</i> such that <i>Canonicalize</i>(<i>a</i>) == <i>cc</i>, return<b> failure.</b></p>
      <p>Let <i>cap</i> be <i>x</i>'s <i>captures</i> internal array.</p>
      <p>Let <i>y</i> be the State (<i>e</i>+1, <i>cap</i>).</p>
      <p>Call <i>c</i>(<i>y</i>) and return its result.</p>
      <p>The abstract operation <i>Canonicalize </i>takes a character parameter <i>ch</i> and performs the following steps:</p>
      <p>If <i>IgnoreCase</i> is <b>false</b>, return <i>ch</i>.</p>
      <p>Let <i>u</i> be <i>ch</i> converted to upper case as if by calling the standard built-in method <b>String.prototype.toUpperCase</b> on the one-character String <i>ch</i>.</p>
      <p>If <i>u</i> does not consist of a single character, return <i>ch</i>.</p>
      <p>Let <i>cu</i> be <i>u</i>'s character.</p>
      <p>If <i>ch</i>'s code unit value is greater than or equal to decimal 128 and <i>cu</i>'s code unit value is less than decimal 128, then return <i>ch</i>.</p>
      <p>Return <i>cu</i>.</p>
      <p>NOTE 1<span>	Parentheses of the form </span><b>( </b>Disjunction<b> )</b> serve both to group the components of the Disjunction pattern together and to save the result of the match. The result can be used either in a backreference (<b>\</b> followed by a nonzero decimal number), referenced in a replace String, or returned as part of an array from the regular expression matching internal procedure. To inhibit the capturing behaviour of parentheses, use the form <b>(?: </b>Disjunction<b> )</b> instead.</p>
      <p>NOTE 2<span>	The form </span><b>(?= </b>Disjunction<b> )</b> specifies a zero-width positive lookahead. In order for it to succeed, the pattern inside Disjunction must match at the current position, but the current position is not advanced before matching the sequel. If Disjunction can match at the current position in several ways, only the first one is tried. Unlike other regular expression operators, there is no backtracking into a <b>(?=</b> form (this unusual behaviour is inherited from Perl). This only matters when the Disjunction contains capturing parentheses and the sequel of the pattern contains backreferences to those captures.</p>
      <p>For example,</p>
      <p>/(?=(a+))/.exec("baaabac")</p>
      <p>matches the empty String immediately after the first <b>b</b> and therefore returns the array:</p>
      <p>["", "aaa"]</p>
      <p>To illustrate the lack of backtracking into the lookahead, consider:</p>
      <p>/(?=(a+))a*b\1/.exec("baaabac")</p>
      <p>This expression returns</p>
      <p>["aba", "a"]</p>
      <p>and not:</p>
      <p>["aaaba", "a"]</p>
      <p>NOTE 3<span>	The form </span><b>(?! </b>Disjunction<b> )</b> specifies a zero-width negative lookahead. In order for it to succeed, the pattern inside Disjunction must fail to match at the current position. The current position is not advanced before matching the sequel. Disjunction can contain capturing parentheses, but backreferences to them only make sense from within Disjunction itself. Backreferences to these capturing parentheses from elsewhere in the pattern always return <b>undefined</b> because the negative lookahead must fail for the pattern to succeed. For example,</p>
      <p>/(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")</p>
      <p>looks for an <b>a</b> not immediately followed by some positive number n of <b>a</b>'s, a <b>b</b>, another n <b>a</b>'s (specified by the first <b>\2</b>) and a <b>c</b>. The second <b>\2</b> is outside the negative lookahead, so it matches against <b>undefined</b> and therefore always succeeds. The whole expression returns the array:</p>
      <p>["baaabaac", "ba", undefined, "abaac"]</p>
      <p>In case-insignificant matches all characters are implicitly converted to upper case immediately before they are compared. However, if converting a character to upper case would expand that character into more than one character (such as converting <b>"ß"</b> (\u00DF) into <b>"SS"</b>), then the character is left as-is instead. The character is also left as-is if it is not an ASCII character but converting it to upper case would make it into an ASCII character. This prevents Unicode characters such as \u0131 and \u017F from matching regular expressions such as <b>/[a</b><b>z]/i</b>, which are only intended to match ASCII letters. Furthermore, if these conversions were allowed, then <b>/[^\W]/i</b> would match each of <b>a</b>, <b>b</b>, …, <b>h</b>, but not <b>i</b> or <b>s</b>.</p>
      <h2>15.10.2.9<span>	AtomEscape</span></h2>
      <p>The production <i>AtomEscape</i> <b>:: </b><i>DecimalEscape</i> evaluates as follows:</p>
      <p>Evaluate <i>DecimalEscape</i> to obtain an EscapeValue <i>E</i>.</p>
      <p>If <i>E</i> is a character, then</p>
      <p>Let <i>ch</i> be <i>E</i>'s character.</p>
      <p>Let <i>A</i> be a one-element CharSet containing the character <i>ch</i>.</p>
      <p>Call <i>CharacterSetMatcher</i>(<i>A</i>, <b>false</b>) and return its Matcher result.</p>
      <p><i>E</i> must be an integer. Let <i>n</i> be that integer.</p>
      <p>If <i>n</i>=0 or <i>n</i>&gt;<i>NCapturingParens</i> then throw a <b>SyntaxError</b> exception.</p>
      <p>Return an internal Matcher closure that takes two arguments, a State <i>x</i> and a Continuation <i>c</i>, and performs the following:</p>
      <p>Let <i>cap</i> be <i>x</i>'s <i>captures</i> internal array.</p>
      <p>Let <i>s</i> be <i>cap</i>[<i>n</i>].</p>
      <p>If <i>s</i> is <b>undefined</b>, then call <i>c</i>(<i>x</i>) and return its result.</p>
      <p>Let <i>e</i> be <i>x</i>'s <i>endIndex</i>.</p>
      <p>Let <i>len</i> be <i>s</i>'s length.</p>
      <p>Let <i>f</i> be <i>e</i>+<i>len</i>.</p>
      <p>If <i>f</i>&gt;<i>InputLength</i>, return <b>failure</b>.</p>
      <p>If there exists an integer <i>i</i> between 0 (inclusive) and <i>len</i> (exclusive) such that <i>Canonicalize</i>(<i>s</i>[<i>i</i>]) is not the same character as <i>Canonicalize</i>(<i>Input</i> [<i>e</i>+<i>i</i>]), then return <b>failure</b>.</p>
      <p>Let <i>y</i> be the State (<i>f</i>, <i>cap</i>).</p>
      <p>Call <i>c</i>(<i>y</i>) and return its result.</p>
      <p>The production <i>AtomEscape</i> <b>:: </b><i>CharacterEscape</i> evaluates as follows:</p>
      <p>Evaluate <i>CharacterEscape</i> to obtain a character <i>ch</i>.</p>
      <p>Let <i>A</i> be a one-element CharSet containing the character <i>ch</i>.</p>
      <p>Call <i>CharacterSetMatcher</i>(<i>A</i>, <b>false</b>) and return its Matcher result.</p>
      <p>The production <i>AtomEscape</i> <b>:: </b><i>CharacterClassEscape</i> evaluates as follows:</p>
      <p>Evaluate <i>CharacterClassEscape</i> to obtain a CharSet <i>A</i>.</p>
      <p>Call <i>CharacterSetMatcher</i>(<i>A</i>, <b>false</b>) and return its Matcher result.</p>
      <p>NOTE<span>	An escape sequence of the form </span><b>\</b> followed by a nonzero decimal number <i>n</i> matches the result of the <i>n</i>th set of capturing parentheses (see 15.10.2.11). It is an error if the regular expression has fewer than <i>n</i> capturing parentheses. If the regular expression has <i>n</i> or more capturing parentheses but the <i>n</i>th one is <b>undefined</b> because it has not captured anything, then the backreference always succeeds.</p>
      <h2>15.10.2.10<span>	CharacterEscape</span></h2>
      <p>The production <i>CharacterEscape</i> <b>:: </b><i>ControlEscape</i> evaluates by returning the character according to Table 25. </p>
      <p>Table 25 — ControlEscape Character Values</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">ControlEscape </span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Code Unit</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Name</span>
              </p>
            </td>
            <td>
              <p>
                <span style="font-weight: bold; font-style: italic">Symbol</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>t</b>
              </p>
            </td>
            <td>
              <p>
                <b>\u0009</b>
              </p>
            </td>
            <td>
              <p>horizontal tab</p>
            </td>
            <td>
              <p>&lt;HT&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>n</b>
              </p>
            </td>
            <td>
              <p>
                <b>\u000A</b>
              </p>
            </td>
            <td>
              <p>line feed (new line)</p>
            </td>
            <td>
              <p>&lt;LF&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>v</b>
              </p>
            </td>
            <td>
              <p>
                <b>\u000B</b>
              </p>
            </td>
            <td>
              <p>vertical tab</p>
            </td>
            <td>
              <p>&lt;VT&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>f</b>
              </p>
            </td>
            <td>
              <p>
                <b>\u000C</b>
              </p>
            </td>
            <td>
              <p>form feed</p>
            </td>
            <td>
              <p>&lt;FF&gt;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>
                <b>r</b>
              </p>
            </td>
            <td>
              <p>
                <b>\u000D</b>
              </p>
            </td>
            <td>
              <p>carriage return</p>
            </td>
            <td>
              <p>&lt;CR&gt;</p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>The production <i>CharacterEscape</i> <b>:: </b><b>c </b><i>ControlLetter</i> evaluates as follows:</p>
      <p>Let <i>ch</i> be the character represented by <i>ControlLetter</i>.</p>
      <p>Let <i>i</i> be <i>ch</i>'s code unit value.</p>
      <p>Let <i>j</i> be the remainder of dividing <i>i</i> by 32.</p>
      <p>Return the character whose code unit value is <i>j</i>.</p>
      <p>The production <i>CharacterEscape</i> <b>:: </b><i>HexEscapeSequence</i> evaluates by evaluating the CV of the <i>HexEscapeSequence</i> (see 7.8.4) and returning its character result.</p>
      <p>The production <i>CharacterEscape</i> <b>:: </b><i>UnicodeEscapeSequence</i> evaluates by evaluating the CV of the <i>UnicodeEscapeSequence</i> (see 7.8.4) and returning its character result.</p>
      <p>The production <i>CharacterEscape</i> <b>:: </b><i>IdentityEscape</i> evaluates by returning the character represented by <i>IdentityEscape</i>.</p>
      <h2>15.10.2.11<span>	DecimalEscape</span></h2>
      <p>The production <i>DecimalEscape</i> <b>:: </b><i>DecimalIntegerLiteral</i> [lookahead ∈ <i>DecimalDigit</i>] evaluates as follows:</p>
      <p>Let <i>i</i> be the MV of <i>DecimalIntegerLiteral</i>.</p>
      <p>If <i>i</i> is zero, return the EscapeValue consisting of a &lt;NUL&gt; character (Unicode value 0000).</p>
      <p>Return the EscapeValue consisting of the integer <i>i</i>.</p>
      <p>The definition of “the MV of <i>DecimalIntegerLiteral</i>” is in 7.8.3.</p>
      <p>NOTE<span>	If </span><b>\</b> is followed by a decimal number <i>n</i> whose first digit is not <b>0</b>, then the escape sequence is considered to be a backreference. It is an error if <i>n</i> is greater than the total number of left capturing parentheses in the entire regular expression. <b>\0</b> represents the &lt;NUL&gt; character and cannot be followed by a decimal digit.</p>
      <h2>15.10.2.12<span>	CharacterClassEscape</span></h2>
      <p>The production <i>CharacterClassEscape</i> <b>:: </b><b>d</b> evaluates by returning the ten-element set of characters containing the characters <b>0</b> through <b>9</b> inclusive.</p>
      <p>The production <i>CharacterClassEscape</i> <b>:: </b><b>D</b> evaluates by returning the set of all characters not included in the set returned by <i>CharacterClassEscape</i> <b>:: </b><b>d</b>.</p>
      <p>The production <i>CharacterClassEscape</i> <b>:: </b><b>s</b> evaluates by returning the set of characters containing the characters that are on the right-hand side of the <i>WhiteSpace</i> (7.2) or <i>LineTerminator</i> (7.3) productions.</p>
      <p>The production <i>CharacterClassEscape</i> <b>:: </b><b>S</b> evaluates by returning the set of all characters not included in the set returned by <i>CharacterClassEscape</i> <b>:: </b><b>s</b>.</p>
      <p>The production <i>CharacterClassEscape</i> <b>:: </b><b>w</b> evaluates by returning the set of characters containing the sixty-three characters:</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>a</p>
            </td>
            <td>
              <p>b</p>
            </td>
            <td>
              <p>c</p>
            </td>
            <td>
              <p>d</p>
            </td>
            <td>
              <p>e</p>
            </td>
            <td>
              <p>f</p>
            </td>
            <td>
              <p>g</p>
            </td>
            <td>
              <p>h</p>
            </td>
            <td>
              <p>i</p>
            </td>
            <td>
              <p>j</p>
            </td>
            <td>
              <p>k</p>
            </td>
            <td>
              <p>l</p>
            </td>
            <td>
              <p>m</p>
            </td>
            <td>
              <p>n</p>
            </td>
            <td>
              <p>o</p>
            </td>
            <td>
              <p>p</p>
            </td>
            <td>
              <p>q</p>
            </td>
            <td>
              <p>r</p>
            </td>
            <td>
              <p>s</p>
            </td>
            <td>
              <p>t</p>
            </td>
            <td>
              <p>u</p>
            </td>
            <td>
              <p>v</p>
            </td>
            <td>
              <p>w</p>
            </td>
            <td>
              <p>x</p>
            </td>
            <td>
              <p>y</p>
            </td>
            <td>
              <p>z</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>A</p>
            </td>
            <td>
              <p>B</p>
            </td>
            <td>
              <p>C</p>
            </td>
            <td>
              <p>D</p>
            </td>
            <td>
              <p>E</p>
            </td>
            <td>
              <p>F</p>
            </td>
            <td>
              <p>G</p>
            </td>
            <td>
              <p>H</p>
            </td>
            <td>
              <p>I</p>
            </td>
            <td>
              <p>J</p>
            </td>
            <td>
              <p>K</p>
            </td>
            <td>
              <p>L</p>
            </td>
            <td>
              <p>M</p>
            </td>
            <td>
              <p>N</p>
            </td>
            <td>
              <p>O</p>
            </td>
            <td>
              <p>P</p>
            </td>
            <td>
              <p>Q</p>
            </td>
            <td>
              <p>R</p>
            </td>
            <td>
              <p>S</p>
            </td>
            <td>
              <p>T</p>
            </td>
            <td>
              <p>U</p>
            </td>
            <td>
              <p>V</p>
            </td>
            <td>
              <p>W</p>
            </td>
            <td>
              <p>X</p>
            </td>
            <td>
              <p>Y</p>
            </td>
            <td>
              <p>Z</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>0</p>
            </td>
            <td>
              <p>1</p>
            </td>
            <td>
              <p>2</p>
            </td>
            <td>
              <p>3</p>
            </td>
            <td>
              <p>4</p>
            </td>
            <td>
              <p>5</p>
            </td>
            <td>
              <p>6</p>
            </td>
            <td>
              <p>7</p>
            </td>
            <td>
              <p>8</p>
            </td>
            <td>
              <p>9</p>
            </td>
            <td>
              <p>_</p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>The production <i>CharacterClassEscape</i> <b>:: </b><b>W</b> evaluates by returning the set of all characters not included in the set returned by <i>CharacterClassEscape</i> <b>:: </b><b>w</b>.</p>
      <h2>15.10.2.13<span>	CharacterClass</span></h2>
      <p>The production <i>CharacterClass</i> <b>:: </b><b>[ </b>[lookahead ∈ {<b>^</b>}]<b> </b><i>ClassRanges</i><b> ]</b> evaluates by evaluating <i>ClassRanges</i> to obtain a CharSet and returning that CharSet and the Boolean <b>false</b>.</p>
      <p>The production <i>CharacterClass</i>  <b>:: </b><b>[ ^ </b><i>ClassRanges</i><b> ]</b> evaluates by evaluating <i>ClassRanges</i> to obtain a CharSet and returning that CharSet and the Boolean <b>true</b>.</p>
      <h2>15.10.2.14<span>	ClassRanges</span></h2>
      <p>The production <i>ClassRanges</i><b> </b><b>:: </b>[empty] evaluates by returning the empty CharSet.</p>
      <p>The production <i>ClassRanges</i><b> </b><b>:: </b><i>NonemptyClassRanges</i> evaluates by evaluating <i>NonemptyClassRanges</i> to obtain a CharSet and returning that CharSet.</p>
      <h2>15.10.2.15<span>	NonemptyClassRanges</span></h2>
      <p>The production <i>NonemptyClassRanges</i> <b>:: </b><i>ClassAtom</i> evaluates by evaluating <i>ClassAtom</i> to obtain a CharSet and returning that CharSet.</p>
      <p>The production <i>NonemptyClassRanges</i> <b>:: </b><i>ClassAtom</i> <i>NonemptyClassRangesNoDash</i> evaluates as follows:</p>
      <p>Evaluate <i>ClassAtom</i> to obtain a CharSet <i>A</i>.</p>
      <p>Evaluate <i>NonemptyClassRangesNoDash</i> to obtain a CharSet <i>B</i>.</p>
      <p>Return the union of CharSets <i>A</i> and <i>B</i>.</p>
      <p>The production <i>NonemptyClassRanges</i> <b>:: </b><i>ClassAtom</i><b> - </b><i>ClassAtom</i> <i>ClassRanges</i> evaluates as follows:</p>
      <p>Evaluate the first <i>ClassAtom</i> to obtain a CharSet <i>A</i>.</p>
      <p>Evaluate the second <i>ClassAtom</i> to obtain a CharSet <i>B</i>.</p>
      <p>Evaluate <i>ClassRanges</i> to obtain a CharSet <i>C</i>.</p>
      <p>Call <i>CharacterRange</i>(<i>A</i>, <i>B</i>) and let <i>D</i> be the resulting CharSet.</p>
      <p>Return the union of CharSets <i>D</i> and <i>C</i>.</p>
      <p>The abstract operation <i>CharacterRange</i> takes two CharSet parameters <i>A</i> and <i>B</i> and performs the following:</p>
      <p>If <i>A</i> does not contain exactly one character or <i>B</i> does not contain exactly one character then throw a <b>SyntaxError</b> exception.</p>
      <p>Let <i>a</i> be the one character in CharSet <i>A</i>.</p>
      <p>Let <i>b</i> be the one character in CharSet <i>B</i>.</p>
      <p>Let <i>i</i> be the code unit value of character <i>a</i>.</p>
      <p>Let <i>j</i> be the code unit value of character <i>b</i>.</p>
      <p>If <i>i </i>&gt; <i>j</i> then throw a <b>SyntaxError</b> exception.</p>
      <p>Return the set containing all characters numbered <i>i</i> through <i>j</i>, inclusive.</p>
      <h2>15.10.2.16<span>	NonemptyClassRangesNoDash</span></h2>
      <p>The production <i>NonemptyClassRangesNoDash</i> <b>:: </b><i>ClassAtom</i> evaluates by evaluating <i>ClassAtom</i> to obtain a CharSet and returning that CharSet.</p>
      <p>The production NonemptyClassRangesNoDash <b>:: </b>ClassAtomNoDash NonemptyClassRangesNoDash evaluates as follows:</p>
      <p>Evaluate <i>ClassAtomNoDash</i> to obtain a CharSet <i>A</i>.</p>
      <p>Evaluate <i>NonemptyClassRangesNoDash</i> to obtain a CharSet <i>B</i>.</p>
      <p>Return the union of CharSets <i>A</i> and <i>B</i>.</p>
      <p>The production NonemptyClassRangesNoDash <b>:: </b>ClassAtomNoDash<b> - </b>ClassAtom ClassRanges evaluates as follows:</p>
      <p>Evaluate <i>ClassAtomNoDash</i> to obtain a CharSet <i>A</i>.</p>
      <p>Evaluate <i>ClassAtom</i> to obtain a CharSet <i>B</i>.</p>
      <p>Evaluate <i>ClassRanges</i> to obtain a CharSet <i>C</i>.</p>
      <p>Call <i>CharacterRange</i>(<i>A</i>, <i>B</i>) and let <i>D</i> be the resulting CharSet.</p>
      <p>Return the union of CharSets <i>D</i> and <i>C</i>.</p>
      <p>NOTE 1	<i>ClassRanges</i> can expand into single <i>ClassAtoms</i> and/or ranges of two <i>ClassAtoms</i> separated by dashes. In the latter case the <i>ClassRanges</i> includes all characters between the first <i>ClassAtom</i> and the second <i>ClassAtom</i>, inclusive; an error occurs if either <i>ClassAtom</i> does not represent a single character (for example, if one is <b>\w</b>) or if the first <i>ClassAtom's</i> code unit value is greater than the second <i>ClassAtom's</i> code unit value.</p>
      <p>NOTE 2<span>	Even if the pattern ignores case, the case of the two ends of a range is significant in determining which characters belong to the range. Thus, for example, the pattern </span><b>/[E-F]/i</b> matches only the letters <b>E</b>, <b>F</b>, <b>e</b>, and <b>f</b>, while the pattern <b>/[E-f]/i</b> matches all upper and lower-case ASCII letters as well as the symbols <b>[</b>, <b>\</b>, <b>]</b>, <b>^</b>, <b>_</b>, and <b>`</b>.</p>
      <p>NOTE 3<span>	A </span><b>-</b> character can be treated literally or it can denote a range. It is treated literally if it is the first or last character of <i>ClassRanges</i>, the beginning or end limit of a range specification, or immediately follows a range specification.</p>
      <h2>15.10.2.17<span>	ClassAtom</span></h2>
      <p>The production <i>ClassAtom</i> <b>:: </b><b>-</b> evaluates by returning the CharSet containing the one character <b>-</b>.</p>
      <p>The production <i>ClassAtom</i> <b>:: </b><i>ClassAtomNoDash</i> evaluates by evaluating <i>ClassAtomNoDash</i> to obtain a CharSet and returning that CharSet.</p>
      <h2>15.10.2.18<span>	ClassAtomNoDash</span></h2>
      <p>The production <i>ClassAtomNoDash</i> <b>:: </b><i>SourceCharacter</i> <b>but not one of </b><b>\</b><b> or </b><b>]</b><b> or </b><b>- </b>evaluates by returning a one-element CharSet containing the character represented by <i>SourceCharacter</i>.</p>
      <p>The production <i>ClassAtomNoDash</i> <b>:: </b><b>\ </b><i>ClassEscape</i> evaluates by evaluating <i>ClassEscape</i> to obtain a CharSet and returning that CharSet.</p>
      <h2>15.10.2.19<span>	ClassEscape</span></h2>
      <p>The production <i>ClassEscape</i> <b>:: </b><i>DecimalEscape</i> evaluates as follows:</p>
      <p>Evaluate <i>DecimalEscape</i> to obtain an EscapeValue <i>E</i>.</p>
      <p>If <i>E</i> is not a character then throw a <b>SyntaxError</b> exception.</p>
      <p>Let <i>ch</i> be <i>E</i>'s character.</p>
      <p>Return the one-element CharSet containing the character <i>ch</i>.</p>
      <p>The production <i>ClassEscape</i> <b>:: </b><b>b</b> evaluates by returning the CharSet containing the one character &lt;BS&gt; (Unicode value 0008).</p>
      <p>The production <i>ClassEscape</i> <b>:: </b><i>CharacterEscape</i> evaluates by evaluating <i>CharacterEscape</i> to obtain a character and returning a one-element CharSet containing that character.</p>
      <p>The production <i>ClassEscape</i> <b>:: </b><i>CharacterClassEscape</i> evaluates by evaluating <i>CharacterClassEscape</i> to obtain a CharSet and returning that CharSet.</p>
      <p>NOTE<span>	A </span>ClassAtom can use any of the escape sequences that are allowed in the rest of the regular expression except for <b>\b</b>, <b>\B</b>, and backreferences. Inside a CharacterClass, <b>\b</b> means the backspace character, while <b>\B</b> and backreferences raise errors. Using a backreference inside a ClassAtom causes an error.</p>
      <h2>15.10.3<span>	The RegExp Constructor Called as a Function</span></h2>
      <h2>15.10.3.1<span>	RegExp(pattern, flags)</span></h2>
      <p>If <i>pattern</i> is an object <i>R</i> that has a [[NativeBrand]] internal property whose value is NativeRegExp and <i>flags</i> is <b>undefined</b>, then return <i>R</i> unchanged. Otherwise call the standard built-in <b>RegExp</b> constructor (15.10.4.1) as if by the expression <b>new RegExp(</b><i>pattern</i><b>, </b><i>flags</i><b>)</b> and return the object constructed by that constructor.</p>
      <h2>15.10.4<span>	The RegExp Constructor</span></h2>
      <p>When <b>RegExp</b> is called as part of a <b>new</b> expression, it is a constructor: it initialises the newly created object.</p>
      <h2>15.10.4.1<span>	new RegExp(pattern, flags)</span></h2>
      <p>If <i>pattern</i> is an object <i>R</i> that has a [[NativeBrand]] internal property whose value is NativeRegExp  and <i>flags</i> is <b>undefined</b>, then let <i>P</i> be the <i>pattern</i> used to construct <i>R</i> and let <i>F</i> be the flags used to construct <i>R</i>. If <i>pattern</i> is an object <i>R</i> that has a [[NativeBrand]] internal property whose value is NativeRegExp  and <i>flags</i> is not <b>undefined</b>, then throw a <b>TypeError</b> exception. Otherwise, let <i>P</i> be the empty String if <i>pattern</i> is <b>undefined</b> and ToString(<i>pattern</i>) otherwise, and let <i>F</i> be the empty String if <i>flags</i> is <b>undefined</b> and ToString(<i>flags</i>) otherwise.</p>
      <p>If the characters of <i>P</i> do not have the syntactic form <i>Pattern</i>, then throw a <b>SyntaxError</b> exception. Otherwise let the newly constructed object have a [[Match]] internal property obtained by evaluating ("compiling") the characters of <i>P</i> as a <i>Pattern</i> as described in 15.10.2. </p>
      <p>If <i>F</i> contains any character other than <b>"g"</b>, <b>"i"</b>, or <b>"m"</b>, or if it contains the same character more than once, then throw a <b>SyntaxError</b> exception. </p>
      <p>If a <b>SyntaxError</b> exception is not thrown, then: </p>
      <p>Let <i>S</i> be a String in the form of a <i>Pattern</i> equivalent to <i>P</i>, in which certain characters are escaped as described below. <i>S</i> may or may not be identical to <i>P</i> or <i>pattern</i>; however, the internal procedure that would result from evaluating <i>S</i> as a <i>Pattern</i> must behave identically to the internal procedure given by the constructed object's [[Match]] internal property. </p>
      <p>The characters <b>/</b> occurring in the pattern shall be escaped in <i>S</i> as necessary to ensure that the String value formed by concatenating the Strings <b>"/"</b>, <i>S</i>, <b>"/"</b>, and <i>F</i> can be parsed (in an appropriate lexical context) as a <i>RegularExpressionLiteral</i> that behaves identically to the constructed regular expression. For example, if <i>P</i> is <b>"/"</b>, then <i>S</i> could be <b>"\/"</b> or <b>"\u002F"</b>, among other possibilities, but not <b>"/"</b>, because <b>///</b> followed by <i>F</i> would be parsed as a <i>SingleLineComment</i> rather than a <i>RegularExpressionLiteral</i>. If <i>P</i> is the empty String, this specification can be met by letting <i>S</i> be <b>"(?:)"</b>. </p>
      <p>The following properties of the newly constructed object are data properties with the attributes that are specified in 15.10.7. The [[Value]] of each property is set as follows:</p>
      <p>The <b>source</b> property of the newly constructed object is set to <i>S</i>.</p>
      <p>The <b>global</b> property of the newly constructed object is set to a Boolean value that is <b>true</b> if <i>F</i> contains the character <b>"</b><b>g</b><b>"</b> and <b>false</b> otherwise.</p>
      <p>The <b>ignoreCase</b> property of the newly constructed object is set to a Boolean value that is <b>true</b> if <i>F</i> contains the character <b>"</b><b>i</b><b>"</b> and <b>false</b> otherwise.</p>
      <p>The <b>multiline</b> property of the newly constructed object is set to a Boolean value that is <b>true</b> if <i>F</i> contains the character <b>"</b><b>m</b><b>"</b> and <b>false</b> otherwise.</p>
      <p>The <b>lastIndex</b> property of the newly constructed object is set to <b>0</b>.</p>
      <p>The [[Prototype]] internal property of the newly constructed object is set to the standard built-in RegExp prototype object as specified in 15.10.6.</p>
      <p>The newly constructed object has a [[NativeBrand]] internal property whose value is NativeRegExp </p>
      <p>NOTE<span>	If pattern is a </span>StringLiteral, the usual escape sequence substitutions are performed before the String is processed by RegExp. If pattern must contain an escape sequence to be recognised by RegExp, any backslash <b>\</b> characters must be escaped within the StringLiteral to prevent them being removed when the contents of the StringLiteral are formed. </p>
      <h2>15.10.5<span>	Properties of the RegExp Constructor</span></h2>
      <p>The value of the [[Prototype]] internal property of the RegExp constructor is the standard built-in Function prototype object (15.3.4).</p>
      <p>Besides the internal properties and the <b>length</b> property (whose value is <b>2</b>), the RegExp constructor has the following properties:</p>
      <h2>15.10.5.1<span>	RegExp.prototype</span></h2>
      <p>The initial value of <b>RegExp.prototype</b> is the RegExp prototype object (15.10.6).</p>
      <p>This property shall have the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.10.6<span>	Properties of the RegExp Prototype Object</span></h2>
      <p>The value of the [[Prototype]] internal property of the RegExp prototype object is the standard built-in Object prototype object (15.2.4). The RegExp prototype object is itself a regular expression object; it has a [[NativeBrand]] internal property whose value is NativeRegExp . The initial values of the RegExp prototype object’s data properties (15.10.7) are set as if the object was created by the expression <b>new RegExp()</b> where <b>RegExp</b> is that standard built-in constructor with that name.</p>
      <p>The RegExp prototype object does not have a <b>valueOf</b> property of its own; however, it inherits the <b>valueOf</b> property from the Object prototype object.</p>
      <p>In the following descriptions of functions that are properties of the RegExp prototype object, the phrase “this RegExp object” refers to the object that is the <b>this</b> value for the invocation of the function; a <b>TypeError</b> exception is thrown if the <b>this</b> value is not an object that has a [[NativeBrand]] internal property whose value is NativeRegExp.</p>
      <h2>15.10.6.1<span>	RegExp.prototype.constructor</span></h2>
      <p>The initial value of <b>RegExp.prototype.constructor</b> is the standard built-in <b>RegExp</b> constructor.</p>
      <h2>15.10.6.2<span>	RegExp.prototype.exec(string)</span></h2>
      <p>Performs a regular expression match of <i>string</i> against the regular expression and returns an Array object containing the results of the match, or <b>null</b> if <i>string</i> did not match.</p>
      <p>The String ToString(<i>string</i>) is searched for an occurrence of the regular expression pattern as follows:</p>
      <p>Let <i>R</i> be this RegExp object.</p>
      <p>Let <i>S</i> be the value of ToString(<i>string</i>).</p>
      <p>Let <i>length</i> be the length of <i>S</i>.</p>
      <p>Let <i>lastIndex</i> be the result of calling the [[Get]] internal method of <i>R</i> with argument "<b>lastIndex</b>".</p>
      <p>Let <i>i</i> be the value of ToInteger(<i>lastIndex</i>).</p>
      <p>Let <i>global</i> be the result of calling the [[Get]] internal method of <i>R</i> with argument "<b>global</b><b>"</b>.</p>
      <p>If <i>global</i> is <b>false</b>, then let <i>i</i> = 0.</p>
      <p>Let <i>matchSucceeded</i> be <b>false</b>.</p>
      <p>Repeat, while <i>matchSucceeded</i> is <b>false</b></p>
      <p>If <i>i </i>&lt; 0 or <i>i </i>&gt; <i>length</i>, then</p>
      <p>Call the [[Put]] internal method of <i>R</i> with arguments "<b>lastIndex</b><b>"</b>, 0, and <b>true</b>.</p>
      <p>Return <b>null</b>.</p>
      <p>Call the [[Match]] internal method of <i>R</i> with arguments <i>S</i> and <i>i</i>.</p>
      <p>If [[Match]] returned <b>failure</b>, then </p>
      <p>
        <i>Let i = i+1.</i>
      </p>
      <p>else </p>
      <p>Let <i>r</i> be the State result of the call to [[Match]].</p>
      <p>Set <i>matchSucceeded</i> to <b>true</b>.</p>
      <p>Let <i>e</i> be <i>r</i>'s <i>endIndex</i> value.</p>
      <p>If <i>global</i> is <b>true</b>,</p>
      <p>Call the [[Put]] internal method of <i>R</i> with arguments "<b>lastIndex</b><b>"</b>, <i>e</i>, and <b>true</b>.</p>
      <p>Let <i>n</i> be the length of <i>r</i>'s <i>captures</i> array. (This is the same value as 15.10.2.1's <i>NCapturingParens</i>.)</p>
      <p>Let <i>A</i> be a new array created as if by the expression <b>new Array()</b> where <b>Array</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>matchIndex</i> be <i>i</i>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments "<b>index</b><b>"</b>, Property Descriptor {[[Value]]: <i>matchIndex</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>true</b>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments "<b>input</b><b>"</b>, Property Descriptor {[[Value]]: <i>S</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>true</b>.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments "<b>length</b><b>"</b>, Property Descriptor {[[Value]]: <i>n</i> + 1}, and <b>true</b>.</p>
      <p>Let <i>matchedSubstr</i> be the matched substring (i.e. the portion of <i>S</i> between offset <i>i</i> inclusive and offset <i>e</i> exclusive).</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments "<b>0</b><b>"</b>, Property Descriptor {[[Value]]: <i>matchedSubstr</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>true</b>.</p>
      <p>For each integer <i>i</i> such that <i>i </i>&gt; 0 and <i>i </i>≤ <i>n</i></p>
      <p>Let <i>captureI</i> be <i>i</i><sup>th</sup> element of <i>r</i>'s <i>captures</i> array.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>A</i> with arguments ToString(<i>i</i>), Property Descriptor {[[Value]]: <i>captureI</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>true</b>.</p>
      <p>Return <i>A</i>.</p>
      <h2>15.10.6.3<span>	RegExp.prototype.test(string)</span></h2>
      <p>The following steps are taken:</p>
      <p>Let <i>match</i> be the result of evaluating the <b>RegExp.prototype.exec</b> (15.10.6.2) algorithm upon this RegExp object using <i>string</i> as the argument.</p>
      <p>If <i>match</i> is not null, then return <b>true</b>; else return <b>false</b>.</p>
      <h2>15.10.6.4<span>	RegExp.prototype.toString()</span></h2>
      <p>Return the String value formed by concatenating the Strings "<b>/</b>", the String value of the <b>source</b> property of this RegExp object, and "<b>/</b>"; plus "<b>g</b>" if the <b>global</b> property is <b>true</b>, "<b>i</b>" if the <b>ignoreCase</b> property is <b>true</b>, and "<b>m</b>" if the <b>multiline</b> property is <b>true</b><b>.</b></p>
      <p>NOTE<span>	The returned String has the form of a </span>RegularExpressionLiteral that evaluates to another RegExp object with the same behaviour as this object. </p>
      <h2>15.10.7<span>	Properties of RegExp Instances</span></h2>
      <p>RegExp instances inherit properties from the RegExp prototype object and have a [[NativeBrand]] internal property whose value is NativeRegExp. RegExp instances also have a [[Match]] internal property and a <b>length</b> property.</p>
      <p>The value of the [[Match]] internal property is an implementation dependent representation of the <i>Pattern</i> of the RegExp object.</p>
      <p>RegExp instances also have the following properties.</p>
      <h2>15.10.7.1<span>	source</span></h2>
      <p>The value of the <b>source</b> property is a String in the form of a Pattern representing the current regular expression. This property shall have the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.10.7.2<span>	global</span></h2>
      <p>The value of the <b>global</b> property is a Boolean value indicating whether the flags contained the character <b>“g”</b>. This property shall have the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.10.7.3<span>	ignoreCase</span></h2>
      <p>The value of the <b>ignoreCase</b> property is a Boolean value indicating whether the flags contained the character <b>“i”</b>. This property shall have the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.10.7.4<span>	multiline</span></h2>
      <p>The value of the <b>multiline</b> property is a Boolean value indicating whether the flags contained the character <b>“m”</b>. This property shall have the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.10.7.5<span>	lastIndex</span></h2>
      <p>The value of the <b>lastIndex</b> property specifies the String position at which to start the next match. It is coerced to an integer when used (see 15.10.6.2). This property shall have the attributes { [[Writable]]: <b>true</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <p>NOTE<span>	Unlike the other standard built-in properties of RegExp instances, </span><b>lastIndex</b> is writable.</p>
      <h2>15.11<span>	Error Objects</span></h2>
      <p>Instances of Error objects are thrown as exceptions when runtime errors occur. The Error objects may also serve as base objects for user-defined exception classes.</p>
      <h2>15.11.1<span>	The Error Constructor Called as a Function</span></h2>
      <p>When <b>Error</b><b> </b>is called as a function rather than as a constructor, it creates and initialises a new Error object. Thus the function call <b>Error(</b>…<b>)</b> is equivalent to the object creation expression <b>new Error(</b>…<b>)</b> with the same arguments.</p>
      <h2>15.11.1.1<span>	Error (message)</span></h2>
      <p>The [[Prototype]] internal property of the newly constructed object is set to the original Error prototype object, the one that is the initial value of <b>Error.prototype</b> (15.11.3.1).</p>
      <p>The newly constructed object has a [[NativeBrand]] internal property whose value is NativeError.</p>
      <p>The [[Extensible]] internal property of the newly constructed object is set to <b>true</b>.</p>
      <p>If the argument <i>message</i> is not <b>undefined</b>, the <b>message</b> own property of the newly constructed object is set to ToString(<i>message</i>). </p>
      <h2>15.11.2<span>	The Error Constructor</span></h2>
      <p>When <b>Error</b> is called as part of a <b>new</b> expression, it is a constructor: it initialises the newly created object.</p>
      <h2>15.11.2.1<span>	new Error (message)</span></h2>
      <p>The [[Prototype]] internal property of the newly constructed object is set to the original Error prototype object, the one that is the initial value of <b>Error.prototype</b> (15.11.3.1).</p>
      <p>The newly constructed object has a [[NativeBrand]] internal property whose value is NativeError .</p>
      <p>The [[Extensible]] internal property of the newly constructed object is set to <b>true</b>.</p>
      <p>If the argument <i>message</i> is not <b>undefined</b>, the <b>message</b> own property of the newly constructed object is set to ToString(<i>message</i>). </p>
      <h2>15.11.3<span>	Properties of the Error Constructor</span></h2>
      <p>The value of the [[Prototype]] internal property of the Error constructor is the Function prototype object (15.3.4).</p>
      <p>Besides the internal properties and the <b>length</b> property (whose value is <b>1</b>), the Error constructor has the following property:</p>
      <h2>15.11.3.1<span>	Error.prototype</span></h2>
      <p>The initial value of <b>Error.prototype</b> is the Error prototype object (15.11.4).</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.11.4<span>	Properties of the Error Prototype Object</span></h2>
      <p>The Error prototype object is itself an Error object and has a [[NativeBrand]] internal property whose value is NativeError .</p>
      <p>The value of the [[Prototype]] internal property of the Error prototype object is the standard built-in Object prototype object (15.2.4).</p>
      <h2>15.11.4.1<span>	Error.prototype.constructor</span></h2>
      <p>The initial value of <b>Error.prototype.constructor</b> is the built-in <b>Error</b> constructor.</p>
      <h2>15.11.4.2<span>	Error.prototype.name</span></h2>
      <p>The initial value of <b>Error.prototype.name</b> is "<b>Error</b>".</p>
      <h2>15.11.4.3<span>	Error.prototype.message</span></h2>
      <p>The initial value of <b>Error.prototype.message</b> is the empty String.</p>
      <h2>15.11.4.4<span>	Error.prototype.toString ( )</span></h2>
      <p>The following steps are taken:</p>
      <p>Let <i>O</i> be the <b>this</b> value.</p>
      <p>If Type(<i>O</i>) is not Object, throw a <b>TypeError</b> exception.</p>
      <p>Let <i>name</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument "<b>name</b>".</p>
      <p>If <i>name</i> is <b>undefined</b>, then let <i>name</i> be "<b>Error</b>"; else let <i>name</i> be ToString(<i>name</i>).</p>
      <p>Let <i>msg</i> be the result of calling the [[Get]] internal method of <i>O</i> with argument "<b>message</b>".</p>
      <p>If <i>msg</i> is undefined, then let <i>msg </i>be the empty String; else let <i>msg</i> be ToString(<i>msg</i>).</p>
      <p>If <i>name</i> is the empty String, return <i>msg</i>.</p>
      <p>If <i>msg</i> is the empty String, return <i>name</i>.</p>
      <p>Return the result of concatenating <i>name</i>, <b>":"</b>, a single space character, and <i>msg</i>.</p>
      <h2>15.11.5<span>	Properties of Error Instances</span></h2>
      <p>Error instances inherit properties from the Error prototype object and have a [[NativeBrand]] internal property whose value is NativeError .  Error instances have no special properties.</p>
      <h2>15.11.6<span>	Native Error Types Used in This Standard</span></h2>
      <p>One of the <i>NativeError</i> objects below is thrown when a runtime error is detected. All of these objects share the same structure, as described in 15.11.7.</p>
      <h2>15.11.6.1<span>	EvalError</span></h2>
      <p>This exception is not currently used within this specification. This object remains for compatibility with previous editions of this specification.</p>
      <h2>15.11.6.2<span>	RangeError</span></h2>
      <p>Indicates a numeric value has exceeded the allowable range. See 15.4.2.2, 15.4.5.1, 15.7.4.2, 15.7.4.5, 15.7.4.6, 15.7.4.7, and 15.9.5.43.</p>
      <h2>15.11.6.3<span>	ReferenceError</span></h2>
      <p>Indicate that an invalid reference value has been detected. See 8.9.1, 8.9.2, 10.2.1, 10.2.1.1.4, 10.2.1.2.4, and 11.13.1.</p>
      <h2>15.11.6.4<span>	SyntaxError</span></h2>
      <p>Indicates that a parsing error has occurred. See 11.1.5, 11.3.1, 11.3.2, 11.4.1, 11.4.4, 11.4.5, 11.13.1, 11.13.2, 12.2.1, 12.10.1, 12.14.1, 13.1, 15.1.2.1, 15.3.2.1, 15.10.2.2, 15.10.2.5, 15.10.2.9, 15.10.2.15, 15.10.2.19, 15.10.4.1, and 15.12.2.</p>
      <h2>15.11.6.5<span>	TypeError</span></h2>
      <p>Indicates the actual type of an operand is different than the expected type. See 8.6.2, 8.9.2, 8.10.5, 8.12.5, 8.12.7, 8.12.8, 8.12.9, 9.9, 9.10, 10.2.1, 10.2.1.1.3, 10.6, 11.2.2, 11.2.3, 11.4.1, 11.8.6, 11.8.7, 11.3.1, 13.2, 13.2.3, 15, 15.2.3.2, 15.2.3.3, 15.2.3.4, 15.2.3.5, 15.2.3.6, 15.2.3.7, 15.2.3.8, 15.2.3.9, 15.2.3.10, 15.2.3.11, 15.2.3.12, 15.2.3.13, 15.2.3.14, 15.2.4.3, 15.3.4.2, 15.3.4.3, 15.3.4.4, 15.3.4.5, 15.3.4.5.2, 15.3.4.5.3, 15.3.5, 15.3.5.3, 15.3.5.4, 15.4.4.3, 15.4.4.11, 15.4.4.16, 15.4.4.17, 15.4.4.18, 15.4.4.19, 15.4.4.20, 15.4.4.21, 15.4.4.22, 15.4.5.1, 15.5.4.2, 15.5.4.3, 15.6.4.2, 15.6.4.3, 15.7.4, 15.7.4.2, 15.7.4.4, 15.9.5, 15.9.5.44, 15.10.4.1, 15.10.6, 15.11.4.4 and 15.12.3.</p>
      <h2>15.11.6.6<span>	URIError</span></h2>
      <p>Indicates that one of the global URI handling functions was used in a way that is incompatible with its definition. See 15.1.3.</p>
      <h2>15.11.7<i>	NativeError</i> Object Structure</h2>
      <p>When an ECMAScript implementation detects a runtime error, it throws an instance of one of the <i>NativeError</i> objects defined in 15.11.6. Each of these objects has the structure described below, differing only in the name used as the constructor name instead of <i>NativeError</i>, in the <b>name</b> property of the prototype object, and in the implementation-defined <b>message</b> property of the prototype object.</p>
      <p>For each error object, references to <i>NativeError</i> in the definition should be replaced with the appropriate error object name from 15.11.6.</p>
      <h2>15.11.7.1<i>	NativeError</i> Constructors Called as Functions</h2>
      <p>When a <i>NativeError</i> constructor is called as a function rather than as a constructor, it creates and initialises a new object.  A call of the object as a function is equivalent to calling it as a constructor with the same arguments.</p>
      <h2>15.11.7.2<i>	NativeError</i> (message)</h2>
      <p>The [[Prototype]] internal property of the newly constructed object is set to the prototype object for this error constructor.  The newly constructed object has a [[NativeBrand]] internal property whose value is NativeError . The [[Extensible]] internal property of the newly constructed object is set to <b>true</b>.</p>
      <p>If the argument <i>message</i> is not <b>undefined</b>, the <b>message</b> own property of the newly constructed object is set to ToString(<i>message</i>).</p>
      <h2>15.11.7.3<span>	The </span><i>NativeError</i> Constructors</h2>
      <p>When a <i>NativeError</i> constructor is called as part of a <b>new</b> expression, it is a constructor: it initialises the newly created object.</p>
      <h2>15.11.7.4<span>	new </span><i>NativeError</i> (message)</h2>
      <p>The [[Prototype]] internal property of the newly constructed object is set to the prototype object for this <i>NativeError</i> constructor.  The newly constructed object has a [[NativeBrand]] internal property whose value is NativeError . The [[Extensible]] internal property of the newly constructed object is set to <b>true</b>.</p>
      <p>If the argument <i>message</i> is not <b>undefined</b>, the <b>message </b>own property of the newly constructed object is set to ToString(<i>message</i>). </p>
      <h2>15.11.7.5<span>	Properties of the </span><i>NativeError</i> Constructors</h2>
      <p>The value of the [[Prototype]] internal property of a <i>NativeError</i> constructor is the Function prototype object (15.3.4).</p>
      <p>Besides the internal properties and the <b>length</b> property (whose value is <b>1</b>), each <i>NativeError</i> constructor has the following property:</p>
      <h2>15.11.7.6<i>	NativeError</i>.prototype</h2>
      <p>The initial value of <span style="font-weight: bold; font-style: italic">NativeError</span><b>.prototype</b> is a <i>NativeError</i> prototype object (15.11.7.7). Each <i>NativeError</i> constructor has a separate prototype object.</p>
      <p>This property has the attributes { [[Writable]]: <b>false</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b> }.</p>
      <h2>15.11.7.7<span>	Properties of the </span><i>NativeError</i> Prototype Objects</h2>
      <p>Each <i>NativeError</i> prototype object is an Error object and has a [[NativeBrand]] internal property whose value is NativeError .</p>
      <p>The value of the [[Prototype]] internal property of each <i>NativeError</i> prototype object is the standard built-in Error prototype object (15.11.4).</p>
      <h2>15.11.7.8<i>	NativeError</i>.prototype.constructor</h2>
      <p>The initial value of the <b>constructor</b> property of the prototype for a given <i>NativeError</i> constructor is the <i>NativeError</i> constructor function itself (15.11.7).</p>
      <h2>15.11.7.9<i>	NativeError</i>.prototype.name</h2>
      <p>The initial value of the <b>name</b> property of the prototype for a given <i>NativeError</i> constructor is the name of the constructor (the name used instead of <i>NativeError</i>).</p>
      <h2>15.11.7.10<i>	NativeError</i>.prototype.message</h2>
      <p>The initial value of the<b> message</b> property of the prototype for a given <i>NativeError</i> constructor is the empty String.</p>
      <p>NOTE<span>	The prototypes for the NativeError constructors do not themselves provide a </span><b>toString </b>function, but instances of errors will inherit it from the Error prototype object.</p>
      <h2>15.11.7.11<span>	Properties of </span><i>NativeError</i> Instances</h2>
      <p><i>NativeError</i> instances inherit properties from their <i>NativeError</i> prototype object and have a [[NativeBrand]] internal property whose value is NativeError .  <i>NativeError</i> instances have no special properties.</p>
      <h2>15.12<span>	The JSON Object</span></h2>
      <p>The <b>JSON</b> object is a single object that contains two functions, <b>parse </b>and <b>stringify</b>, that are used to parse and construct JSON texts. The JSON Data Interchange Format is described in RFC 4627 &lt;http://www.ietf.org/rfc/rfc4627.txt&gt;. The JSON interchange format used in this specification is exactly that described by RFC 4627 with two exceptions:</p>
      <p>The top level <i>JSONText</i> production of the ECMAScript JSON grammar may consist of any <i>JSONValue</i> rather than being restricted to being  a <i>JSONObject</i> or a <i>JSONArray</i> as specified by RFC 4627. </p>
      <p>Conforming implementations of <b>JSON.parse</b> and <b>JSON.stringify</b> must support the exact interchange format described in this specification without any deletions or extensions to the format. This differs from RFC 4627 which permits a JSON parser to accept non-JSON forms and extensions.</p>
      <p>The value of the [[Prototype]] internal property of the JSON object is the standard built-in Object prototype object (15.2.4). The JSON object has a [[NativeBrand]] internal property whose value is NativeJSON . The value of the [[Extensible]] internal property of the JSON object is set to <b>true</b>.</p>
      <p>The JSON object does not have a [[Construct]] internal property; it is not possible to use the JSON object as a constructor with the <b>new</b> operator.</p>
      <p>The JSON object does not have a [[Call]] internal property; it is not possible to invoke the JSON object as a function.</p>
      <h2>15.12.1<span>	The JSON Grammar</span> </h2>
      <p>JSON.stringify produces a String that conforms to the following JSON grammar. JSON.parse accepts a String that conforms to the JSON grammar.</p>
      <h2>15.12.1.1<span>	The JSON Lexical Grammar</span></h2>
      <p>JSON is similar to ECMAScript source text in that it consists of a sequence of characters conforming to the rules of <i>SourceCharacter</i>. The JSON Lexical Grammar defines the tokens that make up a JSON text similar to the manner that the ECMAScript lexical grammar defines the tokens of an ECMAScript source text. The JSON Lexical grammar only recognises the white space character specified by the production <i>JSONWhiteSpace</i>. The JSON lexical grammar shares some productions with the ECMAScript lexical grammar.  All nonterminal symbols of the grammar that do not begin with the characters “JSON” are defined by productions of the ECMAScript lexical grammar.</p>
      <p>Syntax</p>
      <p>
        <i>JSONWhiteSpace </i>
        <b>::</b>
      </p>
      <p>&lt;TAB&gt;<span><br>&lt;CR&gt;</span><span><br>&lt;LF&gt;</span><span><br>&lt;SP&gt;</span></p>
      <p>
      </p>
      <p>JSONString <b>::</b></p>
      <p><b>" </b>JSONStringCharacters<sub>opt</sub><b> "</b></p>
      <p>
      </p>
      <p>JSONStringCharacters <b>::</b></p>
      <p>JSONStringCharacter JSONStringCharacters<sub>opt</sub> </p>
      <p>
      </p>
      <p>
        <i>JSONStringCharacter </i>
        <b>::</b>
      </p>
      <p>SourceCharacter <b>but not one of</b> <b>"</b> <b>or</b> <b>\ </b><b>or</b> U+0000 <b>through</b> U+001F</p>
      <p><b>\</b> JSONEscapeSequence</p>
      <p>
      </p>
      <p>JSONEscapeSequence <b>::</b></p>
      <p>JSONEscapeCharacter</p>
      <p>UnicodeEscapeSequence </p>
      <p>
      </p>
      <p>JSONEscapeCharacter <b>::</b> <b>one of</b></p>
      <p>
        <b>" / \ b f n r t</b>
      </p>
      <p>
      </p>
      <p>JSONNumber <b>::</b></p>
      <p><b>-</b><sub>opt</sub>  DecimalIntegerLiteral JSONFraction<sub>opt</sub>  ExponentPart<sub>opt</sub></p>
      <p>
      </p>
      <p>JSONFraction <b>::</b></p>
      <p><b>.</b> DecimalDigits</p>
      <p>
      </p>
      <p>JSONNullLiteral <b>::</b></p>
      <p>NullLiteral</p>
      <p>
      </p>
      <p>JSONBooleanLiteral <b>::</b></p>
      <p>BooleanLiteral</p>
      <p>
      </p>
      <h2>15.12.1.2<span>	The JSON Syntactic Grammar</span></h2>
      <p>The JSON Syntactic Grammar defines a valid JSON text in terms of tokens defined by the JSON lexical grammar.  The goal symbol of the grammar is <i>JSONText</i>. </p>
      <p>Syntax</p>
      <p>JSONText <b>:</b><span>	 </span></p>
      <p>JSONValue</p>
      <p>
      </p>
      <p>JSONValue <b>:</b><span>	 </span></p>
      <p>JSONNullLiteral<span><br>JSONBooleanLiteral</span><span><br>JSONObject</span><span><br>JSONArray</span><span><br>JSONString</span><span><br>JSONNumber</span></p>
      <p>
      </p>
      <p>JSONObject <b>:</b></p>
      <p><b>{ }</b><br><b>{</b> JSONMemberList <b>}</b></p>
      <p>
      </p>
      <p>JSONMember <b>:</b></p>
      <p>JSONString <b>:</b> JSONValue</p>
      <p>
      </p>
      <p>JSONMemberList <b>:</b></p>
      <p>JSONMember <span><br>JSONMemberList </span><b>,</b><b> </b>JSONMember </p>
      <p>
      </p>
      <p>JSONArray <b>:</b></p>
      <p><b>[ ]</b><br><b>[ </b>JSONElementList<b> ]</b></p>
      <p>
      </p>
      <p>JSONElementList <b>:</b></p>
      <p>JSONValue<span><br>JSONElementList</span><b> ,</b> JSONValue</p>
      <p>
      </p>
      <h2>15.12.2<span>	parse ( text [ , reviver ] )</span></h2>
      <p>The <b>parse</b> function parses a JSON text (a JSON-formatted String) and produces an ECMAScript value. The JSON format is a restricted form of ECMAScript literal. JSON objects are realized as ECMAScript objects. JSON arrays are realized as ECMAScript arrays. JSON strings, numbers, booleans, and null are realized as ECMAScript Strings, Numbers, Booleans, and <b>null</b>. JSON uses a more limited set of white space characters than <i>WhiteSpace</i> and allows Unicode code points U+2028 and U+2029 to directly appear in <i>JSONString</i> literals without using an escape sequence. The process of parsing is similar to 11.1.4 and 11.1.5 as constrained by the JSON grammar.</p>
      <p>The optional <i>reviver</i> parameter is a function that takes two parameters, (<i>key</i> and <i>value</i>). It can filter and transform the results. It is called with each of the <i>key</i>/<i>value</i> pairs produced by the parse, and its return value is used instead of the original value. If it returns what it received, the structure is not modified. If it returns <b>undefined</b> then the property is deleted from the result.</p>
      <p>Let <i>JText</i> be ToString(<i>text</i>).</p>
      <p>Parse <i>JText</i> using the grammars in 15.12.1. Throw a <b>SyntaxError</b> exception if <i>JText</i> did not conform to the JSON grammar for the goal symbol <i>JSONText</i>. </p>
      <p>Let <i>unfiltered</i> be the result of parsing and evaluating <i>JText</i> as if it was the source text of an ECMAScript <i>Program</i> but using<i> JSONString </i>in place<i> </i>of<i> StringLiteral</i>. Note that since <i>JText</i> conforms to the JSON grammar this result will be either a primitive value or an object that is defined by either an <i>ArrayLiteral</i> or an <i>ObjectLiteral</i>.</p>
      <p>If IsCallable(<i>reviver</i>) is <b>true</b>, then</p>
      <p>Let <i>root</i> be a new object created as if by the expression <b>new Object()</b>, where <b>Object</b> is the standard built-in constructor with that name.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>root</i> with the empty String, the PropertyDescriptor {[[Value]]: <i>unfiltered</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b> as arguments.</p>
      <p>Return the result of calling the abstract operation Walk, passing <i>root</i> and the empty String. The abstract operation Walk is described below.</p>
      <p>Else</p>
      <p>Return <i>unfiltered</i>.</p>
      <p>The abstract operation Walk is a recursive abstract operation that takes two parameters: a <i>holder</i> object and the String <i>name</i> of a property in that object. Walk uses the value of <i>reviver</i> that was originally passed to the above parse function.</p>
      <p>Let <i>val</i> be the result of calling the [[Get]] internal method of <i>holder</i> with argument <i>name</i>.</p>
      <p>If <i>val</i> is an object, then</p>
      <p>If <i>val</i> has a [[NativeBrand]] internal property with value NativeArray, then</p>
      <p>Set <i>I</i> to 0.</p>
      <p>Let <i>len</i> be the result of calling the [[Get]] internal method of <i>val</i> with argument <b>"length"</b>.</p>
      <p>Repeat while <i>I </i>&lt; <i>len</i>, </p>
      <p>Let <i>newElement</i> be the result of calling the abstract operation Walk, passing <i>val</i> and ToString(<i>I</i>).</p>
      <p>If <i>newElement</i> is <b>undefined</b>, then</p>
      <p>Call the [[Delete]] internal method of <i>val</i> with ToString(<i>I</i>) and <b>false</b> as arguments. </p>
      <p>Else</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>val</i> with arguments ToString(<i>I</i>), the Property Descriptor {[[Value]]: <i>newElement</i>, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and <b>false</b>.</p>
      <p>Add 1 to <i>I</i>.</p>
      <p>Else</p>
      <p>Let <i>keys</i> be an internal List of String values consisting of the names of all the own properties of <i>val</i> whose [[Enumerable]] attribute is <b>true</b>. The ordering of the Strings should be the same as that used by the <b>Object.keys</b> standard built-in function.</p>
      <p>For each String <i>P</i> in <i>keys</i> do, </p>
      <p>Let <i>newElement</i> be the result of calling the abstract operation Walk, passing <i>val</i> and <i>P</i>. </p>
      <p>If <i>newElement</i> is <b>undefined</b>, then</p>
      <p>Call the [[Delete]] internal method of <i>val</i> with <i>P</i> and <b>false</b> as arguments. </p>
      <p>Else</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>val</i> with arguments <i>P</i>, the Property Descriptor {[[Value]]: <i>newElement</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Return the result of calling the [[Call]] internal method of <i>reviver</i> passing <i>holder</i> as the <b>this</b> value and with an argument list consisting of <i>name </i>and <i>val</i>.</p>
      <p>It is not permitted for a conforming implementation of <b>JSON.parse</b> to extend the JSON grammars. If an implementation wishes to support a modified or extended JSON interchange format it must do so by defining a different parse function. </p>
      <p>NOTE<span>	In the case where there are duplicate name Strings within an object, lexically preceding values for the same key shall be overwritten.</span></p>
      <h2>15.12.3<span>	stringify ( value [ , replacer [ , space ] ] )</span></h2>
      <p>The <b>stringify</b> function returns a String in JSON format representing an ECMAScript value. It can take three parameters. The <i>value</i> parameter is an ECMAScript value, which is usually an object or array, although it can also be a String, Boolean, Number or <b>null</b>. The optional <i>replacer</i> parameter is either a function that alters the way objects and arrays are stringified, or an array of Strings and Numbers that acts as a white list for selecting the object properties that will be stringified. The optional <i>space</i> parameter is a String or Number that allows the result to have white space injected into it to improve human readability.</p>
      <p>These are the steps in stringifying an object:</p>
      <p>Let <i>stack</i> be an empty List.</p>
      <p>Let <i>indent</i> be the empty String.</p>
      <p>Let <i>PropertyList</i> and <i>ReplacerFunction</i> be <b>undefined</b>.</p>
      <p>If Type(<i>replacer</i>) is Object, then</p>
      <p>If IsCallable(<i>replacer</i>) is <b>true</b>, then</p>
      <p>Let <i>ReplacerFunction </i>be<i> replacer</i>.</p>
      <p>Else if <i>replacer</i> has a [[NativeBrand]] internal property with value NativeArray , then</p>
      <p>Let <i>PropertyList </i> be an empty internal List</p>
      <p>For each value <i>v</i> of a property of <i>replacer</i> that has an array index property name. The properties are enumerated in the ascending array index order of their names.</p>
      <p>Let <i>item</i> be <b>undefined</b>.</p>
      <p>If Type(<i>v</i>) is String then let <i>item</i> be <i>v.</i></p>
      <p>Else if Type(<i>v</i>) is Number then let <i>item</i> be ToString(<i>v</i>).</p>
      <p>Else if Type(<i>v</i>) is Object then,</p>
      <p>If <i>v</i> has either an [[NativeBrand]] internal property whose value is either StringWrapper or NumberWrapper<b> </b>then let <i>item</i> be ToString(<i>v</i>).</p>
      <p>If <i>item</i> is not undefined and <i>item</i> is not currently an element of <i>PropertyList</i> then,</p>
      <p>Append <i>item</i> to the end of <i>PropertyList</i>.</p>
      <p>If Type(<i>space</i>) is Object then,</p>
      <p>If <i>space</i> has a [[NativeBrand]] internal property whose value is NumberWrapper  then,</p>
      <p>Let <i>space</i> be ToNumber(<i>space</i>).</p>
      <p>Else if <i>space</i> has a [[NativeBrand]] internal property with value StringWrapper  then,</p>
      <p>Let <i>space</i> be ToString(<i>space</i>).</p>
      <p>If Type(<i>space</i>) is Number</p>
      <p>Let <i>space</i> be min(10, ToInteger(<i>space</i>)).</p>
      <p>Set <i>gap</i> to a String containing <i>space</i> space characters. This will be the empty String if <i>space</i> is less than 1.</p>
      <p>Else if Type(<i>space)</i> is String</p>
      <p>If the number of characters in <i>space</i> is 10 or less, set <i>gap</i> to <i>space</i> otherwise set <i>gap</i> to a String consisting of the first 10 characters of <i>space</i>.</p>
      <p>Else</p>
      <p>Set <i>gap</i> to the empty String.</p>
      <p>Let <i>wrapper</i> be a new object created as if by the expression <b>new Object()</b>, where <b>Object</b> is the standard built-in constructor with that name.</p>
      <p>Call the [[DefineOwnProperty]]  internal method of <i>wrapper</i> with arguments the empty String, the Property Descriptor {[[Value]]: <i>value</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>}, and <b>false</b>.</p>
      <p>Return the result of calling the abstract operation <i>Str</i> with the empty String and <i>wrapper</i>.</p>
      <p>The abstract operation <i>Str</i>(<i>key</i>, <i>holder</i>) has access to <i>ReplacerFunction</i><i> </i>from the invocation of the <b>stringify</b> method. Its algorithm is as follows:</p>
      <p>Let <i>value</i> be the result of calling the [[Get]] internal method of <i>holder</i> with argument <i>key</i>.</p>
      <p>If Type(<i>value</i>) is Object, then</p>
      <p>Let <i>toJSON</i> be the result of calling the [[Get]] internal method of <i>value</i> with argument <b>"toJSON"</b>.</p>
      <p>If IsCallable(<i>toJSON</i>) is <b>true</b></p>
      <p>Let <i>value</i> be the result of calling the [[Call]] internal method of <i>toJSON </i>passing <i>value</i> as the <b>this</b> value and with an argument list consisting of <i>key</i>.</p>
      <p>If <i>ReplacerFunction</i> is not <b>undefined</b>, then</p>
      <p>Let <i>value</i> be the result of calling the [[Call]] internal method of <i>ReplacerFunction</i><i> </i>passing <i>holder</i> as the <b>this</b> value and with an argument list consisting of <i>key</i> and <i>value</i>.</p>
      <p>If Type(<i>value</i>) is Object then,</p>
      <p>If <i>value</i> has an [[NativeBrand]] internal property with value NumberWrapper  then,</p>
      <p>Let <i>value</i> be ToNumber(<i>value</i>).</p>
      <p>Else if <i>value</i> has an [[NativeBrand]] internal property with value StringWrapper  then,</p>
      <p>Let <i>value</i> be ToString(<i>value</i>).</p>
      <p>Else if <i>value</i> has an [[NativeBrand]] internal property with value BooleanWrapper  then,</p>
      <p>Let <i>value</i> be the value of the [[PrimitiveValue]] internal property of <i>value</i>.</p>
      <p>If <i>value</i> is <b>null</b> then return <b>"null"</b>.</p>
      <p>If <i>value</i> is <b>true</b> then return <b>"true"</b>.</p>
      <p>If <i>value</i> is <b>false</b> then return <b>"false"</b>.</p>
      <p>If Type(<i>value</i>) is String, then return the result of calling the abstract operation <i>Quote</i> with argument <i>value</i>.</p>
      <p>If Type(<i>value</i>) is Number</p>
      <p>If <i>value </i>is finite then return ToString(<i>value</i>).</p>
      <p>Else, return <b>"null"</b>.</p>
      <p>If Type(<i>value</i>) is Object, and IsCallable(<i>value</i>) is <b>false</b></p>
      <p>If <i>value</i> has an [[NativeBrand]] internal property with value NativeArray <b> </b>then</p>
      <p>Return the result of calling the abstract operation <i>JA</i> with argument <i>value</i>.</p>
      <p>Else, return the result of calling the abstract operation <i>JO</i> with argument <i>value</i>.</p>
      <p>Return <b>undefined</b>.</p>
      <p>The abstract operation <i>Quote</i>(<i>value</i>) wraps a String value in double quotes and escapes characters within it. </p>
      <p>Let <i>product</i> be the double quote character.</p>
      <p>For each character <i>C</i> in <i>value</i></p>
      <p>If <i>C</i> is the double quote character or the backslash character</p>
      <p>Let <i>product</i> be the concatenation of <i>product</i> and the backslash character.</p>
      <p>Let <i>product</i> be the concatenation of <i>product</i> and <i>C</i>.</p>
      <p>Else if <i>C</i> is backspace, formfeed, newline, carriage return, or tab</p>
      <p>Let <i>product</i> be the concatenation of <i>product</i> and the backslash character.</p>
      <p>Let <i>abbrev</i> be the character corresponding to the value of <i>C</i> as follows:</p>
      <p>backspace	<b>"b"</b></p>
      <p>formfeed	<b>"f"</b></p>
      <p>newline	<b>"n"</b></p>
      <p>carriage return	<b>"r"</b></p>
      <p>tab	<b>"t"</b></p>
      <p>Let <i>product</i> be the concatenation of <i>product</i> and <i>abbrev</i>.</p>
      <p>Else if <i>C</i> is a control character having a code unit value less than the space character</p>
      <p>Let <i>product</i> be the concatenation of <i>product</i> and the backslash character.</p>
      <p>Let <i>product</i> be the concatenation of <i>product</i> and <b>"u"</b>.</p>
      <p>Let <i>hex</i> be the result of converting the numeric code unit value of <i>C</i> to a String of four hexadecimal digits.  Alphabetic hexadecimal digits are presented as lowercase characters. </p>
      <p>Let <i>product</i> be the concatenation of <i>product</i> and <i>hex</i>.</p>
      <p>Else</p>
      <p>Let <i>product</i> be the concatenation of <i>product</i> and <i>C</i>.</p>
      <p>Let <i>product</i> be the concatenation of <i>product</i> and the double quote character.</p>
      <p>Return <i>product</i>.</p>
      <p>The abstract operation <i>JO</i>(<i>value</i>) serializes an object. It has access to the <i>stack</i>, <i>indent</i>, <i>gap</i>, and <i>PropertyList</i> of the invocation of the stringify method.</p>
      <p>If <i>stack</i> contains <i>value</i> then throw a <b>TypeError</b> exception because the structure is cyclical.</p>
      <p>Append <i>value</i> to <i>stack</i>.</p>
      <p>Let <i>stepback</i> be <i>indent</i>.</p>
      <p>Let <i>indent</i> be the concatenation of <i>indent</i> and <i>gap</i>.</p>
      <p>If <i>PropertyList </i>is not <b>undefined</b>, then</p>
      <p>Let <i>K</i> be <i>PropertyList</i>.</p>
      <p>Else</p>
      <p>Let <i>K</i> be an internal List of Strings consisting of the names of all the own properties of <i>value</i> whose [[Enumerable]] attribute is <b>true</b>. The ordering of the Strings should be the same as that used by the <b>Object.keys</b> standard built-in function.</p>
      <p>Let <i>partial</i> be an empty List.</p>
      <p>For each element <i>P</i> of <i>K</i>.</p>
      <p>Let <i>strP</i> be the result of calling the abstract operation <i>Str</i> with arguments <i>P</i> and <i>value</i>.</p>
      <p>If <i>strP</i> is not <b>undefined</b></p>
      <p>Let <i>member</i> be the result of calling the abstract operation <i>Quote</i> with argument <i>P</i>.</p>
      <p>Let <i>member</i> be the concatenation of <i>member</i> and the colon character.</p>
      <p>If <i>gap</i> is not the empty String</p>
      <p>Let <i>member</i> be the concatenation of <i>member</i> and the space character.</p>
      <p>Let <i>member</i> be the concatenation of <i>member</i> and <i>strP</i>.</p>
      <p>Append <i>member</i> to <i>partial</i>.</p>
      <p>If <i>partial</i> is empty, then</p>
      <p>Let <i>final</i> be <b>"{}"</b>.</p>
      <p>Else</p>
      <p>If <i>gap</i> is the empty String</p>
      <p>Let <i>properties</i> be a String formed by concatenating all the element Strings of <i>partial</i> with each adjacent pair of Strings separated with the comma character. A comma is not inserted either before the first String or after the last String. </p>
      <p>Let <i>final</i> be the result of concatenating <b>"{"</b><b>,</b> <i>properties</i>, and <b>"}"</b>.</p>
      <p>Else <i>gap</i> is not the empty String</p>
      <p>Let <i>separator</i> be the result of concatenating the comma character, the line feed character, and <i>indent</i>.</p>
      <p>Let <i>properties</i> be a String formed by concatenating all the element Strings of <i>partial</i> with each adjacent pair of Strings separated with <i>separator</i>. The <i>separator</i> String is not inserted either before the first String or after the last String.</p>
      <p>Let <i>final</i> be the result of concatenating <b>"{"</b>, the line feed character, <i>indent</i>, <i>properties</i>, the line feed character, <i>stepback</i>, and <b>"}</b>".</p>
      <p>Remove the last element of <i>stack</i>.</p>
      <p>Let <i>indent</i> be <i>stepback</i>.</p>
      <p>Return <i>final</i>.</p>
      <p>The abstract operation <i>JA</i>(<i>value</i>) serializes an array. It has access to the <i>stack</i>, <i>indent</i>, and <i>gap</i> of the invocation of the stringify method. The representation of arrays includes only the elements between zero and <b>array.length</b> – 1 inclusive. Named properties are excluded from the stringification. An array is stringified as an open left bracket, elements separated by comma, and a closing right bracket.</p>
      <p>If <i>stack</i> contains <i>value</i> then throw a <b>TypeError</b> exception because the structure is cyclical.</p>
      <p>Append <i>value</i> to <i>stack</i>.</p>
      <p>Let <i>stepback</i> be <i>indent</i>.</p>
      <p>Let <i>indent</i> be the concatenation of <i>indent</i> and <i>gap</i>.</p>
      <p>Let <i>partial</i> be an empty List.</p>
      <p>Let <i>len</i> be the result of calling the [[Get]] internal method of value with argument <b>"length"</b>.</p>
      <p>Let <i>index</i> be 0.</p>
      <p>Repeat while <i>index</i> &lt; <i>len</i></p>
      <p>Let <i>strP</i> be the result of calling the abstract operation <i>Str</i> with arguments ToString(<i>index</i>) and <i>value</i>. </p>
      <p>If <i>strP</i> is <b>undefined</b></p>
      <p>Append <b>"null"</b> to <i>partial</i>.</p>
      <p>Else</p>
      <p>Append  <i>strP</i> to <i>partial</i>.</p>
      <p>Increment <i>index</i> by 1.</p>
      <p>If <i>partial</i> is empty ,then</p>
      <p>Let <i>final</i> be <b>"[]"</b>.</p>
      <p>Else</p>
      <p>If <i>gap</i> is the empty String</p>
      <p>Let <i>properties</i> be a String formed by concatenating all the element Strings of <i>partial</i> with each adjacent pair of Strings separated with the comma character. A comma is not inserted either before the first String or after the last String. </p>
      <p>Let <i>final</i> be the result of concatenating <b>"["</b><b>,</b> <i>properties</i>, and <b>"]"</b>.</p>
      <p>Else</p>
      <p>Let <i>separator</i> be the result of concatenating the comma character, the line feed character, and <i>indent</i>.</p>
      <p>Let <i>properties</i> be a String formed by concatenating all the element Strings of <i>partial</i> with each adjacent pair of Strings separated with <i>separator</i>. The <i>separator</i> String is not inserted either before the first String or after the last String.</p>
      <p>Let <i>final</i> be the result of concatenating <b>"["</b>, the line feed character, <i>indent</i>, <i>properties</i>, the line feed character, <i>stepback</i>, and <b>"]</b>".</p>
      <p>Remove the last element of <i>stack</i>.</p>
      <p>Let <i>indent</i> be <i>stepback</i>.</p>
      <p>Return <i>final</i>.</p>
      <p>NOTE 1<span>	JSON structures are allowed to be nested to any depth, but they must be acyclic. If </span>value is or contains a cyclic structure, then the stringify function must throw a <b>TypeError</b> exception. This is an example of a value that cannot be stringified:</p>
      <p>a = [];</p>
      <p>a[0] = a;</p>
      <p>my_text = JSON.stringify(a); // This must throw an TypeError.</p>
      <p>NOTE 2<span>	Symbolic primitive values are rendered as follows:</span></p>
      <p>The <b>null</b> value is rendered in JSON text as the String null.</p>
      <p>The <b>undefined</b> value is not rendered.</p>
      <p>The <b>true</b> value is rendered in JSON text as the String true.</p>
      <p>The <b>false</b> value is rendered in JSON text as the String false.</p>
      <p>NOTE 3<span>	String values are wrapped in double quotes. The characters </span><b>"</b> and <b>\</b> are escaped with <b>\</b> prefixes. Control characters are replaced with escape sequences <b>\u</b>HHHH, or with the shorter forms, <b>\b</b> (backspace), <b>\f</b> (formfeed), <b>\n</b> (newline), <b>\r</b> (carriage return), <b>\t</b> (tab).</p>
      <p>NOTE 4<span>	Finite numbers are stringified as if by calling </span>ToString<b>(</b><i>number</i><b>)</b>. <b>NaN</b> and Infinity regardless of sign are represented as the String <b>null</b>.</p>
      <p>NOTE 5<span>	Values that do not have a JSON representation (such as </span><b>undefined</b> and functions) do not produce a String. Instead they produce the undefined value. In arrays these values are represented as the String <b>null</b>. In objects an unrepresentable value causes the property to be excluded from stringification.</p>
      <p>NOTE 6<span>	An object is rendered as an opening left brace followed by zero or more properties, separated with commas, closed with a right brace. A property is a quoted String representing the key or property name, a colon, and then the stringified property value. An array is rendered as an opening left bracket followed by zero or more values, separated with commas, closed with a right bracket.</span></p>
      <h1>16<span>	Error</span>s</h1>
      <p>An implementation must report most errors at the time the relevant ECMAScript language construct is evaluated. An <i>early error</i> is an error that can be detected and reported prior to the evaluation of any construct in the <i>Program</i> containing the error.  An implementation must report early errors in a <i>Program</i> prior to the first evaluation of that <i>Program</i>. Early errors in <b>eval</b> code are reported at the time <b>eval</b> is called but prior to evaluation of any construct within the <b>eval</b> code. All errors that are not early errors are runtime errors.</p>
      <p>An implementation must treat any instance of the following kinds of errors as an early error:</p>
      <p>Any syntax error.</p>
      <p>Attempts to define an ObjectLiteral<i> </i>that has multiple <b>get </b>property assignments with the same name or multiple <b>set </b>property assignments with the same name.</p>
      <p>Attempts to define an ObjectLiteral<b> </b>that has both a data property assignment and a <b>get </b>or <b>set </b>property assignment with the same name.</p>
      <p>Errors in regular expression literals that are not implementation-defined syntax extensions.</p>
      <p>Attempts in strict mode code to define an ObjectLiteral that has multiple data property assignments with the same name.</p>
      <p>The occurrence of a WithStatement in strict mode code.</p>
      <p>The occurrence of an Identifier value appearing more than once within a FormalParameterList of an individual strict mode FunctionDeclaration or FunctionExpression.</p>
      <p>Improper uses of <b>return</b>, <b>break</b>, and <b>continue</b>.</p>
      <p>Attempts to call PutValue on any value for which an early determination can be made that the value is not a Reference (for example, executing the assignment statement 3=4).</p>
      <p>An implementation shall not treat other kinds of errors as early errors even if the compiler can prove that a construct cannot execute without error under any circumstances. An implementation may issue an early warning in such a case, but it should not report the error until the relevant construct is actually executed. </p>
      <p>An implementation shall report all errors as specified, except for the following:</p>
      <p>An implementation may extend program syntax and regular expression pattern or flag syntax. To permit this, all operations (such as calling <b>eval</b>, using a regular expression literal, or using the <b>Function</b> or <b>RegExp</b> constructor) that are allowed to throw <b>SyntaxError</b> are permitted to exhibit implementation-defined behaviour instead of throwing <b>SyntaxError</b> when they encounter an implementation-defined extension to the program syntax or regular expression pattern or flag syntax.</p>
      <p>An implementation may provide additional types, values, objects, properties, and functions beyond those described in this specification. This may cause constructs (such as looking up a variable in the global scope) to have implementation-defined behaviour instead of throwing an error (such as <b>ReferenceError</b>).</p>
      <p>An implementation may define behaviour other than throwing <b>RangeError</b> for <b>toFixed</b>, <b>toExponential</b>, and <b>toPrecision</b> when the fractionDigits or precision argument is outside the specified range.</p>
      <p>
      </p>
      <p>
        <hr>
      </p>
      <p><br>(informative){SEQ aaa \h }{SEQ table \r0\h }{SEQ figure \r0\h }<br><br>Grammar Summary</p>
      <p>Lexical Grammar</p>
      <p>SourceCharacter <b>::</b>	See clause 6</p>
      <p>any Unicode code unit</p>
      <p>
      </p>
      <p>InputElementDiv <b>::</b><span>	See clause 7</span></p>
      <p>WhiteSpace<span><br>LineTerminator</span><span><br>Comment</span><span><br>Token</span><span><br>DivPunctuator</span></p>
      <p>
      </p>
      <p>InputElementRegExp <b>::</b>	See clause 7</p>
      <p>WhiteSpace<span><br>LineTerminator</span><span><br>Comment</span><span><br>Token</span><span><br>RegularExpressionLiteral</span></p>
      <p>
      </p>
      <p>WhiteSpace <b>::</b>	See 7.2</p>
      <p>&lt;TAB&gt;<span><br>&lt;VT&gt;</span><span><br>&lt;FF&gt;</span><span><br>&lt;SP&gt;</span><span><br>&lt;NBSP&gt;</span><span><br>&lt;BOM&gt;</span><span><br>&lt;USP&gt;</span></p>
      <p>
      </p>
      <p>LineTerminator <b>::</b><span>	See 7.3</span></p>
      <p>&lt;LF&gt;<span><br>&lt;CR&gt;</span><span><br>&lt;LS&gt;</span><span><br>&lt;PS&gt;</span></p>
      <p>
      </p>
      <p>LineTerminatorSequence <b>::</b><b>	</b>See 7.3</p>
      <p>&lt;LF&gt;<span><br>&lt;CR&gt; </span>[lookahead ∈ &lt;LF&gt; ]<span><br>&lt;LS&gt;</span><span><br>&lt;PS&gt;</span><span><br>&lt;CR&gt; &lt;LF&gt;</span></p>
      <p>
      </p>
      <p>Comment <b>::</b>	See 7.4</p>
      <p>MultiLineComment<span><br>SingleLineComment</span></p>
      <p>
      </p>
      <p>MultiLineComment <b>::</b><span>	See 7.4</span></p>
      <p><b>/*</b> MultiLineCommentChars<sub>opt</sub> <b>*/</b></p>
      <p>
      </p>
      <p>MultiLineCommentChars <b>::</b><span>	See 7.4</span></p>
      <p>MultiLineNotAsteriskChar MultiLineCommentChars<sub>opt</sub><br><b>*</b> PostAsteriskCommentChars<sub>opt</sub></p>
      <p>
      </p>
      <p>PostAsteriskCommentChars <b>::</b><span>	See 7.4</span></p>
      <p>MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars<sub>opt</sub><br><b>*</b> PostAsteriskCommentChars<sub>opt</sub></p>
      <p>
      </p>
      <p>MultiLineNotAsteriskChar <b>::</b><span>	See 7.4</span></p>
      <p>SourceCharacter <b>but not</b> <b>*</b></p>
      <p>
      </p>
      <p>MultiLineNotForwardSlashOrAsteriskChar <b>::</b><span>	See 7.4</span></p>
      <p>SourceCharacter <b>but not one of</b> <b>/</b><b> </b><b>or</b> <b>*</b></p>
      <p>
      </p>
      <p>SingleLineComment <b>::</b><span>	See 7.4</span></p>
      <p><b>//</b> SingleLineCommentChars<sub>opt</sub></p>
      <p>
      </p>
      <p>SingleLineCommentChars <b>::</b><span>	See 7.4</span></p>
      <p>SingleLineCommentChar SingleLineCommentChars<sub>opt</sub></p>
      <p>
      </p>
      <p>SingleLineCommentChar <b>::</b><span>	See 7.4</span></p>
      <p>SourceCharacter<b> </b><b>but not</b><b> </b>LineTerminator</p>
      <p>
      </p>
      <p>Token <b>::</b>	See 7.5</p>
      <p>IdentifierName<span><br>Punctuator</span><span><br>NumericLiteral</span><span><br>StringLiteral</span></p>
      <p>
      </p>
      <p>Identifier <b>::</b><span>	See 7.6</span></p>
      <p>IdentifierName <b>but not</b> ReservedWord</p>
      <p>
      </p>
      <p>IdentifierName <b>::</b><span>	See 7.6</span></p>
      <p>IdentifierStart<span><br>IdentifierName IdentifierPart</span></p>
      <p>
      </p>
      <p>IdentifierStart <b>::</b><span>	See 7.6</span></p>
      <p>UnicodeLetter<br><b>$</b><b><br>_</b><br><b>\</b> UnicodeEscapeSequence</p>
      <p>
      </p>
      <p>IdentifierPart <b>::</b><span>	See 7.6</span></p>
      <p>IdentifierStart<span><br>UnicodeCombiningMark</span><span><br>UnicodeDigit</span><span><br>UnicodeConnectorPunctuation</span><br>&lt;ZWNJ&gt;<span><br>&lt;ZWJ&gt;</span></p>
      <p>UnicodeLetter <b>::</b><span>	See 7.6</span></p>
      <p>any character in the Unicode categories “Uppercase letter (Lu)”, “Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter (Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.</p>
      <p>UnicodeCombiningMark <b>::</b><span>	See 7.6</span></p>
      <p>any character in the Unicode categories “Non-spacing mark (Mn)” or “Combining spacing mark (Mc)”</p>
      <p>UnicodeDigit <b>::</b><span>	See 7.6</span></p>
      <p>any character in the Unicode category “Decimal number (Nd)”</p>
      <p>UnicodeConnectorPunctuation <b>::</b><span>	See 7.6</span></p>
      <p>any character in the Unicode category “Connector punctuation (Pc)”</p>
      <p>ReservedWord <b>::</b><span>	See 7.6.1</span></p>
      <p>Keyword<span><br>FutureReservedWord</span><span><br>NullLiteral</span><span><br>BooleanLiteral</span></p>
      <p>
      </p>
      <p>Keyword <b>::</b> <b>one of</b>	See 7.6.1.1</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>break</p>
            </td>
            <td>
              <p>do </p>
            </td>
            <td>
              <p>instanceof </p>
            </td>
            <td>
              <p>typeof </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>case</p>
            </td>
            <td>
              <p>else</p>
            </td>
            <td>
              <p>new</p>
            </td>
            <td>
              <p>var</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>catch</p>
            </td>
            <td>
              <p>finally</p>
            </td>
            <td>
              <p>return</p>
            </td>
            <td>
              <p>void</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>continue</p>
            </td>
            <td>
              <p>for</p>
            </td>
            <td>
              <p>switch</p>
            </td>
            <td>
              <p>while</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>debugger </p>
            </td>
            <td>
              <p>function</p>
            </td>
            <td>
              <p>this</p>
            </td>
            <td>
              <p>with</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>default</p>
            </td>
            <td>
              <p>if</p>
            </td>
            <td>
              <p>throw</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>delete</p>
            </td>
            <td>
              <p>in</p>
            </td>
            <td>
              <p>try</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>
      </p>
      <p>FutureReservedWord<b> </b><b>::</b><b> </b><b>one of</b>	See 7.6.1.2</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>class</p>
            </td>
            <td>
              <p>enum</p>
            </td>
            <td>
              <p>extends</p>
            </td>
            <td>
              <p>super</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>const</p>
            </td>
            <td>
              <p>export</p>
            </td>
            <td>
              <p>import<br></p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>The following tokens are also considered to be <i>FutureReservedWords</i> when parsing strict mode code (see 10.1.1).</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>implements</p>
            </td>
            <td>
              <p>let</p>
            </td>
            <td>
              <p>private</p>
            </td>
            <td>
              <p>public</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>interface</p>
            </td>
            <td>
              <p>package</p>
            </td>
            <td>
              <p>protected</p>
            </td>
            <td>
              <p>static</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>yield</p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>Punctuator <b>::</b> <b>one of</b>	See 7.7</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>{</p>
            </td>
            <td>
              <p>}</p>
            </td>
            <td>
              <p>(</p>
            </td>
            <td>
              <p>)</p>
            </td>
            <td>
              <p>[</p>
            </td>
            <td>
              <p>]</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>.</p>
            </td>
            <td>
              <p>;</p>
            </td>
            <td>
              <p>,</p>
            </td>
            <td>
              <p>&lt;</p>
            </td>
            <td>
              <p>&gt;</p>
            </td>
            <td>
              <p>&lt;=</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>&gt;=</p>
            </td>
            <td>
              <p>==</p>
            </td>
            <td>
              <p>!=</p>
            </td>
            <td>
              <p>===</p>
            </td>
            <td>
              <p>!==</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p>+</p>
            </td>
            <td>
              <p>-</p>
            </td>
            <td>
              <p>*</p>
            </td>
            <td>
              <p>%</p>
            </td>
            <td>
              <p>++</p>
            </td>
            <td>
              <p>--</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>&lt;&lt;</p>
            </td>
            <td>
              <p>&gt;&gt;</p>
            </td>
            <td>
              <p>&gt;&gt;&gt;</p>
            </td>
            <td>
              <p>&amp;</p>
            </td>
            <td>
              <p>|</p>
            </td>
            <td>
              <p>^</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>!</p>
            </td>
            <td>
              <p>~</p>
            </td>
            <td>
              <p>&amp;&amp;</p>
            </td>
            <td>
              <p>||</p>
            </td>
            <td>
              <p>?</p>
            </td>
            <td>
              <p>:</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>=</p>
            </td>
            <td>
              <p>+=</p>
            </td>
            <td>
              <p>-=</p>
            </td>
            <td>
              <p>*=</p>
            </td>
            <td>
              <p>%=</p>
            </td>
            <td>
              <p>&lt;&lt;=</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>&gt;&gt;=</p>
            </td>
            <td>
              <p>&gt;&gt;&gt;=</p>
            </td>
            <td>
              <p>&amp;=</p>
            </td>
            <td>
              <p>|=</p>
            </td>
            <td>
              <p>^=</p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>
      </p>
      <p>DivPunctuator <b>::</b> <b>one of</b>	See 7.7</p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>/</p>
            </td>
            <td>
              <p>/=</p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
            <td>
              <p>
              </p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>Literal <b>::</b>	See 7.8</p>
      <p>NullLiteral<span><br>BooleanLiteral</span><span><br>NumericLiteral</span><span><br>StringLiteral</span><span><br>RegularExpressionLiteral</span></p>
      <p>
      </p>
      <p>NullLiteral <b>::</b>	See 7.8.1</p>
      <p>
        <b>null</b>
      </p>
      <p>
      </p>
      <p>BooleanLiteral <b>::</b><span>	See 7.8.2</span></p>
      <p>
        <b>true</b>
        <b><br>false</b>
      </p>
      <p>
      </p>
      <p><i>NumericLiteral</i> <b>::</b><span>	See 7.8.3</span></p>
      <p>DecimalLiteral<span><br>HexIntegerLiteral</span></p>
      <p>
      </p>
      <p>DecimalLiteral <b>::</b><span>	See 7.8.3</span></p>
      <p>DecimalIntegerLiteral <b>.</b> DecimalDigits<sub>opt</sub><sub> </sub>ExponentPart<sub>opt</sub><br><b>.</b> DecimalDigits ExponentPart<sub>opt</sub><span><br>DecimalIntegerLiteral ExponentPart</span><sub>opt</sub></p>
      <p>
      </p>
      <p>DecimalIntegerLiteral <b>::</b><span>	See 7.8.3</span></p>
      <p>
        <b>0</b>
        <span><br>NonZeroDigit DecimalDigits</span>
        <sub>opt</sub>
      </p>
      <p>
      </p>
      <p>DecimalDigits <b>::</b><span>	See 7.8.3</span></p>
      <p>DecimalDigit<span><br>DecimalDigits DecimalDigit</span></p>
      <p>
      </p>
      <p>DecimalDigit <b>::</b><b> </b><b>one of</b>	See 7.8.3</p>
      <p>
        <b>0  1  2  3  4  5  6  7  8  9</b>
      </p>
      <p>
      </p>
      <p>NonZeroDigit <b>::</b><b> </b><b>one of</b> <span>	See 7.8.3</span></p>
      <p>
        <b>1  2  3  4  5  6  7  8  9</b>
      </p>
      <p>ExponentPart <b>::</b> <span>	See 7.8.3</span></p>
      <p>ExponentIndicator SignedInteger</p>
      <p>ExponentIndicator <b>::</b><b> </b><b>one of</b><span>	See 7.8.3</span></p>
      <p>
        <b>e  E</b>
      </p>
      <p>
      </p>
      <p>SignedInteger <b>::</b><span>	See 7.8.3</span></p>
      <p>DecimalDigits<br><b>+</b> DecimalDigits<br><b>-</b> DecimalDigits</p>
      <p>
      </p>
      <p>HexIntegerLiteral <b>::</b><span>	See 7.8.3</span></p>
      <p><b>0x</b> HexDigit<br><b>0X</b> HexDigit<span><br>HexIntegerLiteral HexDigit</span></p>
      <p>HexDigit <b>::</b><b> </b><b>one of</b>	See 7.8.3</p>
      <p>
        <b>0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F</b>
      </p>
      <p>StringLiteral <b>::</b><span>	See 7.8.4</span></p>
      <p><b>"</b> DoubleStringCharacters<sub>opt</sub><b> </b><b>"</b><b><br>'</b> SingleStringCharacters<sub>opt</sub><sub> </sub> <b>'</b></p>
      <p>DoubleStringCharacters <b>::</b><span>	See 7.8.4</span></p>
      <p>DoubleStringCharacter DoubleStringCharacters<sub>opt</sub></p>
      <p>SingleStringCharacters <b>::</b><span>	See 7.8.4</span></p>
      <p>SingleStringCharacter SingleStringCharacters<sub>opt</sub></p>
      <p>DoubleStringCharacter <b>::</b><span>	See 7.8.4</span></p>
      <p>SourceCharacter <b>but not one of</b> <b>"</b><b> </b><b>or</b><b> </b><b>\</b> <b>or</b><b> </b>LineTerminator<br><b>\ </b>EscapeSequence<span><br>LineContinuation</span></p>
      <p>SingleStringCharacter <b>::</b><span>	See 7.8.4</span></p>
      <p>SourceCharacter <b>but not one of</b> <b>'</b><b> </b><b>or</b> <b>\</b> <b>or</b><b> </b>LineTerminator<br><b>\ </b>EscapeSequence<span><br>LineContinuation</span></p>
      <p>LineContinuation <b>::</b><span>	See 7.8.4</span></p>
      <p><b>\ </b>LineTerminatorSequence</p>
      <p>EscapeSequence <b>::</b><span>	See 7.8.4</span></p>
      <p>CharacterEscapeSequence<br><b>0</b>  [lookahead ∈ DecimalDigit]<span><br>HexEscapeSequence</span><span><br>UnicodeEscapeSequence</span></p>
      <p>CharacterEscapeSequence <b>::</b><span>	See 7.8.4</span></p>
      <p>SingleEscapeCharacter<span><br>NonEscapeCharacter</span></p>
      <p>SingleEscapeCharacter <b>::</b>  <b>one of</b><span>	See 7.8.4</span></p>
      <p>
        <b>'  "  \  b  f  n  r  t  v</b>
      </p>
      <p>NonEscapeCharacter <b>::</b><b>	</b>See 7.8.4</p>
      <p>SourceCharacter<b> </b><b>but not one of</b> EscapeCharacter <b>or</b><b> </b>LineTerminator</p>
      <p>
      </p>
      <p>EscapeCharacter <b>::</b><span>	See 7.8.4</span></p>
      <p>SingleEscapeCharacter<span><br>DecimalDigit</span><br><b>x</b><b><br></b><b>u</b></p>
      <p>HexEscapeSequence <b>::</b><span>	See 7.8.4</span></p>
      <p><b>x </b>HexDigit HexDigit</p>
      <p>
      </p>
      <p>UnicodeEscapeSequence <b>::</b><span>	See 7.8.4</span></p>
      <p><b>u</b> HexDigit HexDigit HexDigit HexDigit</p>
      <p>
      </p>
      <p>RegularExpressionLiteral <b>::</b><span>	See 7.8.5</span></p>
      <p><b>/</b> RegularExpressionBody<b> </b><b>/</b><b> </b>RegularExpressionFlags</p>
      <p>
      </p>
      <p>RegularExpressionBody <b>::</b><span>	See 7.8.5</span></p>
      <p>RegularExpressionFirstChar RegularExpressionChars</p>
      <p>
      </p>
      <p>RegularExpressionChars <b>::</b><span>	See 7.8.5</span></p>
      <p>[empty]<span><br>RegularExpressionChars RegularExpressionChar</span></p>
      <p>
      </p>
      <p>RegularExpressionFirstChar <b>::</b><span>	See 7.8.5</span></p>
      <p>RegularExpressionNonTerminator <b>but not one of</b> <b>*</b><b> </b><b>or</b><b> </b><b>\</b> <b>or</b><b> </b><b>/ </b><b>or</b><b> [</b><span><br>RegularExpressionBackslashSequence</span><span><br>RegularExpressionClass</span></p>
      <p>
      </p>
      <p>RegularExpressionChar <b>::</b><span>	See 7.8.5</span></p>
      <p>RegularExpressionNonTerminator <b>but not</b><b> </b><b>\</b><b> </b><b>or</b><b> </b><b>/ </b><b>or</b><b> [</b><span><br>RegularExpressionBackslashSequence</span><span><br>RegularExpressionClass</span></p>
      <p>
      </p>
      <p>RegularExpressionBackslashSequence <b>::</b><span>	See 7.8.5</span></p>
      <p><b>\</b> RegularExpressionNonTerminator</p>
      <p>
      </p>
      <p>RegularExpressionNonTerminator <b>::</b><span>	See 7.8.5</span></p>
      <p>SourceCharacter <b>but not</b><b> </b>LineTerminator</p>
      <p>
      </p>
      <p>RegularExpressionClass <b>::</b><span>	See 7.8.5</span></p>
      <p><b>[ </b>RegularExpressionClassChars<b> ]</b></p>
      <p>
      </p>
      <p>RegularExpressionClassChars<b> </b><b>::</b> <span>	See 7.8.5</span></p>
      <p>[empty]<span><br>RegularExpressionClassChars</span><b> </b>RegularExpressionClassChar</p>
      <p>
      </p>
      <p>RegularExpressionClassChar<b> </b><b>::</b> <span>	See 7.8.5</span></p>
      <p>RegularExpressionNonTerminator<b> </b><b>but not</b><b> </b><b>]</b><b> </b><b>or</b><b> </b><b>\</b><b><br></b>RegularExpressionBackslashSequence</p>
      <p>
      </p>
      <p>RegularExpressionFlags <b>::</b><span>	See 7.8.5</span></p>
      <p>[empty]<span><br>RegularExpressionFlags IdentifierPart</span></p>
      <p>Number Conversions</p>
      <p>StringNumericLiteral <b>:::</b><span>	See 9.3.1</span></p>
      <p>StrWhiteSpace<sub>opt</sub><span><br>StrWhiteSpace</span><sub>opt</sub> StrNumericLiteral StrWhiteSpace<sub>opt</sub></p>
      <p>
      </p>
      <p>StrWhiteSpace <b>:::</b><span>	See 9.3.1</span></p>
      <p>StrWhiteSpaceChar StrWhiteSpace<sub>opt</sub></p>
      <p>
      </p>
      <p>StrWhiteSpaceChar <b>:::</b><span>	See 9.3.1</span></p>
      <p>WhiteSpace<span><br>LineTerminator</span></p>
      <p>
      </p>
      <p>StrNumericLiteral <b>:::</b><span>	See 9.3.1</span></p>
      <p>StrDecimalLiteral<span><br>HexIntegerLiteral</span></p>
      <p>StrDecimalLiteral <b>:::</b><span>	See 9.3.1</span></p>
      <p>StrUnsignedDecimalLiteral<br><b>+ </b>StrUnsignedDecimalLiteral<br><b>- </b>StrUnsignedDecimalLiteral</p>
      <p>
      </p>
      <p>StrUnsignedDecimalLiteral <b>:::</b><span>	See 9.3.1</span></p>
      <p><b>Infinity</b><span><br>DecimalDigits </span><b>.</b> DecimalDigits<sub>opt</sub><sub> </sub>ExponentPart<sub>opt</sub><br><b>.</b> DecimalDigits ExponentPart<sub>opt</sub><span><br>DecimalDigits ExponentPart</span><sub>opt</sub></p>
      <p>
      </p>
      <p>DecimalDigits <b>:::</b><span>	See 9.3.1</span></p>
      <p>DecimalDigit<span><br>DecimalDigits DecimalDigit</span></p>
      <p>
      </p>
      <p>DecimalDigit <b>:::</b> <b>one of</b>	See 9.3.1</p>
      <p>
        <b>0  1  2  3  4  5  6  7  8  9</b>
      </p>
      <p>
      </p>
      <p>ExponentPart <b>:::</b>	See 9.3.1</p>
      <p>ExponentIndicator SignedInteger</p>
      <p>
      </p>
      <p>ExponentIndicator <b>:::</b><b> </b><b>one of</b>	See 9.3.1</p>
      <p>
        <b>e  E</b>
      </p>
      <p>
      </p>
      <p>SignedInteger <b>:::</b><span>	See 9.3.1</span></p>
      <p>DecimalDigits<br><b>+ </b>DecimalDigits<br><b>- </b>DecimalDigits</p>
      <p>
      </p>
      <p>HexIntegerLiteral <b>:::</b><span>	See 9.3.1</span></p>
      <p><b>0x</b> HexDigit<br><b>0X</b> HexDigit<span><br>HexIntegerLiteral HexDigit</span></p>
      <p>
      </p>
      <p>HexDigit <b>:::</b><b> </b><b>one of</b>	See 9.3.1</p>
      <p>
        <b>0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F</b>
      </p>
      <p>Expressions</p>
      <p>PrimaryExpression <b>:</b><span>	See 11.1</span></p>
      <p><b>this</b><span><br>Identifier</span><span><br>Literal</span><span><br>ArrayLiteral</span><span><br>ObjectLiteral</span><br><b>(</b> Expression <b>)</b></p>
      <p>
      </p>
      <p>ArrayLiteral <b>:</b><span>	See 11.1.4</span></p>
      <p><b>[ </b>Elision<sub>opt</sub> <b>]</b><b><br>[ </b>ElementList <b>]</b><b><br>[ </b>ElementList <b>,</b> Elision<sub>opt</sub> <b>]</b></p>
      <p>
      </p>
      <p>ElementList <b>:</b>	See 11.1.4</p>
      <p>Elision<sub>opt</sub><sub> </sub>AssignmentExpression<span><br>ElementList</span> <b>,</b> Elision<sub>opt</sub><sub> </sub>AssignmentExpression</p>
      <p>
      </p>
      <p>Elision <b>:</b>	See 11.1.4</p>
      <p><b>,</b><span><br>Elision</span> <b>,</b></p>
      <p>
      </p>
      <p>ObjectLiteral <b>:</b><span>	See 11.1.5</span></p>
      <p><b>{ }</b><br><b>{ </b>PropertyNameAndValueList <b>}</b><b><br>{ </b>PropertyNameAndValueList <b>,</b> <b>}</b></p>
      <p>
      </p>
      <p>PropertyNameAndValueList <b>:</b><b>	</b>See 11.1.5</p>
      <p>PropertyAssignment<span><br>PropertyNameAndValueList</span> <b>,</b>  PropertyAssignment</p>
      <p>PropertyAssignment <b>:</b><b>	</b>See 11.1.5</p>
      <p>PropertyName <b>:</b> AssignmentExpression<br><b>get </b>PropertyName<b> ( ) { </b>FunctionBody <b>}</b><b><br>set </b>PropertyName<b> ( </b>PropertySetParameterList<b> ) { </b>FunctionBody<b> </b><b>}</b></p>
      <p>
      </p>
      <p>PropertyName <b>:</b><b>	</b>See 11.1.5</p>
      <p>IdentifierName<span><br>StringLiteral</span><span><br>NumericLiteral</span></p>
      <p>PropertySetParameterList <b>:</b><b>	</b>See 11.1.5</p>
      <p>Identifier</p>
      <p>MemberExpression <b>:</b><b>	</b>See 11.2</p>
      <p>PrimaryExpression<span><br>FunctionExpression</span><span><br>MemberExpression </span><b>[</b> Expression <b>]</b><b><br></b>MemberExpression <b>.</b> IdentifierName<br><b>new</b> MemberExpression<b> </b><i>Arguments</i></p>
      <p>
      </p>
      <p>NewExpression <b>:</b><b>	</b>See 11.2</p>
      <p>MemberExpression<b><br>new</b> NewExpression</p>
      <p>
      </p>
      <p>CallExpression <b>:</b><b>	</b>See 11.2</p>
      <p>MemberExpression<b> </b>Arguments<b><br></b>CallExpression<b> </b>Arguments<b><br></b>CallExpression <b>[</b> Expression <b>]</b><b><br></b>CallExpression <b>.</b> IdentifierName</p>
      <p>
      </p>
      <p>Arguments <b>:</b><b>	</b>See 11.2</p>
      <p><b>(</b> <b>)</b><b><br>(</b> ArgumentList  <b>)</b></p>
      <p>
      </p>
      <p>ArgumentList <b>:</b><b>	</b>See 11.2</p>
      <p>AssignmentExpression<span><br>ArgumentList </span><b>,</b> AssignmentExpression</p>
      <p>
      </p>
      <p>LeftHandSideExpression <b>:</b><b>	</b>See 11.2</p>
      <p>NewExpression<span><br>CallExpression</span></p>
      <p>
      </p>
      <p>PostfixExpression <b>:</b><b>	</b>See 11.3</p>
      <p>LeftHandSideExpression<span><br>LeftHandSideExpression</span><b> </b>[no LineTerminator here]<b> ++</b><span><br>LeftHandSideExpression</span><b> </b>[no LineTerminator here]<b> --</b></p>
      <p>
      </p>
      <p>UnaryExpression <b>:</b><b>	</b>See 11.4</p>
      <p>PostfixExpression<b><br>delete </b>UnaryExpression<br><b>void </b>UnaryExpression<br><b>typeof </b>UnaryExpression<b><br>++</b> UnaryExpression<br><b>--</b> UnaryExpression<br><b>+</b> UnaryExpression<br><b>-</b> UnaryExpression<br><b>~</b> UnaryExpression<br><b>!</b> UnaryExpression</p>
      <p>
      </p>
      <p>MultiplicativeExpression <b>:</b><b>	</b>See 11.5</p>
      <p>UnaryExpression<span><br>MultiplicativeExpression </span><b>*</b> UnaryExpression<span><br>MultiplicativeExpression </span><b>/</b> UnaryExpression<span><br>MultiplicativeExpression </span><b>%</b> UnaryExpression</p>
      <p>
      </p>
      <p>AdditiveExpression <b>:</b><b>	</b>See 11.6</p>
      <p>MultiplicativeExpression<span><br>AdditiveExpression </span><b>+</b> MultiplicativeExpression<span><br>AdditiveExpression </span><b>-</b> MultiplicativeExpression</p>
      <p>
      </p>
      <p>ShiftExpression <b>:</b><b>	</b>See 11.7</p>
      <p>AdditiveExpression<span><br>ShiftExpression </span><b>&lt;&lt;</b> AdditiveExpression<span><br>ShiftExpression </span><b>&gt;&gt;</b> AdditiveExpression<span><br>ShiftExpression </span><b>&gt;&gt;&gt;</b> AdditiveExpression</p>
      <p>
      </p>
      <p>RelationalExpression <b>:</b><b>	</b>See 11.8</p>
      <p>ShiftExpression<span><br>RelationalExpression </span><b>&lt;</b> ShiftExpression<span><br>RelationalExpression </span><b>&gt;</b> ShiftExpression<span><br>RelationalExpression </span><b>&lt;=</b> ShiftExpression<span><br>RelationalExpression </span><b>&gt;=</b> ShiftExpression<span><br>RelationalExpression </span><b>instanceof</b> ShiftExpression<span><br>RelationalExpression </span><b>in</b> ShiftExpression</p>
      <p>
      </p>
      <p>RelationalExpressionNoIn <b>:</b><b>	</b>See 11.8</p>
      <p>ShiftExpression<span><br>RelationalExpressionNoIn </span><b>&lt;</b> ShiftExpression<span><br>RelationalExpressionNoIn </span><b>&gt;</b> ShiftExpression<span><br>RelationalExpressionNoIn </span><b>&lt;=</b> ShiftExpression<span><br>RelationalExpressionNoIn </span><b>&gt;=</b> ShiftExpression<span><br>RelationalExpressionNoIn </span><b>instanceof</b> ShiftExpression</p>
      <p>
      </p>
      <p>EqualityExpression <b>:</b><b>	</b>See 11.9</p>
      <p>RelationalExpression<span><br>EqualityExpression </span><b>==</b> RelationalExpression<span><br>EqualityExpression </span><b>!=</b> RelationalExpression<span><br>EqualityExpression </span><b>===</b> RelationalExpression<span><br>EqualityExpression </span><b>!==</b> RelationalExpression</p>
      <p>
      </p>
      <p>EqualityExpressionNoIn <b>:</b><b>	</b>See 11.9</p>
      <p>RelationalExpressionNoIn<span><br>EqualityExpressionNoIn </span><b>==</b> RelationalExpressionNoIn<span><br>EqualityExpressionNoIn </span><b>!=</b> RelationalExpressionNoIn<span><br>EqualityExpressionNoIn </span><b>===</b> RelationalExpressionNoIn<span><br>EqualityExpressionNoIn </span><b>!==</b> RelationalExpressionNoIn</p>
      <p>
      </p>
      <p>BitwiseANDExpression <b>:</b><b>	</b>See 11.10</p>
      <p>EqualityExpression<span><br>BitwiseANDExpression </span><b>&amp;</b> EqualityExpression</p>
      <p>
      </p>
      <p>BitwiseANDExpressionNoIn <b>:</b><b>	</b>See 11.10</p>
      <p>EqualityExpressionNoIn<span><br>BitwiseANDExpressionNoIn </span><b>&amp;</b> EqualityExpressionNoIn</p>
      <p>
      </p>
      <p>BitwiseXORExpression <b>:</b><b>	</b>See 11.10</p>
      <p>BitwiseANDExpression<span><br>BitwiseXORExpression </span><b>^</b> BitwiseANDExpression</p>
      <p>
      </p>
      <p>BitwiseXORExpressionNoIn <b>:</b><b>	</b>See 11.10</p>
      <p>BitwiseANDExpressionNoIn<span><br>BitwiseXORExpressionNoIn </span><b>^</b> BitwiseANDExpressionNoIn</p>
      <p>
      </p>
      <p>BitwiseORExpression <b>:</b><b>	</b>See 11.10</p>
      <p>BitwiseXORExpression<span><br>BitwiseORExpression </span><b>|</b> BitwiseXORExpression</p>
      <p>
      </p>
      <p>BitwiseORExpressionNoIn <b>:</b><b>	</b>See 11.10</p>
      <p>BitwiseXORExpressionNoIn<span><br>BitwiseORExpressionNoIn </span><b>|</b> BitwiseXORExpressionNoIn</p>
      <p>
      </p>
      <p>LogicalANDExpression <b>:</b><b>	</b>See 11.11</p>
      <p>BitwiseORExpression<span><br>LogicalANDExpression </span><b>&amp;&amp;</b> BitwiseORExpression</p>
      <p>
      </p>
      <p>LogicalANDExpressionNoIn <b>:</b><b>	</b>See 11.11</p>
      <p>BitwiseORExpressionNoIn<span><br>LogicalANDExpressionNoIn </span><b>&amp;&amp;</b> BitwiseORExpressionNoIn</p>
      <p>
      </p>
      <p>LogicalORExpression <b>:</b><b>	</b>See 11.11</p>
      <p>LogicalANDExpression<span><br>LogicalORExpression </span><b>||</b> LogicalANDExpression</p>
      <p>
      </p>
      <p>LogicalORExpressionNoIn <b>:</b><b>	</b>See 11.11</p>
      <p>LogicalANDExpressionNoIn<span><br>LogicalORExpressionNoIn </span><b>||</b> LogicalANDExpressionNoIn</p>
      <p>
      </p>
      <p>ConditionalExpression <b>:</b><b>	</b>See 11.12</p>
      <p>LogicalORExpression<span><br>LogicalORExpression</span><b> ?</b> AssignmentExpression <b>:</b> AssignmentExpression</p>
      <p>
      </p>
      <p>ConditionalExpressionNoIn <b>:</b><b>	</b>See 11.12</p>
      <p>LogicalORExpressionNoIn<span><br>LogicalORExpressionNoIn</span><b> ?</b> AssignmentExpression <b>:</b> AssignmentExpressionNoIn</p>
      <p>
      </p>
      <p>AssignmentExpression <b>:</b><b>	</b>See 11.13</p>
      <p>ConditionalExpression<span><br>LeftHandSideExpression</span><b> = </b>AssignmentExpression <span><br>LeftHandSideExpression AssignmentOperator AssignmentExpression</span></p>
      <p>
      </p>
      <p>AssignmentExpressionNoIn <b>:</b><b>	</b>See 11.13</p>
      <p>ConditionalExpressionNoIn<span><br>LeftHandSideExpression</span><b> = </b>AssignmentExpressionNoIn<span><br>LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn</span></p>
      <p>
      </p>
      <p>AssignmentOperator <b>:</b><b> </b><b>one of</b><span>	See 11.13</span></p>
      <figure>
        <table class="real-table">
          <tr>
            <td>
              <p>*=</p>
            </td>
            <td>
              <p>/=</p>
            </td>
            <td>
              <p>%=</p>
            </td>
            <td>
              <p>+=</p>
            </td>
            <td>
              <p>-=</p>
            </td>
            <td>
              <p>&lt;&lt;=</p>
            </td>
            <td>
              <p>&gt;&gt;=</p>
            </td>
            <td>
              <p>&gt;&gt;&gt;=</p>
            </td>
            <td>
              <p>&amp;=</p>
            </td>
            <td>
              <p>^=</p>
            </td>
            <td>
              <p>|=</p>
            </td>
          </tr>
        </table>
      </figure>
      <p>
      </p>
      <p>Expression <b>:</b><b>	</b>See 11.14</p>
      <p>AssignmentExpression<span><br>Expression </span><b>,</b> AssignmentExpression</p>
      <p>
      </p>
      <p>ExpressionNoIn <b>:</b><span>	See 11.14</span></p>
      <p>AssignmentExpressionNoIn<span><br>ExpressionNoIn </span><b>,</b> AssignmentExpressionNoIn</p>
      <p>Statements</p>
      <p>Statement <b>:</b>	See clause 12</p>
      <p>Block<span><br>VariableStatement</span><span><br>EmptyStatement</span><span><br>ExpressionStatement</span><span><br>IfStatement</span><span><br>IterationStatement</span><span><br>ContinueStatement</span><span><br>BreakStatement</span><span><br>ReturnStatement</span><span><br>WithStatement</span><span><br>LabelledStatement</span><span><br>SwitchStatement</span><span><br>ThrowStatement</span><span><br>TryStatement</span><span><br>DebuggerStatement</span></p>
      <p>Block <b>:</b><b>	</b>See 12.1</p>
      <p><b>{</b> StatementList<sub>opt</sub> <b>}</b></p>
      <p>
      </p>
      <p>StatementList <b>:</b><b>	</b>See 12.1</p>
      <p>Statement<span><br>StatementList Statement</span></p>
      <p>
      </p>
      <p>VariableStatement <b>:</b><b>	</b>See 12.2</p>
      <p><b>var</b> VariableDeclarationList <b>;</b></p>
      <p>
      </p>
      <p>VariableDeclarationList <b>:</b><b>	</b>See 12.2</p>
      <p>VariableDeclaration<span><br>VariableDeclarationList </span><b>,</b> VariableDeclaration</p>
      <p>
      </p>
      <p>VariableDeclarationListNoIn <b>:</b><b>	</b>See 12.2</p>
      <p>VariableDeclarationNoIn<span><br>VariableDeclarationListNoIn </span><b>,</b> VariableDeclarationNoIn</p>
      <p>
      </p>
      <p>VariableDeclaration <b>:</b><b>	</b>See 12.2</p>
      <p>Identifier Initialiser<sub>opt</sub></p>
      <p>
      </p>
      <p>VariableDeclarationNoIn <b>:</b><b>	</b>See 12.2</p>
      <p>Identifier InitialiserNoIn<sub>opt</sub></p>
      <p>
      </p>
      <p>Initialiser <b>:</b><b>	</b>See 12.2</p>
      <p><b>=</b> AssignmentExpression</p>
      <p>
      </p>
      <p>InitialiserNoIn <b>:</b><b>	</b>See 12.2</p>
      <p><b>=</b> AssignmentExpressionNoIn</p>
      <p>
      </p>
      <p>EmptyStatement <b>:</b><b>	</b>See 12.3</p>
      <p>
        <b>;</b>
      </p>
      <p>
      </p>
      <p>ExpressionStatement <b>:</b><b>	</b>See 12.4</p>
      <p>[lookahead ∈ {<b>{</b>,<b> function</b>}] Expression <b>;</b></p>
      <p>
      </p>
      <p>IfStatement <b>:</b><b>	</b>See 12.5</p>
      <p><b>if</b> <b>(</b> Expression <b>)</b> Statement  <b>else</b> Statement<br><b>if</b> <b>(</b> Expression <b>)</b> Statement</p>
      <p>
      </p>
      <p>IterationStatement <b>:</b><b>	</b>See 12.6</p>
      <p><b>do </b>Statement<b> while</b> <b>(</b> Expression <b>);</b><br><b>while</b> <b>(</b> Expression <b>)</b> Statement<br><b>for</b> <b>(</b>ExpressionNoIn<sub>opt</sub><b>;</b> Expression<sub>opt</sub> <b>;</b> Expression<sub>opt</sub> <b>)</b> Statement<br><b>for</b> <b>(</b> <b>var</b> VariableDeclarationListNoIn<b>;</b> Expression<sub>opt</sub> <b>;</b> Expression<sub>opt</sub> <b>)</b> Statement<br><b>for</b> <b>(</b> LeftHandSideExpression <b>in</b> Expression <b>)</b> Statement<br><b>for</b> <b>(</b> <b>var</b> VariableDeclarationNoIn <b>in</b> Expression <b>)</b> Statement</p>
      <p>
      </p>
      <p>ContinueStatement <b>:</b><b>	</b>See 12.7</p>
      <p><b>continue ;</b><b><br>continue</b><b> </b>[no LineTerminator here] Identifier <b>;</b></p>
      <p>
      </p>
      <p>BreakStatement <b>:</b><b>	</b>See 12.8</p>
      <p><b>break ;</b><b><br>break </b>[no LineTerminator here] Identifier <b>;</b></p>
      <p>
      </p>
      <p>ReturnStatement <b>:</b><b>	</b>See 12.9</p>
      <p><b>return ;</b><b><br>return </b>[no LineTerminator here] Expression <b>;</b></p>
      <p>
      </p>
      <p>WithStatement <b>:</b><b>	</b>See 12.10</p>
      <p><b>with</b> <b>(</b> Expression <b>)</b> Statement</p>
      <p>
      </p>
      <p>SwitchStatement <b>:</b><b>	</b>See 12.11</p>
      <p><b>switch</b> <b>(</b> Expression <b>)</b> CaseBlock</p>
      <p>
      </p>
      <p>CaseBlock <b>:</b><b>	</b>See 12.11</p>
      <p><b>{</b> CaseClauses<sub>opt</sub> <b>}</b><br><b>{</b> CaseClauses<sub>opt</sub> DefaultClause CaseClauses<sub>opt</sub> <b>}</b></p>
      <p>
      </p>
      <p>CaseClauses <b>:</b><b>	</b>See 12.11</p>
      <p>CaseClause<span><br>CaseClauses CaseClause</span></p>
      <p>
      </p>
      <p>CaseClause <b>:</b><b>	</b>See 12.11</p>
      <p><b>case</b> Expression <b>:</b> StatementList<sub>opt</sub></p>
      <p>
      </p>
      <p>DefaultClause <b>:</b><b>	</b>See 12.11</p>
      <p><b>default</b> <b>:</b> StatementList<sub>opt</sub></p>
      <p>
      </p>
      <p>LabelledStatement <b>:</b><b>	</b>See 12.12</p>
      <p>Identifier <b>:</b> Statement</p>
      <p>
      </p>
      <p>ThrowStatement <b>:</b><b>	</b>See 12.13</p>
      <p><b>throw </b>[no LineTerminator here] Expression <b>;</b></p>
      <p>
      </p>
      <p>TryStatement <b>:</b><b>	</b>See 12.14</p>
      <p><b>try</b> Block Catch<sub><br></sub><b>try</b> Block Finally<sub><br></sub><b>try</b> Block Catch Finally</p>
      <p>
      </p>
      <p>Catch <b>:</b><b>	</b>See 12.14</p>
      <p><b>catch</b> <b>( </b>Identifier <b>)</b> Block</p>
      <p>
      </p>
      <p>Finally <b>:</b>	See 12.14</p>
      <p><b>finally</b> Block</p>
      <p>DebuggerStatement <b>:</b><span>	See 12.15</span></p>
      <p><b>debugger</b> <b>;</b></p>
      <p>Functions and Programs</p>
      <p>FunctionDeclaration <b>:</b><span>	See clause 13</span></p>
      <p><b>function</b> Identifier <b>(</b> FormalParameterList<sub>opt</sub> <b>)</b> <b>{</b> FunctionBody <b>}</b></p>
      <p>
      </p>
      <p>FunctionExpression <b>:</b><span>	See clause 13</span></p>
      <p><b>function</b> Identifier<sub>opt</sub> <b>(</b> FormalParameterList<sub>opt</sub> <b>)</b> <b>{</b> FunctionBody <b>}</b></p>
      <p>
      </p>
      <p>FormalParameterList <b>:</b><span>	See clause 13</span></p>
      <p>Identifier<span><br>FormalParameterList </span><b>,</b> Identifier</p>
      <p>
      </p>
      <p>FunctionBody <b>:</b>	See clause 13</p>
      <p>SourceElements<sub>opt</sub></p>
      <p>
      </p>
      <p>Program <b>:</b>	See clause 14</p>
      <p>SourceElements<sub>opt</sub></p>
      <p>
      </p>
      <p>SourceElements <b>:</b>	See clause 14</p>
      <p>SourceElement<span><br>SourceElements SourceElement</span></p>
      <p>
      </p>
      <p>SourceElement <b>:</b>	See clause 14</p>
      <p>Statement<span><br>FunctionDeclaration</span></p>
      <p>Universal Resource Identifier Character Classes</p>
      <p>uri <b>:::</b>	See 15.1.3</p>
      <p>uriCharacters<sub>opt</sub></p>
      <p>
      </p>
      <p>uriCharacters <b>:::</b><span>	See 15.1.3</span></p>
      <p>uriCharacter uriCharacters<sub>opt</sub></p>
      <p>
      </p>
      <p>uriCharacter <b>:::</b><span>	See 15.1.3</span></p>
      <p>uriReserved<span><br>uriUnescaped</span><span><br>uriEscaped</span></p>
      <p>
      </p>
      <p>uriReserved <b>:::</b> <b>one of</b>	See 15.1.3</p>
      <p>
        <b>;  /  ?  :  @  &amp;  =  +  $  ,</b>
      </p>
      <p>
      </p>
      <p>uriUnescaped <b>:::</b><span>	See 15.1.3</span></p>
      <p>uriAlpha<span><br>DecimalDigit</span><span><br>uriMark</span></p>
      <p>
      </p>
      <p>uriEscaped <b>:::</b>	See 15.1.3</p>
      <p><b>%</b> HexDigit HexDigit</p>
      <p>
      </p>
      <p>uriAlpha <b>:::</b> <b>one of</b>	See 15.1.3</p>
      <p>
        <b>a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z</b>
        <b><br>A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z</b>
      </p>
      <p>
      </p>
      <p>uriMark <b>:::</b> <b>one of</b>	See 15.1.3</p>
      <p>
        <b>-  _  .  !  ~  *  '  (  )</b>
      </p>
      <p>Regular Expressions</p>
      <p>Pattern <b>::</b>	See 15.10.1</p>
      <p>Disjunction</p>
      <p>
      </p>
      <p>Disjunction <b>::</b><b>	</b>See 15.10.1</p>
      <p>Alternative<span><br> Alternative </span><b>|</b> Disjunction</p>
      <p>
      </p>
      <p>Alternative <b>::</b><b>	</b>See 15.10.1</p>
      <p>[empty]<span><br>Alternative Term</span></p>
      <p>
      </p>
      <p>Term <b>::</b><b>	</b>See 15.10.1</p>
      <p>Assertion<span><br>Atom</span><span><br>Atom Quantifier</span></p>
      <p>
      </p>
      <p>Assertion <b>::</b><b>	</b>See 15.10.1</p>
      <p><b>^</b><br><b>$</b><br><b>\ b</b><br><b>\ B</b><br><b>(</b><b> </b><b>?</b><b> </b><b>=</b><b> </b>Disjunction <b>)</b><br><b>(</b><b> </b><b>?</b><b> </b><b>!</b><b> </b>Disjunction <b>)</b></p>
      <p>
      </p>
      <p>Quantifier <b>::</b><b>	</b>See 15.10.1</p>
      <p>QuantifierPrefix<span><br>QuantifierPrefix</span><b> ?</b></p>
      <p>
      </p>
      <p>QuantifierPrefix <b>::</b><b>	</b>See 15.10.1</p>
      <p><b>*</b><b><br>+</b><br><b>?</b><br><b>{</b> DecimalDigits <b>}</b><br><b>{</b> DecimalDigits<b> </b><b>,</b><b> </b><b>}</b><br><b>{</b> DecimalDigits<b> </b><b>,</b> DecimalDigits <b>}</b></p>
      <p>
      </p>
      <p>Atom <b>::</b><b>	</b>See 15.10.1</p>
      <p>PatternCharacter<br>.<br><b>\ </b>AtomEscape<span><br>CharacterClass</span><b><br>(</b><b> </b>Disjunction <b>)</b><br><b>(</b><b> </b><b>?</b><b> </b><b>:</b><b> </b>Disjunction <b>)</b></p>
      <p><i>PatternCharacter</i> ::	See 15.10.1</p>
      <p><i>SourceCharacter</i> <b>but not</b><b> </b><b>one of-</b><b><br></b><b>    ^  $  \  .  *  +  ?  (  )  [  ]  {  }  |</b></p>
      <p>
      </p>
      <p>AtomEscape <b>::</b><b>	</b>See 15.10.1</p>
      <p>DecimalEscape<span><br>CharacterEscape</span><span><br>CharacterClassEscape</span></p>
      <p>
      </p>
      <p>CharacterEscape <b>::</b><b>	</b>See 15.10.1</p>
      <p>ControlEscape<br><b>c</b> ControlLetter<span><br>HexEscapeSequence</span><span><br>UnicodeEscapeSequence</span><span><br>IdentityEscape</span></p>
      <p>
      </p>
      <p>ControlEscape <b>::</b> <b>one of</b>	See 15.10.1</p>
      <p>
        <b>f  n  r  t  v</b>
      </p>
      <p>
      </p>
      <p>ControlLetter <b>::</b> <b>one of</b>	See 15.10.1</p>
      <p>
        <b>a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z</b>
        <b><br>A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z</b>
      </p>
      <p>
      </p>
      <p>IdentityEscape <b>::</b><b>	</b>See 15.10.1</p>
      <p>SourceCharacter <b>but not</b><b> </b>IdentifierPart<br>&lt;ZWJ&gt;<span><br>&lt;ZWNJ&gt;</span></p>
      <p>
      </p>
      <p>DecimalEscape <b>::</b><b>	</b>See 15.10.1</p>
      <p>DecimalIntegerLiteral  [lookahead ∈ DecimalDigit]</p>
      <p>
      </p>
      <p>CharacterClassEscape <b>::</b><b>  </b><b>one of</b> 	See 15.10.1</p>
      <p>
        <b>d  D  s  S  w  W</b>
      </p>
      <p>
      </p>
      <p>CharacterClass  <b>::</b><b>	</b>See 15.10.1</p>
      <p><b>[ </b>[lookahead ∈ {<b>^</b>}]<b> </b>ClassRanges<b> ]</b><br><b>[ ^ </b>ClassRanges<b> ]</b></p>
      <p>
      </p>
      <p>ClassRanges <b>::</b><b>	</b>See 15.10.1</p>
      <p>[empty]<span><br>NonemptyClassRanges</span></p>
      <p>
      </p>
      <p>NonemptyClassRanges <b>::</b><b>	</b>See 15.10.1</p>
      <p>ClassAtom<span><br>ClassAtom NonemptyClassRangesNoDash</span><span><br>ClassAtom</span><b> – </b>ClassAtom ClassRanges</p>
      <p>
      </p>
      <p>NonemptyClassRangesNoDash <b>::</b><b>	</b>See 15.10.1</p>
      <p>ClassAtom<span><br>ClassAtomNoDash NonemptyClassRangesNoDash</span><span><br>ClassAtomNoDash</span><b> – </b>ClassAtom ClassRanges</p>
      <p>
      </p>
      <p>ClassAtom <b>::</b><b>	</b>See 15.10.1</p>
      <p>
        <b>-</b>
        <span><br>ClassAtomNoDash</span>
      </p>
      <p>
      </p>
      <p>ClassAtomNoDash <b>::</b><b>	</b>See 15.10.1</p>
      <p>SourceCharacter  <b>but not</b> <b>one of</b> <b>\</b> <b>or</b> <b>]</b><b> or</b> <b>-</b><br><b>\</b> ClassEscape</p>
      <p>
      </p>
      <p>ClassEscape <b>::</b><b>	</b>See 15.10.1</p>
      <p>DecimalEscape<br><b>b</b><span><br>CharacterEscape</span><b><br></b>CharacterClassEscape</p>
      <p>JSON</p>
      <p>JSON Lexical Grammar</p>
      <p><i>JSONWhiteSpace</i> <b>::</b> 	See 15.12.1.1</p>
      <p>&lt;TAB&gt;<span><br>&lt;CR&gt;</span><span><br>&lt;LF&gt;</span><span><br>&lt;SP&gt;</span></p>
      <p>
      </p>
      <p>JSONString <b>::</b> 	See 15.12.1.1</p>
      <p><b>" </b>JSONStringCharacters<sub>opt</sub> <b>"</b></p>
      <p>
      </p>
      <p>JSONStringCharacters <b>::</b><b>	</b> See 15.12.1.1</p>
      <p>JSONStringCharacter JSONStringCharacters<sub>opt</sub> </p>
      <p>
      </p>
      <p>JSONStringCharacter <b>::</b><b> </b><b>	</b> See 15.12.1.1</p>
      <p>SourceCharacter <b>but not one of</b> <b>"</b> <b>or</b> <b>\ </b><b>or</b> U+0000 <b>through</b> U+001F</p>
      <p><b>\</b> JSONEscapeSequence</p>
      <p>
      </p>
      <p>JSONEscapeSequence <b>::</b> <span>	See 15.12.1.1</span></p>
      <p>JSONEscapeCharacter</p>
      <p>UnicodeEscapeSequence </p>
      <p>
      </p>
      <p>JSONEscapeCharacter <b>::</b><b>  </b><b>one of</b><b>	</b> See 15.12.1.1</p>
      <p>
        <b> " / \ b f n r t</b>
      </p>
      <p>
      </p>
      <p>JSONNumber <b>::</b><b>	</b>See 15.12.1.1</p>
      <p><b>-</b><sub>opt</sub>  DecimalIntegerLiteral JSONFraction<sub>opt</sub>  ExponentPart<sub>opt</sub></p>
      <p>
      </p>
      <p>JSONFraction <b>::</b><b> </b><b>	</b>See 15.12.1.1</p>
      <p><b>.</b> DecimalDigits</p>
      <p>
      </p>
      <p>JSONNullLiteral <b>::</b><b>	</b>See 15.12.1.1</p>
      <p>NullLiteral</p>
      <p>
      </p>
      <p>JSONBooleanLiteral <b>::</b><b>	</b>See 15.12.1.1</p>
      <p>BooleanLiteral</p>
      <p>JSON Syntactic Grammar</p>
      <p>JSONText <b>:</b><span>	 </span>See 15.12.1.2</p>
      <p>JSONValue</p>
      <p>
      </p>
      <p>JSONValue <b>:</b><b> </b><b>	</b>See 15.12.1.2<span>	 </span></p>
      <p>JSONNullLiteral<span><br>JSONBooleanLiteral</span><span><br>JSONObject</span><span><br>JSONArray</span><span><br>JSONString</span><span><br>JSONNumber</span></p>
      <p>
      </p>
      <p>JSONObject <b>:</b><b> </b><b>	</b>See 15.12.1.2</p>
      <p><b>{ }</b><br><b>{</b> JSONMemberList <b>}</b></p>
      <p>
      </p>
      <p>JSONMember <b>:</b><b>	</b>See 15.12.1.2</p>
      <p>JSONString <b>:</b> JSONValue</p>
      <p>
      </p>
      <p>JSONMemberList <b>:</b><b>	</b>See 15.12.1.2</p>
      <p>JSONMember <span><br>JSONMemberList </span><b>,</b><b> </b>JSONMember </p>
      <p>
      </p>
      <p>JSONArray <b>:</b><b>	</b>See 15.12.1.2</p>
      <p><b>[ ]</b><br><b>[</b><b> </b>JSONElementList<b> ]</b></p>
      <p>
      </p>
      <p>JSONElementList <b>:</b><b> </b><b>	</b>See 15.12.1.2</p>
      <p>JSONValue<span><br>JSONElementList</span><b> ,</b> JSONValue</p>
      <p>
        <hr>
      </p>
      <p><span><br>(</span>normative)<br>{SEQ aaa \h }{SEQ table \r0\h }{SEQ figure \r0\h }<br>Additional ECMAScript Features for Web Browsers</p>
      <p>The ECMAScript language syntax and semantics defined in this annex are required when the ECMAScript host is a web browser. The content of this annex is normative but optional if the ECMAScript host is not a web browser.</p>
      <p>Additional Syntax</p>
      <p>Numeric Literals</p>
      <p>The syntax and semantics of 7.8.3 is extended as follows except that this extension is not allowed for strict mode code:</p>
      <p>Syntax</p>
      <p>NumericLiteral <b>::</b></p>
      <p>DecimalLiteral<span><br>HexIntegerLiteral</span><span><br>OctalIntegerLiteral</span></p>
      <p>OctalIntegerLiteral <b>::</b></p>
      <p><b>0</b> OctalDigit<span><br>OctalIntegerLiteral OctalDigit</span></p>
      <p>OctalDigit <b>::</b> <b>one of</b></p>
      <p>
        <b>0</b>
        <b>  </b>
        <b>1</b>
        <b>  </b>
        <b>2</b>
        <b>  </b>
        <b>3 </b>
        <b> </b>
        <b>4 </b>
        <b> </b>
        <b>5</b>
        <b>  </b>
        <b>6</b>
        <b>  </b>
        <b>7</b>
      </p>
      <p>Semantics</p>
      <p>The MV of <i>NumericLiteral</i> <b>::</b> <i>OctalIntegerLiteral</i> is the MV of <i>OctalIntegerLiteral</i>.</p>
      <p>The MV of <i>OctalDigit</i> <b>::</b> <b>0</b> is 0.</p>
      <p>The MV of <i>OctalDigit</i> <b>::</b> <b>1</b> is 1.</p>
      <p>The MV of <i>OctalDigit</i> <b>::</b> <b>2</b> is 2.</p>
      <p>The MV of <i>OctalDigit</i> <b>::</b> <b>3</b> is 3.</p>
      <p>The MV of <i>OctalDigit</i> <b>::</b> <b>4</b> is 4.</p>
      <p>The MV of <i>OctalDigit</i> <b>::</b> <b>5</b> is 5.</p>
      <p>The MV of <i>OctalDigit</i> <b>::</b> <b>6</b> is 6.</p>
      <p>The MV of <i>OctalDigit</i> <b>::</b> <b>7</b> is 7.</p>
      <p>The MV of <i>OctalIntegerLiteral </i><b>::</b> <b>0</b> <i>OctalDigit</i> is the MV of <i>OctalDigit</i>.</p>
      <p>The MV of <i>OctalIntegerLiteral </i><b>::</b> <i>OctalIntegerLiteral</i> <i>OctalDigit</i> is (the MV of <i>OctalIntegerLiteral</i> times 8) plus the MV of <i>OctalDigit</i>.</p>
      <p>String Literals</p>
      <p>The syntax and semantics of 7.8.4 is extended as follows except that this extension is not allowed for strict mode code:</p>
      <p>Syntax</p>
      <p>EscapeSequence <b>::</b></p>
      <p>CharacterEscapeSequence<span><br>OctalEscapeSequence</span><span><br>HexEscapeSequence</span><span><br>UnicodeEscapeSequence</span></p>
      <p>OctalEscapeSequence <b>::</b></p>
      <p>OctalDigit [lookahead ∈ DecimalDigit]<span><br>ZeroToThree OctalDigit </span>[lookahead ∈ DecimalDigit]<span><br>FourToSeven OctalDigit</span><span><br>ZeroToThree OctalDigit OctalDigit</span></p>
      <p>ZeroToThree <b>::</b> <b>one of</b></p>
      <p>
        <b>0  1  2  3</b>
      </p>
      <p>FourToSeven <b>::</b><b> </b><b>one of</b></p>
      <p>
        <b>4  5  6  7</b>
      </p>
      <p>Semantics</p>
      <p>The CV of <i>EscapeSequence </i><b>::</b> <i>OctalEscapeSequence</i> is the CV of the<i> OctalEscapeSequence</i>.</p>
      <p>The CV of <i>OctalEscapeSequence</i> <b>::</b> <i>OctalDigit</i> [lookahead ∈ <i>DecimalDigit</i>] is the character whose code unit value is the MV of the <i>OctalDigit</i>.</p>
      <p>The CV of <i>OctalEscapeSequence</i> <b>::</b> <i>ZeroToThree</i> <i>OctalDigit</i> [lookahead ∈ <i>DecimalDigit</i>] is the character whose code unit value is (8 times the MV of the <i>ZeroToThree</i>) plus the MV of the <i>OctalDigit</i>.</p>
      <p>The CV of <i>OctalEscapeSequence</i> <b>::</b> <i>FourToSeven</i> <i>OctalDigit</i> is the character whose code unit value is (8 times the MV of the <i>FourToSeven</i>) plus the MV of the <i>OctalDigit</i>.</p>
      <p>The CV of <i>OctalEscapeSequence</i> <b>::</b> <i>ZeroToThree</i> <i>OctalDigit</i> <i>OctalDigit</i> is the character whose code unit value is (64 (that is, 8<sup>2</sup>) times the MV of the <i>ZeroToThree</i>) plus (8 times the MV of the first <i>OctalDigit</i>) plus the MV of the second <i>OctalDigit</i>.</p>
      <p>The MV of <i>ZeroToThree</i> <b>::</b> <b>0</b> is 0.</p>
      <p>The MV of <i>ZeroToThree </i><b>::</b> <b>1</b> is 1.</p>
      <p>The MV of <i>ZeroToThree </i><b>::</b> <b>2</b> is 2.</p>
      <p>The MV of <i>ZeroToThree </i><b>::</b> <b>3</b> is 3.</p>
      <p>The MV of <i>FourToSeven</i> <b>::</b> <b>4</b> is 4.</p>
      <p>The MV of <i>FourToSeven</i> <b>::</b> <b>5</b> is 5.</p>
      <p>The MV of <i>FourToSeven</i> <b>::</b> <b>6</b> is 6.</p>
      <p>The MV of <i>FourToSeven</i> <b>::</b> <b>7</b> is 7.</p>
      <p>Additional Properties</p>
      <p>When the ECMAScript host is a web browser the following these additional properties  of the standard native objects are defined. </p>
      <p>escape (string)</p>
      <p>The <b>escape</b> function is a property of the global object. It computes a new version of a String value in which certain characters have been replaced by a hexadecimal escape sequence.</p>
      <p>For those characters being replaced whose code unit value is <b>0xFF </b>or less, a two-digit escape sequence of the form <b>%</b><i>xx</i> is used. For those characters being replaced whose code unit value is greater than <b>0xFF</b>, a four-digit escape sequence of the form <b>%u</b><i>xxxx</i> is used.</p>
      <p>When the <b>escape</b> function is called with one argument <i>string</i>, the following steps are taken:</p>
      <p>Call ToString(<i>string</i>).</p>
      <p>Compute the number of characters in Result(1).</p>
      <p>Let <i>R </i>be the empty string.</p>
      <p>Let <i>k</i> be 0.</p>
      <p>If <i>k</i> equals Result(2), return <i>R</i>.</p>
      <p>Get the character (represented as a 16-bit unsigned integer) at position <i>k</i> within Result(1).</p>
      <p>If Result(6) is one of the 69 nonblank characters<br><b>“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@*_+-./”</b><b><br></b>then go to step 13.</p>
      <p>If Result(6), is less than 256, go to step 11.</p>
      <p>Let <i>S</i> be a String containing six characters <b>“%u</b><i>wxyz</i><b>”</b> where <i>wxyz</i> are four hexadecimal digits encoding the value of Result(6).</p>
      <p>Go to step 14.</p>
      <p>Let <i>S</i> be a String containing three characters <b>“%</b><i>xy</i><b>”</b> where <i>xy</i> are two hexadecimal digits encoding the value of Result(6).</p>
      <p>Go to step 14.</p>
      <p>Let <i>S</i> be a String containing the single character Result(6).</p>
      <p>Let <i>R</i> be a new String value computed by concatenating the previous value of <i>R</i> and <i>S</i>.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Go to step 5.</p>
      <p>NOTE<span>	The encoding is partly based on the encoding described in RFC 1738, but the entire encoding specified in this standard is described above without regard to the contents of RFC 1738. This encoding does not reflect changes to RFC 1738 made by RFC 3986.</span></p>
      <p>unescape (string)</p>
      <p>The <b>unescape</b> function is a property of the global object. It computes a new version of a String value in which each escape sequence of the sort that might be introduced by the <b>escape</b> function is replaced with the character that it represents.</p>
      <p>When the <b>unescape</b> function is called with one argument <i>string</i>, the following steps are taken:</p>
      <p>Call ToString(<i>string</i>).</p>
      <p>Compute the number of characters in Result(1).</p>
      <p>Let <i>R</i> be the empty String.</p>
      <p>Let <i>k</i> be 0.</p>
      <p>If <i>k</i> equals Result(2), return <i>R</i>.</p>
      <p>Let <i>c</i> be the character at position <i>k</i> within Result(1).</p>
      <p>If <i>c</i> is not <b>%</b>, go to step 18.</p>
      <p>If <i>k</i> is greater than Result(2)−6, go to step 14.</p>
      <p>If the character at position <i>k</i>+1 within Result(1) is not <b>u</b>, go to step 14.</p>
      <p>If the four characters at positions <i>k</i>+2, <i>k</i>+3, <i>k</i>+4, and <i>k</i>+5 within Result(1) are not all hexadecimal digits, go to step 14.</p>
      <p>Let <i>c</i> be the character whose code unit value is the integer represented by the four hexadecimal digits at positions <i>k</i>+2,<i> k</i>+3, <i>k</i>+4, and <i>k</i>+5 within Result(1).</p>
      <p>Increase k by 5.</p>
      <p>Go to step 18.</p>
      <p>If <i>k</i> is greater than Result(2)−3, go to step 18.</p>
      <p>If the two characters at positions <i>k</i>+1 and <i>k</i>+2 within Result(1) are not both hexadecimal digits, go to step 18.</p>
      <p>Let <i>c</i> be the character whose code unit value is the integer represented by two zeroes plus the two hexadecimal digits at positions <i>k</i>+1 and <i>k</i>+2 within Result(1).</p>
      <p>Increase <i>k </i>by 2.</p>
      <p>Let <i>R</i> be a new String value computed by concatenating the previous value of <i>R</i> and <i>c</i>.</p>
      <p>Increase <i>k</i> by 1.</p>
      <p>Go to step 5.</p>
      <p>String.prototype.substr (start, length)</p>
      <p>The <b>substr</b> method takes two arguments, <i>start</i> and <i>length</i>, and returns a substring of the result of converting the this object to a String, starting from character position <i>start</i> and running for <i>length</i> characters (or through the end of the String if <i>length</i> is <b>undefined</b>). If <i>start</i> is negative, it is treated as (<i>sourceLength</i>+<i>start</i>) where <i>sourceLength</i> is the length of the String. The result is a String value, not a String object. The following steps are taken:</p>
      <p>Call ToString, giving it the <b>this</b> value as its argument.</p>
      <p>Call ToInteger(<i>start</i>).</p>
      <p>If <i>length</i> is <b>undefined</b>, use <b>+</b><b>∞</b>; otherwise call ToInteger(<i>length</i>).</p>
      <p>Compute the number of characters in Result(1).</p>
      <p>If Result(2) is positive or zero, use Result(2); else use max(Result(4)+Result(2),0).</p>
      <p>Compute min(max(Result(3),0), Result(4)–Result(5)).</p>
      <p>If Result(6) ≤ 0, return the empty String “”.</p>
      <p>Return a String containing Result(6) consecutive characters from Result(1) beginning with the character at position Result(5).</p>
      <p>The <b>length</b> property of the <b>substr</b> method is <b>2</b>.</p>
      <p>NOTE<span>	The </span><b>substr</b> function is intentionally generic; it does not require that its <b>this</b> value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
      <p>Date.prototype.getYear ( )</p>
      <p>NOTE<span>	The </span><b>getFullYear</b> method is preferred for nearly all purposes, because it avoids the “year 2000 problem.”</p>
      <p>When the <b>getYear</b> method is called with no arguments, the following steps are taken:</p>
      <p>Let <i>t</i> be this time value.</p>
      <p>If <i>t</i> is <b>NaN</b>, return <b>NaN</b>.</p>
      <p>Return YearFromTime(LocalTime(<i>t</i>)) − 1900.</p>
      <p>Date.prototype.setYear (year)</p>
      <p>NOTE<span>	The </span><b>setFullYear</b> method is preferred for nearly all purposes, because it avoids the “year 2000 problem.”</p>
      <p>When the <b>setYear</b> method is called with one argument <i>year</i>, the following steps are taken:</p>
      <p>Let <i>t</i> be the result of LocalTime(this time value); but if this time value is <b>NaN</b>, let <i>t</i> be <b>+0</b>.</p>
      <p>Call ToNumber(<i>year</i>).</p>
      <p>If Result(2) is<b> NaN</b>, set the [[PrimitiveValue]] internal property of the <b>this</b> value to <b>NaN</b> and return <b>NaN</b>.</p>
      <p>If Result(2) is not <b>NaN</b> and 0 ≤ ToInteger(Result(2)) ≤ 99 then Result(4) is ToInteger(Result(2)) + 1900. Otherwise, Result(4) is Result(2).</p>
      <p>Compute MakeDay(Result(4), MonthFromTime(<i>t</i>), DateFromTime(<i>t</i>)).</p>
      <p>Compute UTC(MakeDate(Result(5), TimeWithinDay(<i>t</i>))).</p>
      <p>Set the [[PrimitiveValue]] internal property of the <b>this</b> value to TimeClip(Result(6)).</p>
      <p>Return the value of the [[PrimitiveValue]] internal property of the <b>this</b> value.</p>
      <p>Date.prototype.toGMTString ( )</p>
      <p>NOTE<span>	The property </span><b>toUTCString</b> is preferred. The <b>toGMTString</b> property is provided principally for compatibility with old code. It is recommended that the <b>toUTCString</b> property be used in new ECMAScript code.</p>
      <p>The Function object that is the initial value of <b>Date.prototype.toGMTString</b> is the same Function object that is the initial value of <b>Date.prototype.toUTCString</b>.</p>
      <p>Other Additional Features</p>
      <p>The __proto__ pseudo property.</p>
      <p>Object.prototype.__proto__</p>
      <p>The initial value of the <b>__proto__</b> property of the Object prototype object is a data property whose initial value is  <b>null</b>. This property initially has the attributes { [[Writable]]: <b>true</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>true</b> }.</p>
      <p>Manipulations of this property as tracked by the Boolean valued primordial internal variable UnderscoreProtoEnabled.  The default initial value of UnderscoreProtoEnabled is true only if this property is initially present on the primordial Object prototype object.</p>
      <p>NOTE<span>	Any modification of this property or its attributes causes </span>UnderscoreProtoEnabled  to be set to <b>false</b>.</p>
      <p> Changes To Internal Methods__</p>
      <p>The definition of the [[Get]] internal method given in 8.12.3 is replaced with the following:</p>
      <p>If <i>P</i> is the string value <b>"__proto__"</b> and UnderscoreProtoEnabled is <b>true</b>, then </p>
      <p>Let <i>desc </i>be the result of calling the [[GetProperty]] internal method of <i>O </i>with property name <i>P</i>.</p>
      <p>If <i>desc </i>is not <b>undefined</b> and was create by step 1.a to describe the property defined in B.3.1.1 then,</p>
      <p>Return the value of the [[Prototype]] internal property of <i>O</i>.</p>
      <p>Continue by executing the steps of 8.12.3 starting with step 1.</p>
      <p>
      </p>
      <p>The definition of the [[Put]] internal method given in 8.12.5 is replaced with the following:</p>
      <p>If <i>P</i> is the string value <b>"__proto__"</b> and UnderscoreProtoEnabled is <b>true</b> and <i>O</i> is not the standard built-in Object prototype object, then </p>
      <p>Let <i>desc </i>be the result of calling the [[GetProperty]] internal method of <i>O </i>with property name <i>P</i>.</p>
      <p>If <i>desc </i>is not <b>undefined</b> and was create by step 1.a to describe the property defined in B.3.1.1 then,</p>
      <p>If the type of <i>V</i> is neither Object or Null, return</p>
      <p>Set the value of the [[Prototype]] internal property of O to V.</p>
      <p>Return.</p>
      <p>Continue by executing the steps of 8.12.5 starting with step 1.</p>
      <p>The definition of the [[Delete]] internal method given in 8.12.7 is replaced with the following:</p>
      <p>If UnderscoreProtoEnabled is <b>true</b><i> </i>and <i>P</i> is the string value <b>"__proto__"</b> and <i>O</i> is the standard built-in Object prototype object, then </p>
      <p>Set UnderscoreProtoEnabled to <b>false</b>.</p>
      <p>Continue by executing the steps of 8.12.7 starting with step 1.</p>
      <p>
      </p>
      <p>The definition of the [[DefineOwnProperty]] internal method given in 8.12.9 is replaced with the following:</p>
      <p>If UnderscoreProtoEnabled is <b>true</b><i> </i>and <i>P</i> is the string value <b>"__proto__"</b> and <i>O</i> is the standard built-in Object prototype object, then </p>
      <p>If any attribute contained in <i>Desc</i> is not present or has a different value from the corresponding attribute in { [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b> }then,</p>
      <p>Set UnderscoreProtoEnabled to <b>false</b>.</p>
      <p>Continue by executing the steps of 8.12.9 starting with step 1.</p>
      <p>
      </p>
      <p>
      </p>
      <p>__proto___ Object Initialisers _</p>
      <p>Definitions of two algorithms in 11.1.5 are replaced with the following:</p>
      <p>The production  PropertyNameAndValueList <b>:</b>  PropertyAssignment is evaluated as follows:</p>
      <p>Let <i>obj </i>be the result of creating a new object as if by the expression <b>new Object() </b>where <b>Object</b> is the standard built-in constructor with that name.</p>
      <p>Let <i>propId </i>be the result of evaluating <i>PropertyAssignment</i>.</p>
      <p>If <i>propId</i>.name is the string value <b>"__proto__"</b> and UnderscoreProtoEnabled is <b>true</b> and IsDataDescriptor(<i>propId</i>.descriptor) is <b>true</b>, then </p>
      <p>Let <i>v</i><i> </i>be <i>propId</i>.descriptor.value.</p>
      <p>If <i>desc </i><i>be </i><i>propId</i>.descriptor</p>
      <p>If the type of <i>v</i> is either Object or Null, </p>
      <p>Set the value of the [[Prototype]] internal property of <i>O</i> to <i>V</i>.</p>
      <p>Return.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>obj</i> with arguments <i>propId</i>.name, <i>propId</i>.descriptor, and <b>false</b>.</p>
      <p>Return <i>obj</i>.</p>
      <p>The production<span><br>     </span>PropertyNameAndValueList <b>:</b>  PropertyNameAndValueList <b>,</b> PropertyAssignment<span><br>is evaluated as follows:</span></p>
      <p>Let <i>obj</i> be the result of evaluating <i>PropertyNameAndValueList</i>.</p>
      <p>Let <i>propId</i> be the result of evaluating <i>PropertyAssignment</i>.</p>
      <p>Let <i>previous</i> be the result of calling the [[GetOwnProperty]] internal method of <i>obj</i> with argument <i>propId</i>.name.</p>
      <p>If <i>previous</i> is not <b>undefined</b> then throw a <b>SyntaxError</b> exception if any of the following conditions are true</p>
      <p>This production is contained in strict code and IsDataDescriptor(<i>previous</i>) is <b>true</b> and IsDataDescriptor(<i>propId</i>.descriptor) is <b>true</b>.</p>
      <p>IsDataDescriptor(<i>previous</i>) is <b>true</b> and IsAccessorDescriptor(<i>propId</i>.descriptor) is <b>true.</b></p>
      <p>IsAccessorDescriptor(<i>previous</i>) is <b>true</b> and IsDataDescriptor(<i>propId</i>.descriptor) is <b>true</b>.</p>
      <p>IsAccessorDescriptor(<i>previous</i>) is <b>true </b>and IsAccessorDescriptor(<i>propId</i>.descriptor) is <b>true </b>and<b> </b>either both <i>previous</i> and <i>propId</i>.descriptor have [[Get]] fields or both <i>previous</i> and <i>propId</i>.descriptor have [[Set]] fields</p>
      <p>If <i>propId</i>.name is the string value <b>"__proto__"</b> and UnderscoreProtoEnabled is <b>true</b> and IsDataDescriptor(<i>propId</i>.descriptor) is <b>true</b>, then </p>
      <p>Let <i>v</i><i> </i>be <i>propId</i>.descriptor.value.</p>
      <p>If <i>desc </i><i>be </i><i>propId</i>.descriptor</p>
      <p>If the type of <i>v</i> is either Object or Null, </p>
      <p>Set the value of the [[Prototype]] internal property of <i>O</i> to <i>V</i>.</p>
      <p>Return.</p>
      <p>Call the [[DefineOwnProperty]] internal method of <i>obj</i> with arguments <i>propId</i>.name, <i>propId</i>.descriptor, and <b>false</b>.</p>
      <p>Return <i>obj</i>.</p>
      <p>
      </p>
      <p>
      </p>
      <p><br>(informative)<br>{SEQ aaa \h }{SEQ table \r0\h }{SEQ figure \r0\h }<br>The Strict Mode of ECMAScript</p>
      <p>The strict mode restriction and exceptions</p>
      <p>The identifiers "<b>implements</b>", "<b>interface</b>", "<b>let</b>", "<b>package</b>", "<b>private</b>", "<b>pr</b><b>otected</b>", "<b>public</b>", "<b>static</b>", and "<b>yield</b>" are classified as <i>FutureReservedWord</i> tokens within strict mode code. (7.6.12).</p>
      <p>A conforming implementation, when processing strict mode code, may not extend the syntax of <i>NumericLiteral</i> (7.8.3) to include <i>OctalIntegerLiteral</i> as described in B.1.1.</p>
      <p>A conforming implementation, when processing strict mode code (see 10.1.1), may not extend the syntax of <i>EscapeSequence</i> to include <i>OctalEscapeSequence</i> as described in B.1.2.</p>
      <p>Assignment to an undeclared identifier or otherwise unresolvable reference does not create a property in the global object. When a simple assignment occurs within strict mode code, its <i>LeftHandSide </i>must not evaluate to an unresolvable Reference. If it does a <b>ReferenceError</b> exception is thrown (8.9.2). The <i>LeftHandSide </i>also may not be a reference to a data property with the attribute value {[[Writable]]:<b>false</b>}, to an accessor property with the attribute value {[[Set]]:<b>undefined</b>},<b>  </b>nor to a non-existent property of an object whose [[Extensible]] internal property has the value <b>false</b>. In these cases a <b>TypeError</b> exception is thrown (11.13.1).</p>
      <p>The identifier <b>eval</b> or <b>arguments</b> may not appear as the <i>LeftHandSideExpression</i> of an Assignment operator (11.13) or of a <i>PostfixExpression</i> (11.3) or as the <i>UnaryExpression</i> operated upon by a Prefix Increment (11.4.4) or a Prefix Decrement (11.4.5) operator. </p>
      <p>Arguments objects for strict mode functions define non-configurable accessor properties named "<b>caller</b>" and "<b>callee</b>" which throw a <b>TypeError </b>exception on access (10.6).</p>
      <p>Arguments objects for strict mode functions do not dynamically share their array indexed property values with the corresponding formal parameter bindings of their functions. (10.6).</p>
      <p>For strict mode functions, if an arguments object is created the binding of the local identifier <b>arguments</b> to the arguments object is immutable and hence may not be the target of an assignment expression. (10.5).</p>
      <p>It is a <b>SyntaxError</b> if strict mode code contains an <i>ObjectLiteral</i> with more than one definition of any data property (11.1.5).</p>
      <p>It is a <b>SyntaxError</b> if the <i>Identifier</i> <b>"eval"</b> or the <i>Identifier </i><b>"arguments"</b> occurs as the <i>Identifier</i> in a PropertySetParameterList<b> </b>of a PropertyAssignment that is contained in strict code or if its <i>FunctionBody</i> is strict code (11.1.5).</p>
      <p>Strict mode eval code cannot instantiate variables or functions in the variable environment of the caller to eval. Instead, a new variable environment is created and that environment is used for declaration binding instantiation for the eval code (10.4.2).</p>
      <p>If <b>this</b> is evaluated within strict mode code, then the <b>this </b>value is not coerced to an object. A <b>this</b> value of <b>null</b> or <b>undefined</b> is not converted to the global object and primitive values are not converted to wrapper objects. The <b>this</b> value passed via a function call (including calls made using <b>Function.prototype.apply</b> and <b>Function.prototype.call</b><b>)</b> do not coerce the passed this value to an object (10.4.3, 11.1.1, 15.3.4.3, 15.3.4.4).</p>
      <p>When a <b>delete</b> operator occurs within strict mode code, a <b>SyntaxError </b>is thrown if its <i>UnaryExpression</i> is a direct reference to a variable, function argument, or function name(11.4.1).</p>
      <p>When a <b>delete</b> operator occurs within strict mode code, a <b>TypeError</b> is thrown if the property to be deleted has the attribute { [[Configurable]]:<b>false</b> } (11.4.1).</p>
      <p>It is a <b>SyntaxError</b> if a <i>VariableDeclaration</i> or <i>VariableDeclarationNoIn</i> occurs within strict code and its  <i>Identifier</i> is <b>eval</b><b> </b>or<b> </b><b>arguments</b> (12.2.1).</p>
      <p>Strict mode code may not include a <i>WithStatement</i>. The occurrence of a <i>WithStatement</i> in such a context is an <b>SyntaxError</b> (12.10).</p>
      <p>It is a <b>SyntaxError</b> if a <i>TryStatement</i> with a  <i>Catch</i> occurs within strict code and the <i>Identifier</i> of the <i>Catch</i> production is <b>eval</b> or<b> </b><b>arguments</b> (12.14.1)</p>
      <p>It is a <b>SyntaxError</b> if  the identifier <b>eval</b> or<b> </b><b>arguments</b> appears within a <i>FormalParameterList</i> of a strict mode <i>FunctionDeclaration</i> or <i>FunctionExpression</i> (13.1)</p>
      <p>A strict mode function may not have two or more formal parameters that have the same name. An attempt to create such a function using a <i>FunctionDeclaration</i>, <i>FunctionExpression</i>, or <b>Function</b> constructor is a <b>SyntaxError </b>(13.1, 15.3.2).</p>
      <p>An implementation may not extend, beyond that defined in this specification, the meanings within strict mode functions of properties named <b>caller</b> or <b>arguments</b> of function instances. ECMAScript code may not create or modify properties with these names on function objects that correspond to strict mode functions (10.6, 13.2, 15.3.4.5.3).</p>
      <p>It is a <b>SyntaxError</b> to use within strict mode code the identifiers <b>eval</b> or <b>arguments</b> as the <i>Identifier</i> of a <i>FunctionDeclaration</i> or <i>FunctionExpression</i> or as a formal parameter name (13.1). Attempting to dynamically define such a strict mode function using the <b>Function</b> constructor (15.3.2) will throw a <b>SyntaxError</b> exception.</p>
      <p>
      </p>
      <p><br>(informative)<br>{SEQ aaa \h }{SEQ table \r0\h }{SEQ figure \r0\h }<br>Corrections and Clarifications in the 5<sup>th</sup> Edition<span><br>with Possible 3</span><sup>rd</sup> Edition Compatibility Impact</p>
      <p>Throughout: In the Edition 3 specification the meaning of phrases such as “as if by the expression <b>new Array()</b>” are subject to misinterpretation. In the Edition 5 specification text for all internal references and invocations of standard built-in objects and methods has been clarified by making it explicit that the intent is that the actual built-in object is to be used rather than the current dynamic value of the correspondingly named property. </p>
      <p>11.8.1: ECMAScript generally uses a left to right evaluation order, however the Edition 3 specification language for the &gt; and &lt;= operators resulted in a partial right to left order. The specification has been corrected for these operators such that it now specifies a full left to right evaluation order. However, this change of order is potentially observable if side-effects occur during the evaluation process.</p>
      <p>11.1.4: Edition 5 clarifies the fact that a trailing comma at the end of an <i>ArrayInitialiser</i> does not add to the length of the array. This is not a semantic change from Edition 3 but some implementations may have previously misinterpreted this.</p>
      <p>11.2.3: Edition 5 reverses the order of steps 2 and 3 of the algorithm.  The original order as specified in Editions 1 through 3 was incorrectly specified such that side-effects of evaluating <i>Arguments</i> could affect the result of evaluating <i>MemberExpression</i>.</p>
      <p>12.4: In Edition 3, an object is created, as if by <b>new Object()</b>to serve as the scope for resolving the name of the exception parameter passed to a <b>catch</b> clause of a <b>try</b> statement. If the actual exception object is a function and it is called from within the <b>catch</b> clause, the scope object will be passed as the <b>this</b> value of the call. The body of the function can then define new properties on its <b>this</b> value and those property names become visible identifiers bindings within the scope of the <b>catch</b> clause after the function returns. In Edition 5, when an exception parameter is called as a function, <b>undefined</b> is passed as the <b>this</b> value.</p>
      <p>13: In Edition 3, the algorithm for the production <i>FunctionExpression</i> with an <i>Identifier</i> adds an object created as if by <b>new Object()</b> to the scope chain to serve as a scope for looking up the name of the function. The identifier resolution rules (10.1.4 in Edition 3) when applied to such an object will, if necessary, follow the object’s prototype chain when attempting to resolve an identifier.  This means all the properties of Object.prototype are visible as identifiers within that scope.  In practice most implementations of Edition 3 have not implemented this semantics.  Edition 5 changes the specified semantics by using a Declarative Environment Record to bind the name of the function.</p>
      <p>14: In Edition 3, the algorithm for the production <i>SourceElements </i><b>:</b> <i>SourceElements SourceElement </i>did not correctly propagate statement result values in the same manner as <i>Block</i>. This could result in the <b>eval</b> function producing an incorrect result when evaluating a <i>Program</i> text. In practice most implementations of Edition 3 have implemented the correct propagation rather than what was specified in Edition 5.</p>
      <p>15.10.6: RegExp.prototype is now a RegExp object rather than an instance of Object. The value of its [[Class]] internal property which is observable using Object.prototype.toString is now “RegExp” rather than “Object”.</p>
      <p>
        <hr>
      </p>
      <p><br>(informative)<br>{SEQ aaa \h }{SEQ table \r0\h }{SEQ figure \r0\h }<br>Additions and Changes in the 5<sup>th</sup> Edition that<span><br>Introduce Incompatibilities with the 3</span><sup>rd</sup> Edition</p>
      <p>7.1: Unicode format control characters are no longer stripped from ECMAScript source text before processing. In Edition 5, if such a character appears in a <i>StringLiteral</i> or <i>RegularExpressionLiteral</i> the character will be incorporated into the literal where in Edition 3 the character would not be incorporated into the literal.</p>
      <p>7.2: Unicode character &lt;BOM&gt; is now treated as whitespace  and its presence in the middle of what appears to be an identifier could result in a syntax error which would not have occurred in Edition 3</p>
      <p>7.3: Line terminator characters that are preceded by an escape sequence are now allowed within a string literal token.  In Edition 3 a syntax error would have been produced.</p>
      <p>7.8.5: Regular expression literals now return a unique object each time the literal is evaluated. This change is detectable by any programs that test the object identity of such literal values or that are sensitive to the shared side effects.</p>
      <p>7.8.5: Edition 5 requires early reporting of any possible RegExp constructor errors that would be produced when converting a <i>RegularExpressionLiteral</i> to a RegExp object. Prior to Edition 5 implementations were permitted to defer the reporting of such errors until the actual execution time creation of the object.</p>
      <p>7.8.5: In Edition 5 unescaped “/” characters may appear as a <i>CharacterClass</i> in a regular expression literal. In Edition 3 such a character would have been interpreted as the final character of the literal.</p>
      <p>10.4.2: In Edition 5, indirect calls to the <b>eval</b> function use the global environment as both the variable environment and lexical environment for the eval code.  In Edition 3, the variable and lexical environments of the caller of an indirect <b>eval</b> was used as the environments for the eval code.</p>
      <p>15.4.4: In Edition 5 all methods of <b>Array.prototype</b> are intentionally generic. In Edition 3 <b>toString</b> and <b>toLocaleString</b> were not generic and would throw a <b>TypeError</b> exception if applied to objects that were not instances of Array.</p>
      <p>10.6: In Edition 5 the array indexed properties of argument objects that correspond to actual formal parameters are enumerable.  In Edition 3, such properties were not enumerable.</p>
      <p>10.6: In Edition 5 the value of the [[Class]] internal property of an arguments object is <b>"Arguments"</b>.  In Edition 3, it was <b>"Object"</b>. This is observable if <b>toString</b> is called as a method of an arguments object. </p>
      <p>12.6.4: for-in statements no longer throw a <b>TypeError</b> if the <b>in</b> expression evaluates to <b>null</b> or <b>undefined</b>. Instead, the statement behaves as if the value of the expression was an object with no enumerable properties.</p>
      <p>15: In Edition 5, the following new properties are defined on built-in objects that exist in Edition 3: <b>Object.getPrototypeOf</b>,<b> </b><b>Object.getOwnPropertyDescriptor</b>,<b> Object.getOwnPropertyNames</b>, <b>Object.create</b><b>,</b> <b>Object.defineProperty</b>, <b>Object.defineProperties</b>, <b>Object.seal</b>, <b>Object.freeze</b>, <b>Object.preventExtensions</b>, <b>Object.isSealed</b>, <b>Object.isFrozen</b>, <b>Object.isExtensible</b>, <b>Object.keys</b>, <b>Function.prototype.bind</b>, <b>Array.prototype.indexOf</b>,  <b>Array.prototype.lastIndexOf</b>, <b>Array.prototype.every</b>, <b>Array.prototype.some</b>, <b>Array.prototype.forEach</b>, <b>Array.prototype.map</b>, <b>Array.prototype.filter</b>, <b>Array.prototype.reduce</b>, <b>Array.prototype.reduceRight</b>, <b>String.prototype.trim</b>, <b>Date.now</b>, <b>Date.prototype.toISOString, Date.prototype.toJSON</b>.</p>
      <p>15: Implementations are now required to ignore extra arguments to standard built-in methods unless otherwise explicitly specified. In Edition 3 the handling of extra arguments was unspecified and implementations were explicitly allowed to throw a <b>TypeError</b> exception.</p>
      <p>15.1.1: The value properties <b>NaN</b>, <b>Infinity</b>, and <b>undefined</b> of the Global Object have been changed to be read-only properties.</p>
      <p>15.1.2.1. Implementations are no longer permitted to restrict the use of eval in ways that are not a direct call.  In addition, any invocation of eval that is not a direct call uses the global environment as its variable environment rather than the caller’s variable environment.</p>
      <p>15.1.2.2: The specification of the function <b>parseInt</b> no longer allows implementations to treat Strings beginning with a <b>0</b> character as octal values.</p>
      <p>15.3.4.3: In Edition 3, a <b>TypeError</b> is thrown if the second argument passed to <b>Function.prototype.apply</b> is neither an array object nor an arguments object. In Edition 5, the second argument may be any kind of generic array-like object that has a valid <b>length</b> property.</p>
      <p>15.3.4.3, 15.3.4.4: In Edition 3 passing <b>undefined</b> or <b>null</b> as the first argument to either <b>Function.prototype.apply</b> or <b>Function.prototype.call</b> causes the global object to be passed to the indirectly invoked target function as the <b>this</b> value. If the first argument is a primitive value the result of calling ToObject on the primitive value is passed as the <b>this</b> value. In Edition 5, these transformations are not performed and the actual first argument value is passed as the <b>this</b> value. This difference will normally be unobservable to existing ECMAScript Edition 3 code because a corresponding transformation takes place upon activation of the target function. However, depending upon the implementation, this difference may be observable by host object functions called using <b>apply</b> or <b>call</b>. In addition, invoking a standard built-in function in this manner with <b>null</b> or <b>undefined</b> passed as the this value will in many cases cause behaviour in Edition 5 implementations that differ from Edition 3 behaviour. In particular, in Edition 5 built-in functions that are specified to actually use the passed <b>this</b> value as an object typically throw a <b>TypeError</b> exception if passed <b>null</b> or <b>undefined</b> as the <b>this</b> value.</p>
      <p>15.3.5.2: In Edition 5, the <b>prototype</b> property of Function instances is not enumerable. In Edition 3, this property was enumerable.</p>
      <p>15.5.5.2: In Edition 5, the individual characters of a String object’s [[PrimitiveValue] may be accessed as array indexed properties of the String object. These properties are non-writable and non-configurable and shadow any inherited properties with the same names. In Edition 3, these properties did not exist and ECMAScript code could dynamically add and remove writable properties with such names and could access inherited properties with such names.  </p>
      <p>15.9.4.2: <b>Date.parse</b> is now required to first attempt to parse its argument as an ISO format string. Programs that use this format but depended upon implementation specific behaviour (including failure) may behave differently.</p>
      <p>15.10.2.12: In Edition 5, <b>\s</b> now additionally matches &lt;BOM&gt;.</p>
      <p>15.10.4.1: In Edition 3, the exact form of the String value of the <b>source</b> property of an object created by the <b>RegExp</b> constructor is implementation defined. In Edition 5, the String must conform to certain specified requirements and hence may be different from that produced by an Edition 3 implementation.</p>
      <p>15.10.6.4: In Edition 3, the result of <b>RegExp.prototype.toString</b> need not be derived from the value of the RegExp object’s <b>source</b> property.  In Edition 5 the result must be derived from the <b>source</b> property in a specified manner and hence may be different from the result produced by an Edition 3 implementation.</p>
      <p>15.11.2.1, 15.11.4.3:  In Edition 5, if an initial value for the <b>message</b> property of an Error object is not specified via the <b>Error</b> constructor the initial value of the property is the empty String.  In Edition 3, such an initial value is implementation defined.</p>
      <p>15.11.4.4:  In Edition 3, the result of <b>Error.prototype.toString</b> is implementation defined.  In Edition 5, the result is fully specified and hence may differ from some Edition 3 implementations.</p>
      <p>15.12: In Edition 5, the name <b>JSON</b> is defined in the global environment. In Edition 3, testing for the presence of that name will show it to be undefined unless it is defined by the program or implementation.</p>
      <p>
      </p>
      <p>
      </p>
      <p>
        <hr>
      </p>
      <p><br>(informative)<br>{SEQ aaa \h }{SEQ table \r0\h }{SEQ figure \r0\h }<span><br>Technical</span>ly Significant Corrections and Clarifications in the 5.1 Edition</p>
      <p>7.8.4: CV definitions added for <i>DoubleStringCharacter</i> <b>::</b> <i>LineContinuation</i> and <i>SingleStringCharacter</i> <b>::</b> <i>LineContinuation</i>.</p>
      <p>10.2.1.1.3: The argument S is not ignored. It controls whether an exception is thrown when attempting to set an immutable binding.</p>
      <p>10.2.1.2.2: In algorithm step 5, <b>true</b> is passed as the last argument to [[DefineOwnProperty]].</p>
      <p>10.5: Former algorithm step 5.e is now 5.f and a new step 5.e was added to restore compatibility with 3<sup>rd</sup> Edition when redefining global functions.</p>
      <p>11.5.3: In the final bullet item, use of IEEE 754 round-to-nearest mode is specified.</p>
      <p>12.6.3: Missing ToBoolean restored in step 3.a.ii of both algorithms.</p>
      <p>12.6.4: Additional final sentences in each of the last two paragraphs clarify certain property enumeration requirements.</p>
      <p>12.7, 12.8, 12.9: BNF modified to clarify that a <b>continue</b> or <b>break</b> statement without an <i>Identifier</i> or a <b>return</b> statement without an <i>Expression</i> may have a <i>LineTerminator</i> before the semi-colon.</p>
      <p>12.14: Step 3 of algorithm 1 and step 2.a of algorithm 3 are corrected such that the value field of <i>B</i> is passed as a parameter rather than <i>B</i> itself.</p>
      <p>15.1.2.2: In step 2 of algorithm, clarify that <i>S</i> may be the empty string.</p>
      <p>15.1.2.3: In step 2 of algorithm clarify that <i>trimmedString</i> may be the empty string.</p>
      <p>15.1.3:  Added notes clarifying that ECMAScript’s URI syntax is based upon RFC 2396 and not the newer RFC 3986. In the algorithm for Decode, a step was removed that immediately preceded the current step 4.d.vii.10.a because it tested for a condition that cannot occur.</p>
      <p>15.2.3.7: Corrected use of variable <i>P</i> in steps 5 and 6 of algorithm.</p>
      <p>15.2.4.2: Edition 5 handling of <b>undefined</b> and <b>null</b> as <b>this</b> value caused existing code to fail.  Specification modified to maintain compatibility with such code. New steps 1 and 2 added to the algorithm.</p>
      <p>15.3.4.3: Steps 5 and 7 of Edition 5 algorithm have been deleted because they imposed requirements upon the <i>argArray</i> argument that are inconsistent with other uses of generic array-like objects. </p>
      <p>15.4.4.12: In step 9.a, incorrect reference to <i>relativeStart</i> was replaced with a reference to <i>actualStart</i>. </p>
      <p>15.4.4.15: Clarified that the default value for <i>fromIndex</i> is the length minus 1 of the array.</p>
      <p>15.4.4.18: In step 9 of the algorithm, <b>undefined</b> is now the specified return value.</p>
      <p>15.4.4.22: In step 9.c.ii the first argument to the [[Call]] internal method has been changed to <b>undefined</b> for consistency with the definition of Array.prototype.reduce.</p>
      <p>15.4.5.1: In Algorithm steps 3.l.ii and 3.l.iii the variable name was inverted resulting in an incorrectly inverted test.</p>
      <p>15.5.4.9: Normative requirement concerning canonically equivalent strings deleted from paragraph following algorithm because it is listed as a recommendation in NOTE 2.</p>
      <p>15.5.4.14: In split algorithm step 11.a and 13.a, the positional order of the arguments to <i>SplitMatch</i> was corrected to match the actual parameter signature of <i>SplitMatch</i>.  In step 13.a.iii.7.d, <i>lengthA</i> replaces <i>A</i>.length.</p>
      <p>15.5.5.2: In first paragraph, removed the implication that the individual character property access had “array index” semantics. Modified algorithm steps 3 and 5 such that they do not enforce “array index” requirement.</p>
      <p>15.9.1.15: Specified legal value ranges for fields that lacked them. Eliminated “time-only” formats. Specified default values for all optional fields.</p>
      <p>15.10.2.2: The step numbers of the algorithm for the internal closure produced by step 2 were incorrectly numbered in a manner that implied that they were steps of the outer algorithm.</p>
      <p>15.10.2.6: In the abstract operation <i>IsWordChar</i> the first character in the list in step 3 is “<b>a</b>” rather than “<b>A</b>”.</p>
      <p>15.10.2.8: In the algorithm for the closure returned by the abstract operation <i>CharacterSetMatcher</i>, the variable defined by step 3 and passed as an argument in step 4 was renamed to <i>ch</i> in order to avoid a name conflict with a formal parameter of the closure.</p>
      <p>15.10.6.2: Step 9.e was deleted because It performed an extra increment of <i>i</i>.</p>
      <p>15.11.1.1: Removed requirement that the message own property is set to the empty String when the <i>message</i> argument is <b>undefined</b>.</p>
      <p>15.11.1.2: Removed requirement that the message own property is set to the empty String when the <i>message</i> argument is <b>undefined</b>.</p>
      <p>15.11.4.4: Steps 6-10 modified/added to correctly deal with missing or empty message property value.</p>
      <p>15.11.1.2: Removed requirement that the message own property is set to the empty String when the <i>message</i> argument is <b>undefined</b>.</p>
      <p>15.12.3: In step 10.b.iii of the <i>JA</i> internal operation, the last element of the concatenation is “<b>]</b>”.</p>
      <p>B.2.1: Added to NOTE that the encoding is based upon RFC 1738 rather than the newer RFC 3986.</p>
      <p>Annex C: An item was added corresponding to 7.6.12 regarding <i>FutureReservedWords</i> in strict mode.</p>
      <p>Bibliography</p>
      <p>IEEE Std 754-2008: IEEE Standard for Floating-Point Arithmetic. Institute of Electrical and Electronic Engineers, New York (2008)</p>
      <p>The Unicode Consortium. The Unicode Standard, Version 3.0, defined by: The Unicode Standard, Version 3.0 (Reading, MA, Addison-Wesley, 2000. ISBN 0-201-61633-5)</p>
      <p>Unicode Inc. (2010), Unicode Technical Report #15: Unicode Normalization Forms</p>
      <p>ISO 8601:2004(E) <i>Data elements and interchange formats – Information</i><i> </i><i>interchange -- Representation of dates and times</i></p>
      <p>RFC 1738 "Uniform Resource Locators (URL)", available at &lt;http://tools.ietf.org/html/rfc1738&gt;</p>
      <p>RFC 2396 "Uniform Resource Identifiers (URI): Generic Syntax", available at &lt;http://tools.ietf.org/html/rfc2396&gt;</p>
      <p>RFC 3629 "UTF-8, a transformation format of ISO 10646", available at &lt;http://tools.ietf.org/html/rfc3629&gt;</p>
      <p>RFC 4627 "The application/json Media Type for JavaScript Object Notation (JSON)" , available at &lt;http://tools.ietf.org/html/rfc4627&gt;</p>
      <p>
      </p>
      <p>
      </p>
      <p>
      </p>
      <p>
      </p>
    </section>
  </body>
</html>
